---
title: "External Integrations"
description: "Connect your Compozy tools to external services through MCP servers and HTTP APIs"
---

Connect your Compozy tools to external services through the Model Context Protocol (MCP) or simple HTTP integrations. This guide covers practical patterns for integrating with external systems.

<Callout type="info">
Compozy uses a simple HTTP-based MCP proxy (port 8081) to connect to external MCP servers. For direct API integrations, create TypeScript tools with HTTP client functionality.
</Callout>

## Integration Overview

<FeatureCardList>
  <FeatureCard
    icon="Plug"
    title="MCP Integration"
    description="Use Model Context Protocol servers for external tools"
  />
  <FeatureCard
    icon="Globe"
    title="HTTP APIs"
    description="Simple HTTP client integration for REST APIs"
  />
  <FeatureCard
    icon="Key"
    title="Authentication"
    description="API keys via environment variables"
  />
  <FeatureCard
    icon="AlertCircle"
    title="Error Handling"
    description="Basic error handling and timeouts"
  />
</FeatureCardList>

## MCP Integration

The Model Context Protocol (MCP) provides a standardized way to integrate external tools. Compozy's MCP proxy service (running on port 8081) manages connections to MCP servers.

### Basic MCP Configuration

MCP servers can be configured in workflows or agents:

```yaml
# workflow.yaml
resource: workflow
id: external-integration-example
description: Workflow using external MCP servers

# Register MCP servers
mcps:
  - id: filesystem
    transport: stdio
    command: npx
    args: ["-y", "@modelcontextprotocol/server-filesystem", "/workspace"]
    env:
      LOG_LEVEL: "info"
      
  - id: api-server
    transport: sse
    url: "http://localhost:3001/mcp"
    env:
      API_KEY: "{{ .env.API_KEY }}"

agents:
  - id: integration_agent
    instructions: |
      You have access to filesystem and API tools through MCP.
      Use these tools to read files and make API calls as needed.

tasks:
  - id: use_external_tools
    type: basic
    agent: integration_agent
    prompt: |
      Read the configuration file from /workspace/config.json
      and use the API server to fetch data based on the configuration.
```

**Key points about MCP integration:**
- MCP servers are registered when the workflow starts
- The MCP proxy manages server lifecycle and communication
- Agents can use tools from any registered MCP server
- Supports both stdio (local processes) and SSE (HTTP) transports

## HTTP Client Integration

For direct HTTP API integrations, create TypeScript tools that handle authentication and error handling.

### Basic HTTP Client

Create a simple HTTP client tool for API integrations:

```yaml
# tools/http-client.yaml
resource: "tool"
id: "http-client"
description: "HTTP client for external API calls"
timeout: "30s"

input:
  type: "object"
  properties:
    url:
      type: "string"
      format: "uri"
      description: "API endpoint URL"
    method:
      type: "string"
      enum: ["GET", "POST", "PUT", "DELETE"]
      default: "GET"
    headers:
      type: "object"
      additionalProperties:
        type: "string"
    body:
      description: "Request body for POST/PUT"
  required: ["url"]

output:
  type: "object"
  properties:
    status:
      type: "integer"
    data:
      description: "Response data"
    error:
      type: "string"
  required: ["status"]
```

**Implementation with error handling:**
```typescript
// tools/http-client.ts
interface HttpClientInput {
  url: string;
  method?: string;
  headers?: Record<string, string>;
  body?: unknown;
}

export async function run(input: HttpClientInput) {
  try {
    const response = await fetch(input.url, {
      method: input.method || 'GET',
      headers: {
        'Content-Type': 'application/json',
        ...input.headers,
      },
      body: input.body ? JSON.stringify(input.body) : undefined,
      signal: AbortSignal.timeout(30000), // 30 second timeout
    });

    const data = await response.json();

    return {
      status: response.status,
      data: data,
      error: response.ok ? undefined : `HTTP ${response.status}`,
    };
  } catch (error) {
    return {
      status: 0,
      data: null,
      error: error.message,
    };
  }
}
```

**Usage in workflow:**
```yaml
tasks:
  - id: call-api
    type: basic
    $use: tool(local::tools.#(id=="http-client"))
    with:
      url: "https://api.example.com/data"
      method: "GET"
      headers:
        Authorization: "Bearer {{ .env.API_TOKEN }}"
    outputs:
      api_data: "{{ .output.data }}"
```

## Authentication Patterns

### API Key Authentication

The simplest and most common authentication method uses API keys stored in environment variables:

```yaml
# tools/api-client.yaml
resource: "tool"
id: "api-client"
description: "HTTP client with API key authentication"
timeout: "30s"

input:
  type: "object"
  properties:
    endpoint:
      type: "string"
      description: "API endpoint path"
    method:
      type: "string"
      enum: ["GET", "POST", "PUT", "DELETE"]
      default: "GET"
    data:
      description: "Request body for POST/PUT"
  required: ["endpoint"]

output:
  type: "object"
  properties:
    status:
      type: "integer"
    data:
      description: "Response data"
    error:
      type: "string"
  required: ["status"]

env:
  API_BASE_URL: "{{ .env.API_BASE_URL }}"
  API_KEY: "{{ .env.API_KEY }}"
```

**Implementation with environment variables:**
```typescript
// tools/api-client.ts
interface ApiClientInput {
  endpoint: string;
  method?: string;
  data?: unknown;
}

export async function run(input: ApiClientInput) {
  // Access environment variables set in the tool configuration
  const baseUrl = process.env.API_BASE_URL;
  const apiKey = process.env.API_KEY;
  
  if (!baseUrl || !apiKey) {
    return {
      status: 0,
      error: 'Missing required environment variables: API_BASE_URL, API_KEY'
    };
  }
  
  try {
    const response = await fetch(`${baseUrl}${input.endpoint}`, {
      method: input.method || 'GET',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: input.data ? JSON.stringify(input.data) : undefined,
      signal: AbortSignal.timeout(30000), // 30 second timeout
    });
    
    const data = await response.json();
    
    return {
      status: response.status,
      data: data,
      error: response.ok ? undefined : `HTTP ${response.status}`,
    };
  } catch (error) {
    return {
      status: 0,
      data: null,
      error: error.message,
    };
  }
}
```

**Usage in workflow:**
```yaml
# workflow.yaml
tasks:
  - id: fetch-user-data
    type: basic
    $use: tool(local::tools.#(id=="api-client"))
    with:
      endpoint: "/users/{{ .workflow.input.user_id }}"
      method: "GET"
    outputs:
      user_data: "{{ .output.data }}"
      
  - id: update-user
    type: basic
    $use: tool(local::tools.#(id=="api-client"))
    with:
      endpoint: "/users/{{ .workflow.input.user_id }}"
      method: "PUT"
      data:
        name: "{{ .workflow.input.new_name }}"
        updated_at: "{{ now }}"
    condition: "{{ .workflow.input.update_user }}"
```

### Bearer Token Authentication

For services that use bearer tokens:

```typescript
// tools/bearer-auth-client.ts
interface BearerAuthInput {
  url: string;
  method?: string;
  token?: string; // Optional, can use env var
  data?: unknown;
}

export async function run(input: BearerAuthInput) {
  // Use provided token or fall back to environment variable
  const token = input.token || process.env.BEARER_TOKEN;
  
  if (!token) {
    return {
      success: false,
      error: 'No bearer token provided'
    };
  }
  
  try {
    const response = await fetch(input.url, {
      method: input.method || 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
      body: input.data ? JSON.stringify(input.data) : undefined,
    });
    
    return {
      success: response.ok,
      status: response.status,
      data: await response.json(),
    };
  } catch (error) {
    return {
      success: false,
      error: error.message,
    };
  }
}
```

## Error Handling Patterns

### Retry Logic

Implement simple retry logic for transient failures:

```typescript
// tools/retry-client.ts
interface RetryClientInput {
  url: string;
  method?: string;
  data?: unknown;
  maxRetries?: number;
  retryDelay?: number;
}

export async function run(input: RetryClientInput) {
  const maxRetries = input.maxRetries || 3;
  const retryDelay = input.retryDelay || 1000;
  
  let lastError: Error;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(input.url, {
        method: input.method || 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${process.env.API_TOKEN}`,
        },
        body: input.data ? JSON.stringify(input.data) : undefined,
        signal: AbortSignal.timeout(30000),
      });
      
      if (!response.ok && attempt < maxRetries) {
        // Retry on 5xx errors
        if (response.status >= 500) {
          await new Promise(resolve => setTimeout(resolve, retryDelay * attempt));
          continue;
        }
      }
      
      return {
        success: response.ok,
        status: response.status,
        data: await response.json(),
        attempts: attempt,
      };
    } catch (error) {
      lastError = error;
      if (attempt < maxRetries) {
        await new Promise(resolve => setTimeout(resolve, retryDelay * attempt));
        continue;
      }
    }
  }
  
  return {
    success: false,
    error: lastError.message,
    attempts: maxRetries,
  };
}
```

### Timeout Handling

Properly handle timeouts for long-running requests:

```typescript
// tools/timeout-client.ts
interface TimeoutClientInput {
  url: string;
  timeout?: number; // milliseconds
  method?: string;
  data?: unknown;
}

export async function run(input: TimeoutClientInput) {
  const timeout = input.timeout || 30000; // Default 30 seconds
  
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    const response = await fetch(input.url, {
      method: input.method || 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
      body: input.data ? JSON.stringify(input.data) : undefined,
      signal: controller.signal,
    });
    
    clearTimeout(timeoutId);
    
    return {
      success: response.ok,
      status: response.status,
      data: await response.json(),
    };
  } catch (error) {
    if (error.name === 'AbortError') {
      return {
        success: false,
        error: `Request timed out after ${timeout}ms`,
      };
    }
    return {
      success: false,
      error: error.message,
    };
  }
}
```

## Practical Integration Examples

### GitHub API Integration

A practical example of using the GitHub API through a simple HTTP client:

```typescript
// tools/github-client.ts
interface GitHubInput {
  endpoint: string;
  method?: string;
  data?: unknown;
}

export async function run(input: GitHubInput) {
  const baseUrl = 'https://api.github.com';
  const token = process.env.GITHUB_TOKEN;
  
  if (!token) {
    return {
      status: 0,
      error: 'Missing required environment variable: GITHUB_TOKEN'
    };
  }
  
  try {
    const response = await fetch(`${baseUrl}${input.endpoint}`, {
      method: input.method || 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json',
      },
      body: input.data ? JSON.stringify(input.data) : undefined,
      signal: AbortSignal.timeout(30000),
    });
    
    const data = await response.json();
    
    return {
      status: response.status,
      data: data,
      error: response.ok ? undefined : data.message,
    };
  } catch (error) {
    return {
      status: 0,
      data: null,
      error: error.message,
    };
  }
}
```

**What this integration provides:**
- Simple GitHub API access using personal access tokens
- Standard REST API operations (GET, POST, PUT, DELETE)
- Proper error handling and timeout management
- Response includes status code and data

### Slack Integration Example

Here's a practical example of integrating with Slack's Web API:

```typescript
// tools/slack-client.ts
interface SlackInput {
  method: string; // e.g., 'chat.postMessage', 'users.list'
  params?: Record<string, any>;
}

export async function run(input: SlackInput) {
  const token = process.env.SLACK_BOT_TOKEN;
  
  if (!token) {
    return {
      ok: false,
      error: 'Missing required environment variable: SLACK_BOT_TOKEN'
    };
  }
  
  try {
    const response = await fetch(`https://slack.com/api/${input.method}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(input.params || {}),
      signal: AbortSignal.timeout(30000),
    });
    
    const data = await response.json();
    
    if (!data.ok) {
      return {
        ok: false,
        error: data.error || 'Unknown Slack API error',
      };
    }
    
    return data;
  } catch (error) {
    return {
      ok: false,
      error: error.message,
    };
  }
}
```

**Usage in workflow:**
```yaml
tasks:
  - id: send-notification
    type: basic
    $use: tool(local::tools.#(id=="slack-client"))
    with:
      method: "chat.postMessage"
      params:
        channel: "{{ .workflow.input.channel }}"
        text: "Task completed: {{ .workflow.input.task_name }}"
```

**What this provides:**
- Simple Slack API integration using bot tokens
- Support for any Slack Web API method
- Proper error handling with Slack's response format
- Easy to extend for specific Slack operations



## Best Practices

### Error Handling

Always implement proper error handling in your integrations:

```typescript
// tools/resilient-api-client.ts
export async function run(input: ApiInput) {
  try {
    const response = await fetch(input.url, {
      method: input.method || 'GET',
      headers: input.headers,
      body: input.body ? JSON.stringify(input.body) : undefined,
      signal: AbortSignal.timeout(input.timeout || 30000),
    });
    
    if (!response.ok) {
      return {
        status: response.status,
        error: `HTTP ${response.status}: ${response.statusText}`,
        retryable: response.status >= 500 || response.status === 429
      };
    }
    
    const data = await response.json();
    return { status: response.status, data };
    
  } catch (error) {
    if (error.name === 'AbortError') {
      return { status: 0, error: 'Request timeout', retryable: true };
    }
    return { status: 0, error: error.message, retryable: false };
  }
}
```

### Rate Limiting

Implement rate limiting to avoid overwhelming external services:

```typescript
// Simple rate limiter
class RateLimiter {
  private requests: number[] = [];
  
  constructor(
    private maxRequests: number,
    private windowMs: number
  ) {}
  
  canMakeRequest(): boolean {
    const now = Date.now();
    this.requests = this.requests.filter(time => now - time < this.windowMs);
    
    if (this.requests.length < this.maxRequests) {
      this.requests.push(now);
      return true;
    }
    
    return false;
  }
}

const limiter = new RateLimiter(10, 60000); // 10 requests per minute

export async function run(input: ApiInput) {
  if (!limiter.canMakeRequest()) {
    return { status: 429, error: 'Rate limit exceeded' };
  }
  
  // Make the API call...
}
```

### Environment Configuration

Keep your integration configurations flexible:

```yaml
# tools/configurable-api.yaml
resource: "tool"
id: "configurable-api"
description: "Flexible API client with environment-based configuration"

env:
  API_BASE_URL: "{{ .env.API_BASE_URL }}"
  API_KEY: "{{ .env.API_KEY }}"
  TIMEOUT: "{{ .env.API_TIMEOUT | default '30000' }}"
  RETRY_ATTEMPTS: "{{ .env.API_RETRY_ATTEMPTS | default '3' }}"

input:
  type: "object"
  properties:
    endpoint:
      type: "string"
      description: "API endpoint path"
    method:
      type: "string"
      enum: ["GET", "POST", "PUT", "DELETE"]
      default: "GET"
    data:
      description: "Request body data"
```

## CLI Integration

Compozy provides CLI commands for managing external integrations:

<Tabs items={["MCP Commands", "Integration Development"]}>
<Tab value="MCP Commands">

```bash
# Start MCP proxy service
compozy mcp-proxy start

# Test MCP server connections
compozy mcp test-connection filesystem

# Validate external tool configurations
compozy config validate --external

# Debug MCP communication
compozy dev --mcp-debug
```

</Tab>
<Tab value="Integration Development">

```bash
# Initialize project with integration templates
compozy init --template integrations

# Start development server with MCP debugging
compozy dev --watch

# Show current configuration including MCP settings
compozy config show

# Run authentication setup for external services
compozy auth create-user --name "Integration Test"
```

</Tab>
</Tabs>

For complete CLI documentation, see:
- [CLI Overview](/docs/cli/overview)
- [MCP Commands](/docs/cli/mcp-commands)

## Related Documentation

<ReferenceCardList>
  <ReferenceCard
    title="Advanced Patterns"
    href="/docs/core/tools/advanced-patterns"
    description="Essential patterns for resilient tools with state management and error handling"
  />
  <ReferenceCard
    title="Testing & Debugging"
    href="/docs/core/tools/testing-debugging"
    description="Test your integrations with comprehensive debugging strategies"
  />
  <ReferenceCard
    title="Performance & Security"
    href="/docs/core/tools/performance-security"
    description="Optimize performance and secure your tool integrations"
  />
  <ReferenceCard
    title="MCP Integration Patterns"
    href="/docs/core/mcp/integration-patterns"
    description="Learn how to integrate MCP servers with agents and workflows"
  />
  <ReferenceCard
    title="TypeScript Development"
    href="/docs/core/tools/typescript-development"
    description="Build custom tools using TypeScript in Compozy's runtime"
  />
  <ReferenceCard
    title="Runtime Environment"
    href="/docs/core/tools/runtime-environment"
    description="Understand the Bun runtime environment and security features"
  />
</ReferenceCardList>
