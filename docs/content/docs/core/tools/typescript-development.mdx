---
title: "TypeScript Development"
description: Build sophisticated tools using TypeScript that extend your agents' capabilities. This guide covers development setup, best practices, and patterns for creating reliable, performant, and secure tools.
---

## Quick Start

Get up and running with TypeScript tool development in minutes:

<Steps>
  <Step title="Set up your project structure" icon="FolderTree">
    Create the recommended directory layout with organized tool files, type definitions, and configuration files for maintainable development.

    <ProjectStructure
      structure={[
        {
          id: "my-project",
          name: "my-project/",
          children: [
            {
              id: "tools",
              name: "tools/",
              children: [
                { id: "data-processor", name: "data-processor.ts" },
                { id: "api-client", name: "api-client.ts" },
                { id: "index", name: "index.ts" }
              ]
            },
            {
              id: "types",
              name: "types/",
              children: [
                { id: "tools-types", name: "tools.d.ts" }
              ]
            },
            { id: "package-json", name: "package.json" },
            { id: "tsconfig", name: "tsconfig.json" },
            { id: "compozy-yaml", name: "compozy.yaml" }
          ]
        }
      ]}
      initialSelectedId="tools"
      initialExpandedItems={["my-project", "tools", "types"]}
    />
  </Step>

  <Step title="Configure TypeScript for Bun" icon="Settings">
    Set up TypeScript compiler options optimized for Bun's runtime environment with modern ES features and strict type checking.

    ```json
    {
      "compilerOptions": {
        "target": "ES2022",
        "lib": ["ES2022", "DOM"],
        "module": "ESNext",
        "moduleResolution": "bundler",
        "strict": true,
        "skipLibCheck": true,
        "isolatedModules": true
      }
    }
    ```
  </Step>

  <Step title="Install essential dependencies" icon="Package">
    Add Zod for runtime validation and TypeScript development dependencies to ensure type safety and robust error handling.

    ```bash
    bun add zod                    # Runtime validation
    bun add -d typescript @types/node
    ```
  </Step>

  <Step title="Create your first tool" icon="Code">
    Build a simple greeting tool with Zod schema validation, multi-language support, and proper TypeScript typing as a foundation.

    ```typescript
    // tools/greeting.ts
    import { z } from 'zod';

    const inputSchema = z.object({
      name: z.string(),
      language: z.enum(['en', 'es', 'fr']).default('en')
    });

    type Input = z.infer<typeof inputSchema>;

    export async function greeting(input: Input) {
      const { name, language } = inputSchema.parse(input);

      const greetings = {
        en: `Hello, ${name}!`,
        es: `Â¡Hola, ${name}!`,
        fr: `Bonjour, ${name}!`
      };

      return {
        message: greetings[language],
        timestamp: new Date().toISOString()
      };
    }
    ```
  </Step>
</Steps>

## Core Development Patterns

<AccordionGroup>
  <Accordion title="Input Validation with Zod">
    Use Zod for runtime type validation and parsing:

    ```typescript
    import { z } from 'zod';

    // Define strict input schema
    const dataProcessorSchema = z.object({
      data: z.array(z.record(z.unknown())).min(1),
      operation: z.enum(['filter', 'map', 'sort']),
      options: z.object({
        field: z.string().optional(),
        direction: z.enum(['asc', 'desc']).default('asc')
      }).optional()
    });

    export async function processData(input: unknown) {
      // Parse and validate input (throws if invalid)
      const { data, operation, options } = dataProcessorSchema.parse(input);

      // Type-safe processing with validated data
      switch (operation) {
        case 'filter':
          return data.filter(item =>
            options?.field ? item[options.field] : true
          );
        case 'sort':
          return [...data].sort((a, b) => {
            const field = options?.field || 'id';
            const direction = options?.direction || 'asc';
            const result = String(a[field]).localeCompare(String(b[field]));
            return direction === 'asc' ? result : -result;
          });
        default:
          return data;
      }
    }
    ```

    <Callout type="tip">
    Zod provides excellent TypeScript integration and runtime validation in one package.
    </Callout>
  </Accordion>

  <Accordion title="Structured Error Handling">
    Implement consistent error handling across all tools:

    ```typescript
    // Shared error handling utility
    export function withErrorHandling<T extends unknown[], R>(
      fn: (...args: T) => Promise<R>
    ) {
      return async (...args: T): Promise<{ success: true; data: R } | { success: false; error: string }> => {
        try {
          const result = await fn(...args);
          return { success: true, data: result };
        } catch (error) {
          const message = error instanceof Error ? error.message : 'Unknown error occurred';
          return { success: false, error: message };
        }
      };
    }

    // Usage in tools
    export const safeApiClient = withErrorHandling(async (input: ApiInput) => {
      const response = await fetch(input.url, {
        method: input.method || 'GET',
        headers: input.headers
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return response.json();
    });
    ```
  </Accordion>

  <Accordion title="Async Operations & Concurrency">
    Handle concurrent operations safely:

    ```typescript
    import pLimit from 'p-limit';

    // Controlled concurrency for external calls
    const limit = pLimit(5); // Max 5 concurrent operations

    export async function batchProcessor(input: BatchInput) {
      const { items, concurrency = 5 } = input;
      const limitedProcess = pLimit(concurrency);

      // Process items with controlled concurrency
      const results = await Promise.allSettled(
        items.map(item =>
          limitedProcess(() => processSingleItem(item))
        )
      );

      return {
        total: items.length,
        successful: results.filter(r => r.status === 'fulfilled').length,
        failed: results.filter(r => r.status === 'rejected').length,
        results: results.map((result, index) => ({
          index,
          status: result.status,
          data: result.status === 'fulfilled' ? result.value : null,
          error: result.status === 'rejected' ? result.reason.message : null
        }))
      };
    }
    ```
  </Accordion>

  <Accordion title="Environment Configuration">
    Safely access environment variables:

    ```typescript
    // Environment configuration utility
    class ToolConfig {
      static getRequired(key: string): string {
        const value = process.env[key];
        if (!value) {
          throw new Error(`Required environment variable ${key} is not set`);
        }
        return value;
      }

      static getOptional(key: string, defaultValue: string): string {
        return process.env[key] || defaultValue;
      }

      static getBoolean(key: string, defaultValue: boolean): boolean {
        const value = process.env[key];
        if (!value) return defaultValue;
        return value.toLowerCase() === 'true';
      }
    }

    // Usage in API client
    export async function authenticatedRequest(input: ApiInput) {
      const apiKey = ToolConfig.getRequired('API_KEY');
      const baseUrl = ToolConfig.getRequired('API_BASE_URL');
      const timeout = parseInt(ToolConfig.getOptional('API_TIMEOUT', '30000'));

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);

      try {
        const response = await fetch(`${baseUrl}${input.endpoint}`, {
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
          },
          signal: controller.signal
        });

        return await response.json();
      } finally {
        clearTimeout(timeoutId);
      }
    }
    ```

    <Callout type="warning">
    Environment variables must be explicitly allowed in your [runtime configuration](/docs/core/tools/runtime-environment#environment-variables).
    </Callout>
  </Accordion>
</AccordionGroup>

## Tool Export Patterns

<Tabs items={["Default Export (Recommended)", "Configuration-Based"]}>
  <Tab value="Default Export (Recommended)">
    Export tools as a structured object:

    ```typescript
    // tools/index.ts
    import { greeting } from './greeting';
    import { dataProcessor } from './data-processor';
    import { apiClient } from './api-client';

    // Export all tools in organized object
    export default {
      // Utility tools
      greeting,

      // Data processing
      'data-processor': dataProcessor,
      'data-validator': dataValidator,

      // External integrations
      'api-client': apiClient,
      'webhook-handler': webhookHandler
    };
    ```
  </Tab>

  <Tab value="Configuration-Based">
    Define tools through configuration:

    ```typescript
    // tools/registry.ts
    interface ToolDefinition {
      id: string;
      name: string;
      description: string;
      handler: Function;
      schema?: any;
    }

    const toolRegistry: ToolDefinition[] = [
      {
        id: 'greeting',
        name: 'Personalized Greeting',
        description: 'Generate greetings in multiple languages',
        handler: greeting,
        schema: greetingSchema
      },
      {
        id: 'data-processor',
        name: 'Data Processor',
        description: 'Process and transform data arrays',
        handler: dataProcessor,
        schema: dataProcessorSchema
      }
    ];

    // Export as keyed object
    export default Object.fromEntries(
      toolRegistry.map(tool => [tool.id, tool.handler])
    );

    // Also export metadata for documentation
    export const toolMetadata = toolRegistry;
    ```
  </Tab>
</Tabs>

## Testing Your Tools

Write comprehensive tests to ensure reliability:

```typescript
// tests/greeting.test.ts
import { describe, it, expect } from 'bun:test';
import { greeting } from '../tools/greeting';

describe('Greeting Tool', () => {
  it('should generate English greeting by default', async () => {
    const result = await greeting({ name: 'Alice' });

    expect(result.message).toBe('Hello, Alice!');
    expect(result.timestamp).toBeDefined();
  });

  it('should support multiple languages', async () => {
    const spanish = await greeting({ name: 'Carlos', language: 'es' });
    const french = await greeting({ name: 'Marie', language: 'fr' });

    expect(spanish.message).toBe('Â¡Hola, Carlos!');
    expect(french.message).toBe('Bonjour, Marie!');
  });

  it('should validate input schema', async () => {
    expect(async () => {
      await greeting({ name: 123 } as any); // Invalid input
    }).toThrow();
  });
});

// Integration test with mocked dependencies
describe('API Client Tool', () => {
  it('should handle successful API calls', async () => {
    // Mock fetch globally for Bun
    globalThis.fetch = async () => new Response(
      JSON.stringify({ success: true, data: 'test' }),
      { status: 200 }
    );

    const result = await apiClient({
      url: 'https://api.example.com/test',
      method: 'GET'
    });

    expect(result.data).toEqual({ success: true, data: 'test' });
  });
});
```

<Callout type="tip">
Use Bun's built-in test runner with `bun test` for fast, TypeScript-native testing.
</Callout>

## Debugging and Development

<AccordionGroup>
  <Accordion title="Debug Logging">
    Add structured logging for development:

    ```typescript
    const DEBUG = process.env.DEBUG === 'true';

    function debug(message: string, data?: any) {
      if (DEBUG) {
        console.error(`[DEBUG] ${new Date().toISOString()} ${message}`, data ? JSON.stringify(data, null, 2) : '');
      }
    }

    export async function debuggableProcessor(input: ProcessorInput) {
      debug('Processing started', { inputSize: JSON.stringify(input).length });

      try {
        const result = await processData(input);
        debug('Processing completed', { outputSize: JSON.stringify(result).length });
        return result;
      } catch (error) {
        debug('Processing failed', { error: error.message });
        throw error;
      }
    }
    ```
  </Accordion>

  <Accordion title="Performance Monitoring">
    Track execution performance:

    ```typescript
    interface PerformanceMetrics {
      duration: number;
      memoryUsed: number;
      operationsCount: number;
    }

    export function withPerformanceTracking<T extends unknown[], R>(
      fn: (...args: T) => Promise<R>,
      operationName: string
    ) {
      return async (...args: T): Promise<R & { _performance?: PerformanceMetrics }> => {
        const startTime = performance.now();
        const startMemory = process.memoryUsage().heapUsed;

        try {
          const result = await fn(...args);

          const endTime = performance.now();
          const endMemory = process.memoryUsage().heapUsed;

          const metrics: PerformanceMetrics = {
            duration: endTime - startTime,
            memoryUsed: endMemory - startMemory,
            operationsCount: 1 // Can be customized per tool
          };

          // Include performance data in development
          if (process.env.NODE_ENV === 'development') {
            return { ...result, _performance: metrics } as R & { _performance: PerformanceMetrics };
          }

          return result;
        } catch (error) {
          debug(`Performance tracking failed for ${operationName}`, error);
          throw error;
        }
      };
    }
    ```
  </Accordion>
</AccordionGroup>

## Best Practices

<FeatureCardList>
  <FeatureCard
    title="Type Safety First"
    description="Use strict TypeScript configuration and Zod for runtime validation"
    icon="Shield"
    size="sm"
  />
  <FeatureCard
    title="Error Boundaries"
    description="Implement consistent error handling with proper error types"
    icon="AlertTriangle"
    size="sm"
  />
  <FeatureCard
    title="Performance Aware"
    description="Monitor execution time and memory usage for optimization"
    icon="Zap"
    size="sm"
  />
  <FeatureCard
    title="Built-in Testing"
    description="Write tests using Bun's native test runner for reliability"
    icon="CheckCircle"
    size="sm"
  />
</FeatureCardList>

<List>
  <ListItem title="Single Responsibility" icon="Target">
    Each tool should focus on one specific operation or domain
  </ListItem>
  <ListItem title="Input Validation" icon="ShieldCheck">
    Always validate inputs using Zod schemas with descriptive error messages
  </ListItem>
  <ListItem title="Resource Management" icon="Gauge">
    Set appropriate timeouts and handle cleanup properly
  </ListItem>
  <ListItem title="Error Handling" icon="AlertTriangle">
    Use structured error responses that agents can understand and act upon
  </ListItem>
  <ListItem title="Documentation" icon="FileText">
    Include JSDoc comments for complex functions and type definitions
  </ListItem>
  <ListItem title="Testing" icon="TestTube">
    Write unit tests for all tools and integration tests for complex workflows
  </ListItem>
</List>

<Callout type="info">
Start simple with basic validation and error handling, then add advanced patterns like caching and plugins as your tools mature.
</Callout>

## Related Documentation

<ReferenceCardList>
  <ReferenceCard
    title="Runtime Environment"
    description="Understand the Bun execution environment and security model"
    href="/docs/core/tools/runtime-environment"
  />
  <ReferenceCard
    title="Agent Integration"
    description="Learn how agents discover and use your tools"
    href="/docs/core/agents/tools"
  />
</ReferenceCardList>
