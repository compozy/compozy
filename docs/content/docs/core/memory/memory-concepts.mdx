---
title: "Memory Concepts & Architecture"
description: "Understanding Compozy's memory system architecture, concepts, and design principles"
---

## Core Architecture

The memory system consists of several key components that work together to provide reliable memory management:

### Memory Manager
The Memory Manager (`engine/memory/manager.go`) is the central component that:
- Creates and retrieves memory instances based on resource configurations
- Evaluates dynamic key templates using workflow context
- Manages memory instance lifecycle and cleanup
- Coordinates with privacy controls and token management

### Memory Instances
Memory instances represent individual memory containers that:
- Store conversation messages and context data
- Implement different memory types (token-based, message-count-based, buffer)
- Handle automatic cleanup and eviction based on configured policies
- Provide thread-safe operations for concurrent access

### Template Engine
The template engine enables dynamic memory keys by:
- Evaluating Go templates with workflow context
- Supporting variables like `{{.workflow.input.user_id}}` 
- Creating unique memory instances per user, session, or conversation
- Resolving memory references at runtime

### Redis Storage
Redis serves as the persistent storage layer providing:
- Fast key-value storage for messages and metadata
- Atomic operations for thread-safe updates
- TTL-based automatic cleanup
- Scalable storage for multiple memory instances

## Memory Types

Compozy supports three memory management strategies:

### Token-Based Memory
Best for managing LLM context windows and token costs:

```yaml
resource: memory
id: conversation_memory
type: token_based
max_tokens: 4000
max_context_ratio: 0.8
```

**How it works:**
- Tracks token count of stored messages
- Automatically removes old messages when limit exceeded
- Optimizes for LLM context window management
- Configurable flush strategies for memory management

**Use cases:**
- Chat applications with LLM integration
- Conversation history management
- Token budget optimization

### Message Count-Based Memory
Simple memory management based on message quantity:

```yaml
resource: memory
id: simple_chat
type: message_count_based
max_messages: 100
```

**How it works:**
- Counts total messages stored
- Removes oldest messages when limit reached
- Simple FIFO (First In, First Out) eviction
- Predictable memory usage patterns

**Use cases:**
- Simple chat applications
- Fixed-size conversation windows
- Development and testing

### Buffer Memory
Basic storage without automatic eviction:

```yaml
resource: memory
id: debug_memory
type: buffer
max_messages: 50
```

**How it works:**
- Stores messages until manually cleared
- No automatic eviction or cleanup
- Useful for debugging and development
- Manual memory management required

**Use cases:**
- Development and debugging
- Temporary data storage
- Simple applications without complex requirements

## Dynamic Key Templates

Memory instances use template-based keys for flexible memory organization:

### Template Syntax
```yaml
# User-specific memory
key: "user:{{.workflow.input.user_id}}"

# Session-based memory
key: "session:{{.session_id}}:conversation"

# Multi-level hierarchy
key: "project:{{.project_id}}:agent:{{.agent_id}}"
```

### Available Variables
Common template variables include:
- `{{.workflow.input.*}}` - Workflow input parameters
- `{{.session_id}}` - Current session identifier
- `{{.agent_id}}` - Agent identifier
- `{{.user_id}}` - User identifier
- Custom variables from workflow context

### Key Resolution
The template engine resolves keys by:
1. Evaluating templates with current workflow context
2. Creating unique memory instances per resolved key
3. Enabling memory isolation between users, sessions, or contexts

## Memory Lifecycle Management

### TTL (Time To Live) Management
Memory instances automatically clean up based on TTL settings:

```yaml
persistence:
  type: redis
  ttl: 24h           # Base TTL for memory instances
append_ttl: "30m"    # Extend TTL on message append
clear_ttl: "5m"      # Short TTL after clearing
flush_ttl: "1h"      # TTL after flush operations
```

**TTL Behaviors:**
- **Base TTL**: Default expiration time (24 hours)
- **Append TTL**: Extends TTL when actively used (30 minutes)
- **Clear TTL**: Short grace period after clearing (5 minutes)
- **Flush TTL**: Recovery time after flush operations (1 hour)

### Automatic Cleanup
The system provides automatic cleanup through:
- Redis key expiration based on TTL settings
- Periodic cleanup of orphaned metadata
- Health monitoring for instance status
- Garbage collection for unused instances

## Privacy and Security

### Privacy Controls
Memory instances support privacy features:

```yaml
privacy:
  enabled: true
  redaction_patterns:
    - name: "email"
      pattern: "\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b"
      replacement: "[REDACTED:EMAIL]"
    - name: "phone"
      pattern: "\\b\\d{3}-\\d{3}-\\d{4}\\b"
      replacement: "[REDACTED:PHONE]"
```

Privacy features include:
- Regex-based pattern redaction
- Configurable redaction rules
- Automatic PII (Personally Identifiable Information) removal
- Secure storage of sensitive data

### Security Considerations
- Memory keys should not contain sensitive information
- Use appropriate TTL settings for data retention
- Enable privacy controls for production deployments
- Consider access controls for memory instances

## Integration with Agents

### Agent Memory Configuration
Agents can reference memory resources:

```yaml
agents:
  - id: customer_support
    memory:
      - id: conversation_history
        key: "support:{{.workflow.input.conversation_id}}"
      - id: customer_profile
        key: "customer:{{.workflow.input.customer_id}}"
```

### Memory Operations
Common memory operations include:
- **Read**: Retrieve conversation history
- **Append**: Add new messages to memory
- **Clear**: Remove all messages
- **Flush**: Apply cleanup strategies

## Best Practices

### Key Design
- Use hierarchical naming: `domain:entity:context`
- Include necessary identifiers for uniqueness
- Avoid sensitive information in keys
- Keep keys reasonably short for performance

### Memory Type Selection
- **Token-based**: For LLM integration and cost optimization
- **Message count**: For simple chat applications
- **Buffer**: For development and debugging only

### Performance Optimization
- Set appropriate TTL values based on usage patterns (see [TTL Management](#ttl-time-to-live-management) section)
- Use privacy controls only when necessary
- Monitor memory usage and cleanup effectiveness
- Consider memory limits for cost management

### Error Handling
- Implement fallback behavior for memory unavailability
- Handle cleanup errors gracefully
- Monitor memory instance health
- Provide user-friendly error messages

## Common Use Cases

### Customer Support Chat
```yaml
# Customer support with persistent conversation history
resource: memory
id: support_conversation
type: token_based
max_tokens: 2000
key: "support:{{.workflow.input.ticket_id}}"
```

### User Profile Memory
```yaml
# User preferences and context
resource: memory
id: user_profile
type: message_count_based
max_messages: 50
key: "user:{{.workflow.input.user_id}}:profile"
```

### Session-based Memory
```yaml
# Temporary session memory
resource: memory
id: session_memory
type: buffer
max_messages: 20
key: "session:{{.session_id}}"
```

This foundational understanding of memory concepts enables effective use of Compozy's memory system for building context-aware AI applications.

<ReferenceCardList>
  <ReferenceCard
    title="Memory Configuration"
    description="Learn how to configure memory resources"
    href="/docs/core/memory/configuration"
    icon="Settings"
  />
  <ReferenceCard
    title="Memory Operations"
    description="Understand memory operations and usage"
    href="/docs/core/memory/operations"
    icon="Play"
  />
  <ReferenceCard
    title="Privacy & Security"
    description="Implement privacy controls and security"
    href="/docs/core/memory/privacy-security"
    icon="Shield"
  />
  <ReferenceCard
    title="Integration Patterns"
    description="Advanced memory integration patterns"
    href="/docs/core/memory/integration-patterns"
    icon="Layers"
  />
</ReferenceCardList>