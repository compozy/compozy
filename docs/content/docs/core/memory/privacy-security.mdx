---
title: "Privacy & Security"
description: "Data protection and privacy controls for memory systems using regex redaction patterns"
---

## Related Documentation

### üîó Cross-References
- **[Memory Concepts](/docs/core/memory/memory-concepts)** - Understanding memory architecture
- **[Memory Configuration](/docs/core/memory/configuration)** - Basic memory setup
- **[Memory Operations](/docs/core/memory/operations)** - Memory management operations
- **[Integration Patterns](/docs/core/memory/integration-patterns)** - Agent-memory integration
- **[Troubleshooting](/docs/core/memory/troubleshooting)** - Debugging memory issues

<Callout type="info">
**What Memory Privacy Provides:**
- **Regex-based redaction** with ReDoS attack protection
- **Message type filtering** for non-persistable content
- **Circuit breaker protection** with automatic failure recovery
- **Resilient privacy manager** with degraded mode fallback
- **Pattern validation** to prevent catastrophic backtracking
- **Timeout protection** for regex processing
- **Configurable redaction strings** and custom patterns
</Callout>

## Privacy Controls

**What it does:** Compozy's privacy system automatically detects and redacts sensitive information using regex patterns before storing messages in memory. This helps prevent accidental exposure of personal data, credentials, or proprietary information.

**How it works:** The privacy manager applies regex patterns to message content and replaces matches with redaction strings. It includes timeout protection and circuit breaker functionality to prevent regex-based attacks.

### Basic Redaction Setup

Here's how to configure basic redaction for sensitive data:

```yaml
resource: memory
id: secure_memory
description: Memory with privacy protection

privacy_policy:
  redact_patterns:
    # Social Security Numbers (XXX-XX-XXXX)
    - '\b\d{3}-\d{2}-\d{4}\b'

    # Credit card numbers (various formats)
    - '\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{3,6}\b'

    # Email addresses
    - '\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'

    # Phone numbers (US formats)
    - '\b(?:\+?1[-.\s]?)?\(?[2-9]\d{2}\)?[-.\s]?\d{3}[-.\s]?\d{4}\b'

    # IP addresses
    - '\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b'

    # Account numbers
    - '\baccount\s*#?\s*\d{6,12}\b'

    # API keys and tokens
    - '\b[A-Za-z0-9+/]{20,}\b'

    # Custom business-specific patterns
    - '\b[A-Z]{2,3}-\d{4,6}\b'  # Internal reference numbers

  # Replacement text for redacted content
  default_redaction_string: "[REDACTED]"
```

**Example:** When a user sends a message containing "My SSN is 123-45-6789", the memory system stores it as "My SSN is [REDACTED]" instead.

### Common Redaction Patterns

**Financial Information**

Protect financial data with these patterns:

```yaml
privacy_policy:
  redact_patterns:
    # Credit card numbers (various formats)
    - '\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{3,6}\b'
    # Social Security Numbers (XXX-XX-XXXX)
    - '\b\d{3}-\d{2}-\d{4}\b'
    # Bank routing numbers
    - '\b\d{2}-\d{7}\b'
    # Account numbers
    - '\baccount\s*#?\s*\d{6,12}\b'
```

**Personal Information**

Redact personal identifiers:

```yaml
privacy_policy:
  redact_patterns:
    # Email addresses
    - '\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
    # Phone numbers (US formats)
    - '\b(?:\+?1[-.\s]?)?\(?[2-9]\d{2}\)?[-.\s]?\d{3}[-.\s]?\d{4}\b'
    # IP addresses
    - '\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b'
```

**Technical Information**

Protect technical identifiers and security tokens:

```yaml
privacy_policy:
  redact_patterns:
    # UUIDs
    - '\b[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\b'
    # API keys and tokens
    - '\b[A-Za-z0-9+/]{40,}\b'
    # Bearer tokens
    - '\bBearer\s+[A-Za-z0-9+/=]{20,}\b'
    # Custom business patterns
    - '\b[A-Z]{2,3}-\d{4,6}\b'  # Internal reference numbers
```

### Non-Persistable Message Types

**What it does:** Prevents certain types of messages from being stored in memory at all, regardless of content.

**How it works:** The privacy manager checks the message type (role) against a list of non-persistable types and skips storage entirely.

```yaml
privacy_policy:
  non_persistable_message_types:
    - system          # System messages
    - tool_internal   # Internal tool communications
    - debug           # Debug information
    - error           # Error messages
    - authentication  # Authentication-related messages
    - admin           # Administrative messages
    - temporary       # Temporary messages
```

**Example:** If you send a message with role "system", it won't be stored in memory even if it contains no sensitive data.

## Pattern Safety

**What it does:** Compozy validates regex patterns to prevent ReDoS (Regular Expression Denial of Service) attacks that could cause performance issues or crashes.

**How it works:** The privacy manager includes built-in validation that rejects patterns known to cause catastrophic backtracking or excessive memory usage.

### Safe Pattern Examples

```yaml
privacy_policy:
  redact_patterns:
    # ‚úÖ Safe patterns - specific and bounded
    - '\b\d{3}-\d{2}-\d{4}\b'              # SSN with specific format
    - '\b[A-Za-z0-9+/]{40}\b'              # Fixed-length token
    - '\b(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b'  # IP address
```

### Unsafe Pattern Examples

```yaml
privacy_policy:
  redact_patterns:
    # ‚ùå Unsafe patterns - will be rejected
    - '(\w+)+'                             # Nested quantifiers
    - '(a+)+'                              # Nested quantifiers
    - '(a*)*'                              # Nested star quantifiers
    - '(.+)+'                              # Nested quantifiers with any character
    - '(.{0,50000})*'                      # Memory exhaustion
```

## Circuit Breaker Protection

**What it does:** Protects against regex pattern failures by temporarily disabling redaction when too many consecutive errors occur.

**How it works:** The privacy manager tracks consecutive failures and stops processing patterns after 10 consecutive errors. This prevents cascading failures from affecting memory operations.

### Circuit Breaker Configuration

The circuit breaker is built-in and cannot be disabled, but you can monitor its status:

```yaml
# Circuit breaker automatically activates after 10 consecutive errors
# No configuration needed - built-in protection
```

**Error Recovery:** The circuit breaker resets automatically when a pattern succeeds, allowing normal operation to resume.

## Real-World Example

Here's a complete example of privacy configuration for a customer service application:

```yaml
resource: memory
id: customer_service_memory
description: Memory for customer service interactions with privacy protection

privacy_policy:
  redact_patterns:
    # Customer personal information
    - '\b\d{3}-\d{2}-\d{4}\b'                                    # SSN
    - '\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'      # Email
    - '\b(?:\+?1[-.\s]?)?\(?[2-9]\d{2}\)?[-.\s]?\d{3}[-.\s]?\d{4}\b'  # Phone
    
    # Financial information
    - '\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{3,6}\b'             # Credit cards
    - '\baccount\s*#?\s*\d{6,12}\b'                              # Account numbers
    
    # Internal identifiers
    - '\bCS-\d{6}\b'                                             # Customer service ticket IDs
    - '\bEMP-\d{4}\b'                                            # Employee IDs

  non_persistable_message_types:
    - system
    - debug
    - error
    - authentication

  default_redaction_string: "[REDACTED]"

# Basic memory configuration
type: token_based
max_tokens: 4000
persistence:
  type: redis
  config:
    host: localhost
    port: 6379
    db: 0
```

## Performance Considerations

**Impact:** Regex redaction adds 5-10ms processing time per message, depending on the number and complexity of patterns.

**Optimization Tips:**
- Use specific, bounded patterns rather than broad ones
- Limit the number of patterns to essential ones only
- Test patterns with representative data to ensure good performance
- Monitor circuit breaker status to detect pattern issues

## Best Practices

1. **Start Simple:** Begin with a few essential patterns and add more as needed
2. **Test Thoroughly:** Validate patterns with real data before production deployment
3. **Monitor Performance:** Track redaction processing time and circuit breaker status
4. **Document Patterns:** Comment your regex patterns to explain their purpose
5. **Regular Review:** Periodically review and update patterns as requirements change

## Troubleshooting

**Common Issues:**

- **Pattern Rejected:** Check for unsafe regex patterns that could cause ReDoS
- **Circuit Breaker Open:** Too many pattern failures - check pattern syntax and test data
- **Performance Issues:** Reduce pattern complexity or count
- **False Positives:** Refine patterns to be more specific

**Debugging Steps:**

1. Check system logs for privacy manager errors
2. Verify pattern syntax using regex testing tools
3. Test patterns with sample data
4. Monitor circuit breaker status
5. Review memory operation logs

<ReferenceCardList>
  <ReferenceCard
    title="Memory Operations"
    description="Learn how to use memory operations with privacy controls"
    href="/docs/core/memory/operations"
    icon="Play"
  />
  <ReferenceCard
    title="Integration Patterns"
    description="Integrate privacy-aware memory with agents and workflows"
    href="/docs/core/memory/integration-patterns"
    icon="Layers"
  />
  <ReferenceCard
    title="Troubleshooting"
    description="Debug and resolve privacy-related issues"
    href="/docs/core/memory/troubleshooting"
    icon="Bug"
  />
  <ReferenceCard
    title="Configuration"
    description="Advanced memory configuration options"
    href="/docs/core/memory/configuration"
    icon="Settings"
  />
</ReferenceCardList>

This privacy system provides essential data protection for memory operations while maintaining simplicity and performance. Focus on implementing the patterns most relevant to your specific use case.