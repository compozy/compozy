---
title: "Privacy & Security"
description: "Data protection and privacy controls for memory systems using regex redaction patterns"
---

## What is Memory Privacy?

Compozy's privacy system provides **intelligent data protection** for memory operations, automatically detecting and redacting sensitive information before storage. The system uses regex-based pattern matching with built-in security protections to prevent accidental exposure of personal data, credentials, or proprietary information while maintaining memory performance and reliability.

## Core Privacy Features

<FeatureCardList cols={2}>
  <FeatureCard
    title="Pattern-Based Redaction"
    description="Intelligent regex patterns that identify and redact sensitive data like SSNs, credit cards, and emails automatically"
    icon="Shield"
  />
  <FeatureCard
    title="ReDoS Protection"
    description="Built-in validation prevents Regular Expression Denial of Service attacks with timeout and complexity checks"
    icon="AlertTriangle"
  />
  <FeatureCard
    title="Message Type Filtering"
    description="Configurable filtering prevents certain message types from being stored in memory entirely"
    icon="Filter"
  />
  <FeatureCard
    title="Circuit Breaker Safety"
    description="Automatic failure recovery system that prevents cascading errors from affecting memory operations"
    icon="Zap"
  />
</FeatureCardList>

## Setting Up Privacy Protection

<Steps>
  <Step title="Configure Privacy Policy">
    Add a `privacy_policy` section to your memory resource configuration with redaction patterns and settings.
  </Step>
  <Step title="Define Redaction Patterns">
    Specify regex patterns that match sensitive data you want to protect, such as SSNs, credit cards, and emails.
  </Step>
  <Step title="Set Redaction Replacement">
    Choose how redacted content appears in storage using the `default_redaction_string` property.
  </Step>
  <Step title="Test Pattern Safety">
    Validate that your patterns are safe and won't cause performance issues or ReDoS attacks.
  </Step>
</Steps>

### Basic Configuration Example

```yaml
resource: memory
id: secure_memory
description: Memory with privacy protection

privacy_policy:
  redact_patterns:
    # Social Security Numbers (XXX-XX-XXXX)
    - '\b\d{3}-\d{2}-\d{4}\b'
    # Credit card numbers (various formats)
    - '\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{3,6}\b'
    # Email addresses
    - '\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
    # Phone numbers (US formats)
    - '\b(?:\+?1[-.\s]?)?\(?[2-9]\d{2}\)?[-.\s]?\d{3}[-.\s]?\d{4}\b'
    # Account numbers
    - '\baccount\s*#?\s*\d{6,12}\b'

  # Replacement text for redacted content
  default_redaction_string: "[REDACTED]"
```

<Callout type="info">
**Example:** When a user sends "My SSN is 123-45-6789", the memory system stores it as "My SSN is [REDACTED]" to protect sensitive information.
</Callout>

## Common Redaction Patterns

<Tabs items={["Financial Data", "Personal Info", "Technical Data"]}>
  <Tab value="Financial Data">
    Protect financial information including credit cards, SSNs, and account numbers:

    ```yaml
    privacy_policy:
      redact_patterns:
        # Credit card numbers (various formats)
        - '\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{3,6}\b'
        # Social Security Numbers (XXX-XX-XXXX)
        - '\b\d{3}-\d{2}-\d{4}\b'
        # Bank routing numbers
        - '\b\d{2}-\d{7}\b'
        # Account numbers
        - '\baccount\s*#?\s*\d{6,12}\b'
    ```

    These patterns handle common financial data formats while avoiding false positives with other number sequences.
  </Tab>

  <Tab value="Personal Info">
    Redact personal identifiers and contact information:

    ```yaml
    privacy_policy:
      redact_patterns:
        # Email addresses
        - '\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        # Phone numbers (US formats)
        - '\b(?:\+?1[-.\s]?)?\(?[2-9]\d{2}\)?[-.\s]?\d{3}[-.\s]?\d{4}\b'
        # IP addresses
        - '\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b'
    ```

    Learn more about [configuring memory operations](/docs/core/memory/operations) for handling personal data securely.
  </Tab>

  <Tab value="Technical Data">
    Protect technical identifiers and security tokens:

    ```yaml
    privacy_policy:
      redact_patterns:
        # UUIDs
        - '\b[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\b'
        # API keys and tokens (40+ characters)
        - '\b[A-Za-z0-9+/]{40,}\b'
        # Bearer tokens
        - '\bBearer\s+[A-Za-z0-9+/=]{20,}\b'
        # Custom business patterns
        - '\b[A-Z]{2,3}-\d{4,6}\b'  # Internal reference numbers
    ```

    For integration with external systems, see [integration patterns](/docs/core/memory/integration-patterns) for secure API handling.
  </Tab>
</Tabs>

## Message Type Filtering

Beyond pattern-based redaction, you can prevent entire categories of messages from being stored in memory. This provides an additional layer of privacy protection by filtering messages based on their type or role.

<Callout type="warning">
**How it works:** The privacy manager checks each message's type before storage and completely skips non-persistable message types, regardless of content.
</Callout>

### Configuration

```yaml
privacy_policy:
  non_persistable_message_types:
    - system          # System messages and internal communications
    - tool_internal   # Internal tool-to-tool communications
    - debug           # Debug information and diagnostic data
    - error           # Error messages and stack traces
    - authentication  # Authentication-related messages
    - admin           # Administrative messages
    - temporary       # Temporary or transient messages
```

**Filtering Examples:**
- Message with role `"system"` → Not stored in memory
- Message with role `"user"` → Stored normally (with redaction applied)
- Message with role `"debug"` → Not stored in memory

This filtering happens before redaction processing, providing efficient protection for sensitive message categories. Learn more about message handling in the [memory operations guide](/docs/core/memory/operations).

## Pattern Safety & ReDoS Protection

Compozy includes built-in validation to prevent **Regular Expression Denial of Service (ReDoS)** attacks. The privacy manager automatically rejects unsafe patterns that could cause performance issues, memory exhaustion, or system crashes through catastrophic backtracking.

<Callout type="error" className="my-8">
**Security Alert:** Malicious or poorly constructed regex patterns can consume excessive CPU and memory, potentially bringing down your system. Compozy's pattern validation provides essential protection against these attacks.
</Callout>

<Tabs items={["Safe Patterns", "Unsafe Patterns"]} defaultValue="Safe Patterns">
  <Tab value="Safe Patterns">
    These patterns are optimized for performance and security:

    ```yaml
    privacy_policy:
      redact_patterns:
        # Safe patterns - specific and bounded
        - '\b\d{3}-\d{2}-\d{4}\b'              # SSN with specific format
        - '\b[A-Za-z0-9+/]{40}\b'              # Fixed-length token
        - '\b(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b'  # IP address
        - '\b[A-Z]{2}-\d{6}\b'                 # Bounded business code format
    ```

    **Why these are safe:**
    - Use specific quantifiers (`{3}`, `{40}`) instead of unbounded ones
    - Avoid nested quantifiers that cause exponential backtracking
    - Include word boundaries (`\b`) to limit matching scope
    - Use character classes with specific ranges
  </Tab>

  <Tab value="Unsafe Patterns">
    These patterns **will be rejected** by the system:

    ```yaml
    privacy_policy:
      redact_patterns:
        # Unsafe patterns - automatically rejected
        - '(\w+)+'                             # Nested quantifiers
        - '(a+)+'                              # Nested quantifiers
        - '(a*)*'                              # Nested star quantifiers
        - '(.+)+'                              # Nested quantifiers with any character
        - '(.{0,50000})*'                      # Memory exhaustion pattern
        - '(x+x+)+y'                          # Exponential backtracking
    ```

    **Why these are dangerous:**
    - Nested quantifiers create exponential time complexity
    - Unbounded patterns can consume excessive memory
    - Complex alternations can cause catastrophic backtracking
    - Patterns without anchors can match unexpectedly large text sections
  </Tab>
</Tabs>

## Circuit Breaker Protection

The privacy system includes an **automatic failsafe mechanism** that prevents cascading failures when regex patterns consistently fail. This circuit breaker monitors pattern execution and temporarily disables redaction to maintain memory system stability.

<List>
  <ListItem title="Automatic Activation">
    Triggers after 10 consecutive pattern failures to prevent system overload
  </ListItem>
  <ListItem title="Self-Healing Recovery">
    Automatically resets when a pattern succeeds, restoring normal operation
  </ListItem>
  <ListItem title="No Configuration Required">
    Built-in protection that works transparently without manual setup
  </ListItem>
  <ListItem title="Graceful Degradation">
    Memory operations continue normally while patterns are temporarily disabled
  </ListItem>
</List>

<Callout type="info">
**Monitoring:** While the circuit breaker requires no configuration, you should monitor system logs for circuit breaker activations to identify problematic patterns that need fixing.
</Callout>

## Complete Configuration Example

Here's a production-ready privacy configuration for a customer service application:

```yaml
resource: memory
id: customer_service_memory
description: Customer service memory with comprehensive privacy protection

privacy_policy:
  redact_patterns:
    # Customer personal information
    - '\b\d{3}-\d{2}-\d{4}\b'                     # SSN
    - '\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'  # Email
    - '\b(?:\+?1[-.\s]?)?\(?[2-9]\d{2}\)?[-.\s]?\d{3}[-.\s]?\d{4}\b'  # Phone

    # Financial information
    - '\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{3,6}\b'  # Credit cards
    - '\baccount\s*#?\s*\d{6,12}\b'               # Account numbers

    # Internal identifiers
    - '\bCS-\d{6}\b'                              # Support ticket IDs
    - '\bEMP-\d{4}\b'                             # Employee IDs

  non_persistable_message_types:
    - system
    - debug
    - error
    - authentication

  default_redaction_string: "[REDACTED]"

# Memory configuration
type: token_based
max_tokens: 4000
persistence:
  type: redis
  config:
    host: localhost
    port: 6379
    db: 0
```

## Summary

With Compozy's privacy system, you can confidently handle sensitive data while maintaining optimal memory performance. Start with the basic patterns that match your data types, enable message filtering for sensitive categories, and monitor system performance as you scale.

**Ready to implement privacy controls?** Begin with the [memory configuration guide](/docs/core/memory/configuration) to set up your secure memory resources, then explore [integration patterns](/docs/core/memory/integration-patterns) for advanced privacy-aware architectures.

## Next Steps

<ReferenceCardList>
  <ReferenceCard
    title="Memory Operations"
    description="Learn how to use memory operations with privacy controls"
    href="/docs/core/memory/operations"
    icon="Play"
  />
  <ReferenceCard
    title="Integration Patterns"
    description="Integrate privacy-aware memory with agents and workflows"
    href="/docs/core/memory/integration-patterns"
    icon="Layers"
  />
  <ReferenceCard
    title="Configuration"
    description="Advanced memory configuration options"
    href="/docs/core/memory/configuration"
    icon="Settings"
  />
</ReferenceCardList>
