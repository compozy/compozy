---
title: "Troubleshooting Memory Issues"
description: "Practical guide to diagnosing and resolving memory system issues in Compozy"
---

- **Multiple memory strategies**: `token_based`, `message_count_based`, and `buffer` types
- **Advanced flushing strategies**: `hybrid_summary`, `simple_fifo`, `lru`, and `token_aware_lru`
- **Comprehensive privacy controls**: Regex-based redaction with ReDoS protection and circuit breaker
- **Flexible eviction policies**: `fifo`, `lru`, and `priority` based eviction
- **Template-based key resolution**: Dynamic key generation using Go templates
- **Token counting integration**: Support for multiple providers (OpenAI, tiktoken)

## üîó Related Documentation

- **[Memory Configuration](./configuration)** - Understanding memory configuration
- **[Memory Concepts](./memory-concepts)** - Core memory system concepts
- **[Privacy & Security](./privacy-security)** - Privacy and redaction troubleshooting

## Common Issues and Solutions

### Memory Instance Not Found

**What this means:** The memory system cannot find the specified memory instance, usually due to key resolution issues.

**Symptoms:**
- "Memory instance not found" errors
- Agents unable to load conversation history
- Empty memory responses

**Common Causes:**
1. **Template evaluation errors** - The key template doesn't resolve correctly
2. **Redis connection issues** - Cannot connect to Redis
3. **TTL expiration** - Memory data has expired
4. **Incorrect configuration** - Memory not properly configured

**Debugging Steps:**

First, check your memory configuration:

```yaml
# compozy.yaml
memory:
  - resource: memory
    id: user_memory
    type: token_based
    max_tokens: 4000
    key: "user:{{.workflow.input.user_id}}"
    persistence:
      type: redis
      ttl: 24h
```

**Template evaluation issues** are the most common cause. Ensure your workflow provides the required context variables:

```yaml
# Example workflow input
input:
  user_id: "user123"  # Required for template "user:{{.workflow.input.user_id}}"
  session_id: "session456"  # If used in template
```

**Check Redis connectivity:**

```bash
# Test Redis connection
redis-cli ping

# Check if key exists
redis-cli get "user:your_user_id"
```

**Solutions:**

1. **Fix template syntax:**
```yaml
# ‚ùå Incorrect
key: "user:{{.workflow.input.user_id"  # Missing closing brace

# ‚úÖ Correct
key: "user:{{.workflow.input.user_id}}"
```

2. **Verify context variables:**
```yaml
# Ensure workflow input contains required fields
input:
  user_id: "user123"        # For {{.workflow.input.user_id}}
  session_id: "session456"  # For {{.workflow.input.session_id}}
```

3. **Check TTL configuration:**
```yaml
persistence:
  type: redis
  ttl: 24h  # Reasonable TTL for your use case
```

### Memory Operations Timeout

**What this means:** Memory operations are taking too long to complete, often due to Redis performance issues or large data processing.

**Symptoms:**
- Operations hang or timeout
- "Context deadline exceeded" errors
- Slow response times

**Common Causes:**
1. **Redis performance issues** - High latency or overload
2. **Large message processing** - Processing very large conversation histories
3. **Network latency** - Slow connection to Redis
4. **Privacy processing overhead** - Complex regex redaction patterns

**Debugging Steps:**

Check Redis performance:
```bash
# Monitor Redis latency
redis-cli --latency-history -h localhost -p 6379

# Check Redis info
redis-cli info stats
```

Monitor memory usage:
```bash
# Check memory usage
redis-cli info memory

# List memory keys
redis-cli keys "user:*"
```

**Solutions:**

1. **Optimize Redis configuration:**
```yaml
# If using Docker
redis:
  image: redis:7-alpine
  command: redis-server --maxmemory 256mb --maxmemory-policy allkeys-lru
```

2. **Reduce message size:**
```yaml
# Use smaller token limits
memory:
  - resource: memory
    id: user_memory
    type: token_based
    max_tokens: 2000  # Smaller limit for better performance
```

3. **Simplify privacy patterns:**
```yaml
# Optimize regex patterns
privacy_policy:
  redact_patterns:
    - '\b\d{3}-\d{2}-\d{4}\b'  # Simple, specific patterns
```

### Token Count Issues

**What this means:** Problems with token counting, leading to incorrect memory management.

**Symptoms:**
- Memory not flushing when expected
- Incorrect token count reporting
- Memory exceeding configured limits

**Common Causes:**
1. **Token counting provider issues** - Problems with OpenAI API or tiktoken
2. **Configuration mismatch** - Incorrect token limits or ratios
3. **Template evaluation errors** - Token count metadata not updating

**Debugging Steps:**

Check your token-based memory configuration:
```yaml
memory:
  - resource: memory
    id: user_memory
    type: token_based
    max_tokens: 4000  # Clear limit
    # OR
    max_context_ratio: 0.8  # 80% of context window
```

**Solutions:**

1. **Set explicit token limits:**
```yaml
# Use explicit token limits instead of ratios
memory:
  - resource: memory
    id: user_memory
    type: token_based
    max_tokens: 4000  # Clear, explicit limit
```

2. **Verify token provider configuration:**
```yaml
# Ensure token provider is configured
agent:
  llm:
    provider: openai
    model: gpt-4
    api_key: ${OPENAI_API_KEY}
```

### Memory Not Persisting

**What this means:** Memory data is not being saved to Redis properly.

**Symptoms:**
- Memory resets between workflow runs
- No conversation history preserved
- Fresh memory on each interaction

**Common Causes:**
1. **Redis not configured** - No persistence layer
2. **Incorrect key templates** - Keys changing between runs
3. **TTL too short** - Data expiring too quickly
4. **Redis connection issues** - Cannot write to Redis

**Debugging Steps:**

Check Redis configuration:
```yaml
# Ensure Redis persistence is configured
memory:
  - resource: memory
    id: user_memory
    type: token_based
    max_tokens: 4000
    persistence:
      type: redis  # Must be specified
      ttl: 24h     # Reasonable TTL
```

Verify key consistency:
```bash
# Check if keys are being created
redis-cli keys "*"

# Monitor Redis operations
redis-cli monitor
```

**Solutions:**

1. **Configure Redis persistence:**
```yaml
persistence:
  type: redis
  ttl: 24h
```

2. **Use consistent key templates:**
```yaml
# Ensure key template produces consistent results
key: "user:{{.workflow.input.user_id}}"
# NOT: "user:{{.workflow.exec_id}}" (changes every run)
```

3. **Verify Redis connection:**
```bash
# Test Redis connection
redis-cli ping
# Should return: PONG
```

### Flushing Strategy Issues

**What this means:** Problems with memory flushing behavior, where memory isn't being cleared or summarized correctly when limits are reached.

**Symptoms:**
- Memory growing beyond configured limits
- Flushing not triggered when expected
- Loss of important conversation context
- Inconsistent memory behavior

**Common Causes:**
1. **Incorrect flushing strategy configuration** - Wrong strategy for your use case
2. **Token counting issues** - Problems with token counting affecting flush triggers
3. **Strategy configuration errors** - Missing or invalid parameters

**Available Flushing Strategies:**

```yaml
# Simple FIFO - removes oldest messages
flushing_strategy:
  type: simple_fifo
  flush_percentage: 0.3  # Remove 30% of oldest messages

# LRU - removes least recently used messages  
flushing_strategy:
  type: lru
  flush_percentage: 0.25

# Token-aware LRU - considers both recency and token count
flushing_strategy:
  type: token_aware_lru
  flush_percentage: 0.3
  token_weight: 0.7      # Weight given to token count vs recency

# Hybrid summary - creates summary of old content
flushing_strategy:
  type: hybrid_summary
  summary_ratio: 0.4     # 40% of memory becomes summary
  preserve_recent: 10    # Keep 10 most recent messages untouched
```

**Debugging Steps:**

Check your flushing configuration:
```yaml
memory:
  - resource: memory
    id: user_memory
    type: token_based
    max_tokens: 4000
    flushing_strategy:
      type: hybrid_summary
      summary_ratio: 0.3
      preserve_recent: 8
```

**Solutions:**

1. **Choose appropriate strategy for your use case:**
```yaml
# For maintaining conversation context
flushing_strategy:
  type: hybrid_summary
  summary_ratio: 0.3
  preserve_recent: 10

# For simple memory management
flushing_strategy:
  type: simple_fifo
  flush_percentage: 0.25
```

### Eviction Policy Issues

**What this means:** Problems with how messages are selected for removal during memory operations.

**Available Eviction Policies:**

```yaml
# FIFO - First In, First Out
eviction_policy:
  type: fifo

# LRU - Least Recently Used  
eviction_policy:
  type: lru

# Priority-based - Based on message importance
eviction_policy:
  type: priority
  priority_weights:
    user: 1.0
    assistant: 0.8
    system: 0.6
```

### Privacy/Redaction Issues

**What this means:** Problems with data redaction or privacy policy enforcement, including ReDoS attacks and circuit breaker failures.

**Symptoms:**
- Sensitive data not being redacted
- Over-redaction of normal content
- Redaction patterns not working
- ReDoS protection warnings in logs
- Circuit breaker activation messages

**Common Causes:**
1. **Invalid regex patterns** - Malformed or dangerous regular expressions
2. **ReDoS vulnerability** - Regex patterns susceptible to catastrophic backtracking
3. **Circuit breaker activation** - Too many consecutive regex failures
4. **Configuration errors** - Privacy policy not applied correctly

**Debugging Steps:**

Check your privacy configuration:
```yaml
memory:
  - resource: memory
    id: user_memory
    type: token_based
    max_tokens: 4000
    privacy_policy:
      redact_patterns:
        - '\b\d{3}-\d{2}-\d{4}\b'  # SSN pattern
        - '\b\d{16}\b'             # Credit card pattern
      default_redaction_string: "[REDACTED]"
      circuit_breaker:
        failure_threshold: 10      # Built-in protection
        recovery_timeout: 300s     # Auto-recovery time
```

**Solutions:**

1. **Test regex patterns for ReDoS:**
```bash
# Test your regex patterns for safety
echo "My SSN is 123-45-6789" | timeout 1s grep -E '\b\d{3}-\d{2}-\d{4}\b'
# Should complete quickly - if timeout triggers, pattern may be unsafe
```

2. **Use ReDoS-safe patterns:**
```yaml
# ‚úÖ ReDoS-safe patterns
privacy_policy:
  redact_patterns:
    - '\b\d{3}-\d{2}-\d{4}\b'      # SSN - linear complexity
    - '\b\d{16}\b'                 # Credit card - linear complexity
    - '\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'  # Email

# ‚ùå Avoid ReDoS-prone patterns  
privacy_policy:
  redact_patterns:
    - '(a+)+'                      # Nested quantifiers - dangerous
    - '(.*a){10,}'                 # Complex backtracking
    - '\d+'                        # Too broad - matches all numbers
```

3. **Monitor circuit breaker status:**
```yaml
# Circuit breaker automatically protects against:
# - 10+ consecutive regex failures
# - Automatically recovers after successful pattern match
# - No manual configuration needed
```

4. **Configure non-persistable message types:**
```yaml
privacy_policy:
  non_persistable_message_types:
    - "system_internal"
    - "debug"
    - "temporary"
```

## Configuration Issues

### Invalid Configuration Format

**What this means:** The memory configuration has syntax errors or missing required fields.

**Common Errors:**

1. **Missing required fields:**
```yaml
# ‚ùå Missing required fields
memory:
  - resource: memory
    id: user_memory
    # Missing type and max_tokens

# ‚úÖ Complete configuration
memory:
  - resource: memory
    id: user_memory
    type: token_based
    max_tokens: 4000
```

2. **Invalid TTL format:**
```yaml
# ‚ùå Invalid TTL format
persistence:
  ttl: "24 hours"  # Should be "24h"

# ‚úÖ Valid TTL format
persistence:
  ttl: 24h
```

3. **Invalid regex patterns:**
```yaml
# ‚ùå Invalid regex
privacy_policy:
  redact_patterns:
    - "[0-9+"  # Unclosed bracket

# ‚úÖ Valid regex
privacy_policy:
  redact_patterns:
    - '\b\d{3}-\d{2}-\d{4}\b'
```

### Template Evaluation Problems

**What this means:** The key template cannot be evaluated with the provided context.

**Common Issues:**

1. **Missing context variables:**
```yaml
# Template requires user_id
key: "user:{{.workflow.input.user_id}}"

# But workflow input doesn't provide it
input:
  session_id: "session123"  # Missing user_id
```

2. **Incorrect template syntax:**
```yaml
# ‚ùå Wrong syntax
key: "user:${workflow.input.user_id}"  # Shell syntax, not Go template

# ‚úÖ Correct syntax
key: "user:{{.workflow.input.user_id}}"
```

3. **Complex template logic:**
```yaml
# ‚ùå Too complex
key: "{{if .workflow.input.user_id}}user:{{.workflow.input.user_id}}{{else}}guest:{{.workflow.input.session_id}}{{end}}"

# ‚úÖ Keep it simple
key: "user:{{.workflow.input.user_id}}"
```

## Performance Issues

### Slow Memory Operations

**What this means:** Memory operations are taking longer than expected.

**Common Causes:**
1. **Large conversation histories** - Too many messages stored
2. **Complex redaction patterns** - Regex processing overhead
3. **Redis performance** - Database performance issues
4. **Network latency** - Slow connection to Redis

**Solutions:**

1. **Reduce token limits:**
```yaml
# Use smaller token limits for better performance
memory:
  - resource: memory
    id: user_memory
    type: token_based
    max_tokens: 2000  # Smaller limit
```

2. **Optimize redaction patterns:**
```yaml
# Use specific, efficient patterns
privacy_policy:
  redact_patterns:
    - '\b\d{3}-\d{2}-\d{4}\b'  # Specific SSN pattern
    # Avoid: '.*sensitive.*' (too broad)
```

3. **Configure Redis for performance:**
```yaml
# Redis configuration for better performance
redis:
  image: redis:7-alpine
  command: redis-server --maxmemory 256mb --maxmemory-policy allkeys-lru
```

### Memory Growing Too Large

**What this means:** Memory instances are using too much storage.

**Solutions:**

1. **Set appropriate token limits:**
```yaml
memory:
  - resource: memory
    id: user_memory
    type: token_based
    max_tokens: 4000  # Reasonable limit
```

2. **Configure shorter TTL:**
```yaml
persistence:
  type: redis
  ttl: 1h  # Shorter TTL for temporary data
```

3. **Use message count limits:**
```yaml
memory:
  - resource: memory
    id: user_memory
    type: message_count_based
    max_messages: 50  # Limit message count
```

## CLI Commands for Memory Management

The Compozy CLI provides several commands to help with memory troubleshooting:

### Available Commands

```bash
# Authentication (required for API access)
compozy auth generate --name "dev-key" --description "Development API key"
compozy auth list --sort created --filter memory
compozy auth revoke <key-id> --force

# Configuration management
compozy config show --format yaml          # Show current configuration
compozy config show --format json          # Show as JSON
compozy config validate                     # Validate configuration

# Development and server management
compozy dev                                 # Start development server
compozy start                               # Start production server
compozy init                                # Initialize new Compozy project
compozy mcp-proxy                           # Start MCP proxy server

# Workflow management (for testing memory in workflows)
compozy workflow list --format json
compozy workflow get <workflow-id>
compozy workflow execute <workflow-id> --input "user_id=test123"
```

### Memory-Specific Troubleshooting

**Note**: There are no dedicated memory CLI commands - memory operations are performed through the REST API during workflow execution.

**Using workflows to test memory:**

```bash
# Execute a workflow that uses memory
compozy workflow execute my-workflow --input "user_id=test123" --input "message=Hello"

# Check workflow execution
compozy workflow get my-workflow
```

**Using the REST API directly:**

```bash
# Read from memory (replace {memory_ref} with your memory instance ID)
curl -X GET "http://localhost:5001/api/v0/memory/{memory_ref}/read" \
  -H "Authorization: Bearer your-api-key"

# Write to memory  
curl -X POST "http://localhost:5001/api/v0/memory/{memory_ref}/write" \
  -H "Authorization: Bearer your-api-key" \
  -H "Content-Type: application/json" \
  -d '{"message": {"role": "user", "content": "Hello world"}}'

# Check memory stats
curl -X GET "http://localhost:5001/api/v0/memory/{memory_ref}/stats" \
  -H "Authorization: Bearer your-api-key"

# Health check
curl -X GET "http://localhost:5001/api/v0/memory/{memory_ref}/health" \
  -H "Authorization: Bearer your-api-key"
```

## Debugging Tools

### Redis Debugging

Basic Redis commands for debugging:

```bash
# Check Redis connectivity
redis-cli ping

# List all keys (use pattern for memory keys)
redis-cli keys "compozy:*"
redis-cli keys "user:*"

# Get specific key
redis-cli get "user:123"

# Check key expiration
redis-cli ttl "user:123"

# Monitor Redis operations
redis-cli monitor

# Check Redis info
redis-cli info stats
redis-cli info memory
```

### Memory Health Check

Create a simple health check to verify memory system:

```yaml
# Basic health check workflow
workflow:
  name: memory-health-check
  tasks:
    - id: test-memory
      type: basic
      agent:
        id: test-agent
        llm:
          provider: openai
          model: gpt-4
        memory:
          - resource: memory
            id: health_check_memory
            type: token_based
            max_tokens: 1000
            key: "health:check:{{.workflow.input.test_id}}"
      with:
        test_id: "health-check-123"
        message: "This is a health check message"
```

### Logging Configuration

Enable logging to help with debugging:

```yaml
# Configure logging in your environment
logging:
  level: debug  # Set to debug for detailed logs
  format: json
  fields:
    service: compozy
    component: memory
```

## Best Practices

### Configuration Best Practices

1. **Use explicit token limits:**
```yaml
# ‚úÖ Explicit limits
max_tokens: 4000

# ‚ùå Avoid ratios if possible
max_context_ratio: 0.8
```

2. **Keep key templates simple:**
```yaml
# ‚úÖ Simple templates
key: "user:{{.workflow.input.user_id}}"

# ‚ùå Complex templates
key: "{{.workflow.input.namespace}}:{{.workflow.input.type}}:{{.workflow.input.user_id}}"
```

3. **Use reasonable TTL values:**
```yaml
# ‚úÖ Reasonable TTL
persistence:
  ttl: 24h  # 1 day

# ‚ùå Too short
persistence:
  ttl: 5m   # Too short for most use cases
```

### Privacy Best Practices

1. **Use specific redaction patterns:**
```yaml
# ‚úÖ Specific patterns
privacy_policy:
  redact_patterns:
    - '\b\d{3}-\d{2}-\d{4}\b'  # SSN
    - '\b\d{16}\b'             # Credit card

# ‚ùå Overly broad patterns
privacy_policy:
  redact_patterns:
    - '\d+'  # Too broad
```

2. **Configure non-persistable types:**
```yaml
privacy_policy:
  non_persistable_message_types:
    - "system_internal"
    - "debug"
    - "temporary"
```

### Performance Best Practices

1. **Monitor Redis performance:**
```bash
# Regular Redis health checks
redis-cli info stats
redis-cli info memory
```

2. **Use appropriate memory types:**
```yaml
# For token-limited scenarios
type: token_based
max_tokens: 4000

# For message-count scenarios
type: message_count_based
max_messages: 50
```

3. **Optimize for your use case:**
```yaml
# For short-lived interactions
persistence:
  ttl: 1h

# For long-lived conversations
persistence:
  ttl: 7d
```

## When to Seek Help

Escalate issues when:

1. **Redis is down** - Cannot connect to Redis
2. **Data corruption** - Memory data appears corrupted
3. **Performance degradation** - Operations consistently slow
4. **Configuration errors** - Cannot resolve configuration issues
5. **Privacy violations** - Redaction not working properly

## Summary

The memory system in Compozy is straightforward: it uses Redis for storage and simple template-based key resolution. Most issues stem from:

1. **Template evaluation problems** - Ensure your workflow provides required context variables
2. **Redis connectivity issues** - Verify Redis is running and accessible
3. **Configuration errors** - Check syntax and required fields
4. **Performance issues** - Monitor Redis and optimize configuration

For most troubleshooting scenarios, checking Redis connectivity, verifying key templates, and reviewing your configuration will resolve the issue.