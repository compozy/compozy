---
title: "Memory Operations"
description: "Overview of memory operations available through API endpoints and workflow tasks for persistent data management"
---

## Overview

Memory operations in Compozy provide **persistent context management** for AI agents and workflows. These operations enable your applications to maintain conversation history, share context between agents, and optimize memory usage through intelligent strategies.

Memory operations are available through **two primary interfaces**:

<FeatureCardList cols={2}>
  <FeatureCard
    title="REST API Operations"
    description="Direct HTTP endpoints for external integrations, custom tools, and programmatic access"
    icon="Globe"
    href="/docs/api/memory"
  />
  <FeatureCard
    title="Workflow Memory Tasks"
    description="YAML-configured tasks for workflow-native memory operations with template support"
    icon="FileCode"
    href="/docs/core/tasks/memory-tasks"
  />
</FeatureCardList>

## Operation Categories

Compozy provides 8 core memory operations organized into logical groups:

<Tabs items={["Data Operations", "Management Operations", "Monitoring Operations"]}>
  <Tab value="data-operations" title="Data Operations">
    ### Core CRUD Operations

    <List>
      <ListItem title="Read" icon="Eye">
        Retrieve messages with pagination and filtering for efficient data access
      </ListItem>
      <ListItem title="Write" icon="Edit">
        Replace entire memory content with atomic operations for data consistency
      </ListItem>
      <ListItem title="Append" icon="Plus">
        Add new messages to existing memory with automatic optimization triggers
      </ListItem>
    </List>

    **API Example:**
    ```bash
    # Read with pagination
    curl "http://localhost:5001/api/v0/memory/user_memory/read?key=user:123&limit=10"
    ```

    **Task Example:**
    ```yaml
    type: memory
    operation: read
    memory_ref: user_sessions
    key_template: "user:{{ .workflow.input.user_id }}:conversation"
    ```
  </Tab>

  <Tab value="management-operations" title="Management Operations">
    ### Memory Lifecycle Management

    <List>
      <ListItem title="Clear" icon="X">
        Safely remove content with confirmation and optional backup capabilities
      </ListItem>
      <ListItem title="Delete" icon="Trash2">
        Permanently remove memory instances when no longer needed
      </ListItem>
      <ListItem title="Flush" icon="Zap">
        Optimize memory using intelligent strategies (LRU, FIFO, token-aware, hybrid summary)
      </ListItem>
    </List>

    **API Example:**
    ```bash
    # Flush with strategy
    curl -X POST "http://localhost:5001/api/v0/memory/user_memory/flush" \
      -d '{"key": "user:123", "strategy": "hybrid_summary"}'
    ```

    **Task Example:**
    ```yaml
    type: memory
    operation: flush
    memory_ref: conversation_memory
    flush_config:
      strategy: "lru"
      threshold: 0.8
    ```
  </Tab>

  <Tab value="monitoring-operations" title="Monitoring Operations">
    ### Health & Analytics

    <List>
      <ListItem title="Health" icon="Activity">
        Monitor memory status, usage patterns, and optimization recommendations
      </ListItem>
      <ListItem title="Stats" icon="BarChart3">
        Access comprehensive analytics including token usage, message distribution, and trends
      </ListItem>
    </List>

    **API Example:**
    ```bash
    # Get health metrics
    curl "http://localhost:5001/api/v0/memory/user_memory/health?include_stats=true"
    ```

    **Task Example:**
    ```yaml
    type: memory
    operation: health
    memory_ref: user_sessions
    outputs:
      usage_percent: "{{ .output.usage_percent }}"
      recommendations: "{{ .output.recommendations }}"
    ```
  </Tab>
</Tabs>

## Implementation Approaches

Choose the approach that best fits your integration needs:

<Tabs items={["REST API", "Memory Tasks", "Integration Comparison"]}>
  <Tab value="rest-api" title="REST API">
    **Best for:** External integrations, custom applications, real-time operations

    **Key Features:**
    - Direct HTTP access to all memory operations
    - Complete OpenAPI/Swagger documentation
    - Authentication and authorization support
    - Real-time response for immediate operations

    **Use Cases:**
    - TypeScript tools and custom integrations
    - External application memory management
    - Real-time conversation systems
    - Direct programmatic access

    **Learn More:** [Complete API Reference →](/docs/api/memory)
  </Tab>

  <Tab value="memory-tasks" title="Memory Tasks">
    **Best for:** Workflow-native operations, template-driven keys, complex orchestration

    **Key Features:**
    - YAML configuration with template expressions
    - Workflow context integration
    - Dynamic key generation with templates
    - Seamless task chaining and orchestration

    **Use Cases:**
    - Persistent workflow state management
    - AI agent conversation history
    - Multi-step memory operations
    - Context sharing between workflow tasks

    **Learn More:** [Memory Tasks Guide →](/docs/core/tasks/memory-tasks)
  </Tab>

  <Tab value="integration-comparison" title="Integration Comparison">
    | Feature | REST API | Memory Tasks |
    |---------|----------|--------------|
    | **Access Method** | HTTP endpoints | YAML workflow tasks |
    | **Key Generation** | Static strings | Template expressions |
    | **Context Integration** | Manual | Automatic workflow context |
    | **Authentication** | API keys/tokens | Workflow-level security |
    | **Error Handling** | HTTP status codes | Task flow control |
    | **Orchestration** | External coordination | Native workflow chaining |
    | **Best For** | External tools, real-time | Workflows, AI agents |

    **Decision Guide:**
    - **Choose REST API** for external integrations, custom tools, or real-time operations
    - **Choose Memory Tasks** for workflow-native operations, AI agents, or complex orchestration
    - **Use Both** for hybrid approaches with external triggers and workflow processing
  </Tab>
</Tabs>

## Quick Start Examples

Get started with common memory operation patterns:

<Tabs items={["Conversation Storage", "Session Management", "Context Sharing"]}>
  <Tab value="conversation-storage" title="Conversation Storage">
    **Store and retrieve conversation history:**

    ```yaml
    # Store user message
    - id: store-user-message
      type: memory
      operation: append
      memory_ref: conversations
      key_template: "conv:{{ .workflow.input.session_id }}"
      payload:
        role: "user"
        content: "{{ .workflow.input.message }}"
        timestamp: "{{ now }}"
    
    # Retrieve conversation history
    - id: get-conversation-history
      type: memory
      operation: read
      memory_ref: conversations
      key_template: "conv:{{ .workflow.input.session_id }}"
      read_config:
        limit: 50
        include_metadata: true
    ```
  </Tab>

  <Tab value="session-management" title="Session Management">
    **Manage user sessions with automatic cleanup:**

    ```yaml
    # Create session
    - id: create-session
      type: memory
      operation: write
      memory_ref: user_sessions
      key_template: "session:{{ .workflow.input.user_id }}:{{ now | date '2006-01-02' }}"
      payload:
        user_id: "{{ .workflow.input.user_id }}"
        created_at: "{{ now }}"
        preferences: "{{ .workflow.input.preferences }}"

    # Cleanup old sessions
    - id: cleanup-sessions
      type: memory
      operation: flush
      memory_ref: user_sessions
      key_template: "session:{{ .workflow.input.user_id }}:*"
      flush_config:
        strategy: "token_count"
        threshold: 0.8
    ```
  </Tab>

  <Tab value="context-sharing" title="Context Sharing">
    **Share context between workflow tasks:**

    ```yaml
    # Store processing results
    - id: store-analysis-results
      type: memory
      operation: write
      memory_ref: workflow_context
      key_template: "analysis:{{ .workflow.id }}:results"
      payload:
        analysis_type: "{{ .tasks.analyze_data.output.type }}"
        confidence: "{{ .tasks.analyze_data.output.confidence }}"
        recommendations: "{{ .tasks.analyze_data.output.recommendations }}"

    # Retrieve for next stage
    - id: get-analysis-context
      type: memory
      operation: read
      memory_ref: workflow_context
      key_template: "analysis:{{ .workflow.id }}:results"
      outputs:
        previous_analysis: "{{ .output.payload }}"
    ```
  </Tab>
</Tabs>

## Related Documentation

<ReferenceCardList>
  <ReferenceCard
    title="Memory Tasks"
    description="Comprehensive guide to workflow memory tasks with YAML configuration and template expressions"
    href="/docs/core/tasks/memory-tasks"
    icon="FileCode"
  />
  <ReferenceCard
    title="Memory API Reference"
    description="Complete REST API documentation with endpoints, schemas, and authentication"
    href="/docs/api/memory"
    icon="Globe"
  />
  <ReferenceCard
    title="Memory Configuration"
    description="Configure memory backends, flushing strategies, and performance settings"
    href="/docs/core/memory/configuration"
    icon="Settings"
  />
  <ReferenceCard
    title="Privacy & Security"
    description="Implement data redaction, secure storage, and privacy controls"
    href="/docs/core/memory/privacy-security"
    icon="Shield"
  />
  <ReferenceCard
    title="Integration Patterns"
    description="Advanced patterns for memory integration across workflows and external systems"
    href="/docs/core/memory/integration-patterns"
    icon="Layers"
  />
  <ReferenceCard
    title="Agent Memory Integration"
    description="Automatic memory integration with AI agents for conversational applications"
    href="/docs/core/agents/memory"
    icon="Brain"
  />
</ReferenceCardList>
