---
title: "Integration Patterns"
description: "Best practices for integrating memory with agents, workflows, and tools in Compozy"
---

## Agent Memory Integration

Memory integration in Compozy allows agents to maintain conversation context and user-specific information through simple key-value storage.

### Basic Agent Memory

The simplest integration pattern uses a single memory resource with a user-specific key:

```yaml
agents:
  - id: chat_agent
    config:
      $ref: global::models.#(provider=="openai")
      temperature: 0.7
    
    memory:
      - id: conversation_memory
        key: "user:{{.workflow.input.user_id}}"
        mode: read-write
    
    instructions: |
      You are a helpful assistant with access to conversation history.
      Use the context from previous messages to provide relevant responses.
    
    actions:
      - id: chat
        prompt: |
          Current message: {{.workflow.input.message}}
          
          Respond helpfully using any relevant context from our conversation history.
```

**How this works:**
- The agent gets access to memory through the `memory` configuration
- Memory is automatically loaded when the agent starts
- The `key` template resolves to a unique identifier like `user:123`
- Previous conversation context is available to the agent during execution

### Multi-Memory Agent

For more complex scenarios, agents can access multiple memory resources:

```yaml
agents:
  - id: support_agent
    config:
      $ref: global::models.#(provider=="openai")
    
    memory:
      - id: conversation_memory
        key: "conversation:{{.workflow.input.conversation_id}}"
        mode: read-write
      - id: user_profile
        key: "user:{{.workflow.input.user_id}}"
        mode: read-only
    
    instructions: |
      You are a customer support agent with access to:
      1. Current conversation history
      2. User profile information
      
      Use all available context to provide comprehensive support.
    
    actions:
      - id: provide_support
        prompt: |
          Support Request: {{.workflow.input.request}}
          
          Use your conversation history and user profile to provide detailed support.
```

**Use cases:**
- Customer support systems with conversation and user context
- Personal assistants with user preferences and session data
- Multi-tenant applications with tenant-specific memory

## Workflow Memory Patterns

Workflow tasks can interact with memory through simple tool operations. These patterns show how to load, process, and store memory data within workflows.

### Load-Process-Store Pattern

This is the most common workflow pattern for memory-enabled tasks:

```yaml
tasks:
  # 1. Load existing context
  - id: load_context
    type: basic
    $use: tool(local::tools.#(id="memory_tool"))
    with:
      operation: "read"
      memory_key: "user:{{.workflow.input.user_id}}"
    outputs:
      context: "{{.output.messages}}"
  
  # 2. Process with agent
  - id: process_message
    type: basic
    $use: agent(local::agents.#(id="chat_agent"))
    with:
      message: "{{.workflow.input.message}}"
      context: "{{.tasks.load_context.output.context}}"
    outputs:
      response: "{{.output.response}}"
  
  # 3. Store interaction
  - id: store_interaction
    type: basic
    $use: tool(local::tools.#(id="memory_tool"))
    with:
      operation: "append"
      memory_key: "user:{{.workflow.input.user_id}}"
      message: |
        User: {{.workflow.input.message}}
        Assistant: {{.tasks.process_message.output.response}}
```

**How this works:**
- Step 1: Load existing memory using the `read` operation
- Step 2: Process the user message with the loaded context
- Step 3: Store the new interaction using the `append` operation

### Memory Health Checking

For production workflows, you can check memory health and manage token usage:

```yaml
tasks:
  # Check memory health
  - id: check_memory_health
    type: basic
    $use: tool(local::tools.#(id="memory_tool"))
    with:
      operation: "health"
      memory_key: "user:{{.workflow.input.user_id}}"
    outputs:
      token_count: "{{.output.token_count}}"
      message_count: "{{.output.message_count}}"
  
  # Conditionally flush if memory is getting full
  - id: flush_if_needed
    type: router
    condition: "{{gt .tasks.check_memory_health.output.token_count 3000}}"
    routes:
      "true":
        - id: flush_memory
          type: basic
          $use: tool(local::tools.#(id="memory_tool"))
          with:
            operation: "flush"
            memory_key: "user:{{.workflow.input.user_id}}"
      "false":
        - id: continue_processing
          type: basic
          $use: agent(local::agents.#(id="chat_agent"))
          with:
            message: "{{.workflow.input.message}}"
```

**How this works:**
- Check current memory usage with the `health` operation
- Use a router task to conditionally flush memory when approaching limits
- Continue with normal processing if memory usage is acceptable

## Tool Integration Patterns

Memory tools provide the interface between workflows and the memory system. Here are the basic tool patterns you'll use.

### Basic Memory Tool

A simple memory tool supports all basic operations:

```typescript
interface MemoryToolInput {
  operation: 'read' | 'append' | 'clear' | 'health' | 'flush';
  memory_key: string;
  message?: string;
  force?: boolean;
}

interface MemoryToolOutput {
  success: boolean;
  messages?: Array<{
    role: string;
    content: string;
    timestamp: string;
  }>;
  message_count?: number;
  token_count?: number;
  error?: string;
}

export default async function memoryTool(input: MemoryToolInput): Promise<MemoryToolOutput> {
  const { operation, memory_key, message, force = false } = input;
  
  try {
    switch (operation) {
      case 'read':
        return await readMemory(memory_key);
      
      case 'append':
        if (!message) {
          throw new Error('Message is required for append operation');
        }
        return await appendMemory(memory_key, message);
      
      case 'clear':
        return await clearMemory(memory_key);
      
      case 'health':
        return await checkMemoryHealth(memory_key);
      
      case 'flush':
        return await flushMemory(memory_key, force);
      
      default:
        throw new Error(`Unknown operation: ${operation}`);
    }
  } catch (error) {
    return {
      success: false,
      error: error.message || 'Unknown error occurred'
    };
  }
}
```

**How this works:**
- The tool accepts an operation type and memory key
- Each operation calls the appropriate memory manager function
- Results are returned with success/error status
- Tools run in the secure Bun runtime environment

### Memory Usage Examples

Here are practical examples of how to use memory in different scenarios:

#### Simple Chatbot
```yaml
# Basic conversational agent
agents:
  - id: chatbot
    memory:
      - id: conversation
        key: "chat:{{.workflow.input.user_id}}"
    
    instructions: |
      You are a friendly chatbot. Use conversation history to provide contextual responses.
    
    actions:
      - id: chat
        prompt: |
          User message: {{.workflow.input.message}}
          
          Respond naturally using our conversation history.
```

#### Multi-User Support System
```yaml
# Support agent with user and ticket context
agents:
  - id: support_agent
    memory:
      - id: ticket_memory
        key: "ticket:{{.workflow.input.ticket_id}}"
        mode: read-write
      - id: user_profile
        key: "user:{{.workflow.input.user_id}}"
        mode: read-only
    
    instructions: |
      You are a support agent. Use ticket history and user profile to provide helpful assistance.
    
    actions:
      - id: handle_ticket
        prompt: |
          Support request: {{.workflow.input.request}}
          
          Use ticket history and user profile to provide comprehensive support.
```

#### Session-Based Assistant
```yaml
# Personal assistant with session memory
agents:
  - id: personal_assistant
    memory:
      - id: session_memory
        key: "session:{{.workflow.input.session_id}}"
        mode: read-write
    
    instructions: |
      You are a personal assistant. Remember context from this session to provide better help.
    
    actions:
      - id: assist
        prompt: |
          User request: {{.workflow.input.request}}
          
          Use session context to provide personalized assistance.
```

## Memory Key Patterns

Memory keys are templates that resolve to unique identifiers. Here are common patterns:

### User-Based Keys
```yaml
# User-specific memory
key: "user:{{.workflow.input.user_id}}"
# Examples: user:123, user:456

# User conversation memory
key: "user:{{.workflow.input.user_id}}:conversation"
# Examples: user:123:conversation, user:456:conversation
```

### Session-Based Keys
```yaml
# Session-specific memory
key: "session:{{.workflow.input.session_id}}"
# Examples: session:abc123, session:def456

# Session with user context
key: "session:{{.workflow.input.session_id}}:user:{{.workflow.input.user_id}}"
# Examples: session:abc123:user:789
```

### Context-Based Keys
```yaml
# Support ticket memory
key: "ticket:{{.workflow.input.ticket_id}}"
# Examples: ticket:T-123, ticket:T-456

# Project-specific memory
key: "project:{{.workflow.input.project_id}}:{{.workflow.input.user_id}}"
# Examples: project:proj-123:user-456
```

## Best Practices

### Memory Key Design
- Use descriptive prefixes (`user:`, `session:`, `ticket:`)
- Include unique identifiers to avoid conflicts
- Keep keys reasonably short but descriptive
- Use consistent naming patterns across your application

### Memory Management
- Check memory health periodically to avoid hitting token limits
- Use the `flush` operation to manage memory size
- Consider your memory strategy (token-based vs message-based)
- Monitor memory usage in production environments

### Error Handling
- Always check for memory operation success
- Provide fallback behavior when memory is unavailable
- Log memory errors for debugging
- Consider graceful degradation when memory operations fail

### Performance Considerations
- Memory operations are fast but not instantaneous
- Use parallel tasks when loading multiple memory resources
- Consider caching frequently accessed memory data
- Monitor memory operation latency in production

## Integration Architecture

Compozy's memory integration follows a simple but effective architecture:

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   AI Agent      │    │ Workflow Task   │    │   Memory Tool   │
│                 │    │                 │    │                 │
│ • Memory Config │    │ • Tool Calls    │    │ • Operations    │
│ • Auto-loading  │    │ • Memory Ops    │    │ • Bun Runtime   │
│ • Context       │    │ • Data Flow     │    │ • JSON I/O      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                     ┌─────────────────┐
                     │ Memory Manager  │
                     │                 │
                     │ • Key Resolution│
                     │ • Template Eng. │
                     │ • Redis Store   │
                     └─────────────────┘
```

**Key components:**
- **AI Agents**: Declarative memory configuration with automatic loading
- **Workflow Tasks**: Memory operations through tool calls
- **Memory Tools**: Secure TypeScript execution in Bun runtime
- **Memory Manager**: Core memory operations with Redis storage

This simple architecture provides powerful memory capabilities while maintaining ease of use and configuration.

<ReferenceCardList>
  <ReferenceCard
    title="Memory Configuration"
    description="Setting up memory resources"
    href="/docs/core/memory/configuration"
    icon="Settings"
  />
  <ReferenceCard
    title="Memory Operations"
    description="Core memory operations and APIs"
    href="/docs/core/memory/operations"
    icon="Play"
  />
  <ReferenceCard
    title="Privacy & Security"
    description="Securing memory with redaction patterns"
    href="/docs/core/memory/privacy-security"
    icon="Shield"
  />
  <ReferenceCard
    title="Troubleshooting"
    description="Common memory issues and solutions"
    href="/docs/core/memory/troubleshooting"
    icon="Bug"
  />
</ReferenceCardList>