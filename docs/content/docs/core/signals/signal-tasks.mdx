---
title: Signal Tasks
description: Complete guide to signal tasks for sending events and coordinating workflows in Compozy
---

import {
  Radio,
  Zap,
  MessageSquare,
  Clock,
  Share,
  Database,
  Activity,
  Bell,
  CheckCircle,
  AlertCircle,
  Code,
  GitBranch,
  Route,
  Timer,
  Network,
  Users,
  Shield,
  Target,
  FileText,
  Settings,
  Play,
  Pause,
  RefreshCw,
  TrendingUp,
  BookOpen,
  ExternalLink,
  ArrowRight,
  Box,
  Workflow,
  Info,
  AlertTriangle,
  CheckCircle2,
  Gauge,
  Layers,
  Link,
  Eye,
  Repeat,
  CloudSun,
  HeadphonesIcon,
  Cpu,
  PenTool,
} from "lucide-react";
import { FeatureCard, FeatureCardList } from "@/components/ui/feature-card";
import { ReferenceCard, ReferenceCardList } from "@/components/ui/reference-card";
import { Callout } from "@/components/ui/callout";
import { Tabs, Tab } from "@/components/ui/tabs";
import { Steps, Step } from "@/components/ui/step";
import { Mermaid } from "@/components/ui/mermaid";

# Signal Tasks

Signal tasks are **event emitters** in Compozy workflows that send messages to other workflows or tasks. They enable decoupled communication patterns, event-driven architectures, and sophisticated workflow coordination.

<Callout type="info" title="Signal Dispatch">
Signal tasks use **Redis** for high-performance message dispatch, ensuring reliable delivery and scalability across distributed workflow systems.
</Callout>

## Core Signal Task Features

<FeatureCardList cols={3} size="sm">
  <FeatureCard
    title="Event Emission"
    description="Send structured messages to coordinate workflows"
    icon={Radio}
  />
  <FeatureCard
    title="Payload Support"
    description="Include rich data in signal messages"
    icon={Database}
  />
  <FeatureCard
    title="Template Integration"
    description="Use dynamic templates for signal IDs and payloads"
    icon={Code}
  />
</FeatureCardList>

## Basic Signal Task

### Configuration Structure

```yaml
- id: send-notification
  type: signal
  signal:
    id: "notification-signal"
    payload:
      message: "Task completed successfully"
      timestamp: "{{ now }}"
```

### Required Configuration

<FeatureCardList cols={3} size="sm">
  <FeatureCard
    title="type: signal"
    description="Identifies the task as a signal emitter"
    icon={Settings}
  />
  <FeatureCard
    title="signal.id"
    description="Unique identifier for signal routing"
    icon={Target}
  />
  <FeatureCard
    title="signal.payload"
    description="Optional structured data to send"
    icon={FileText}
  />
</FeatureCardList>

## Signal Configuration

### Signal ID Patterns

The signal ID determines which wait tasks will receive the signal:

<Tabs items={["Static IDs", "Dynamic IDs", "Template-based IDs"]}>
<Tab>

```yaml
signal:
  id: "order-processed"
  id: "user-approved"
  id: "task-completed"
```

<Callout type="info" title="Static IDs">
Use static IDs for **consistent system events** that don't vary between workflow instances.
</Callout>

</Tab>
<Tab>

```yaml
signal:
  id: "user-{{ .workflow.input.user_id }}-approved"
  id: "order-{{ .workflow.input.order_id }}-processed"
  id: "workflow-{{ .workflow.id }}-status"
```

<Callout type="success" title="Dynamic IDs">
Dynamic IDs enable **targeted messaging** to specific workflow instances or entities.
</Callout>

</Tab>
<Tab>

```yaml
signal:
  id: "{{ .workflow.input.signal_name }}"
  id: "{{ .workflow.input.event_type }}-{{ .workflow.input.entity_id }}"
  id: "{{ .task.output.signal_type }}"
```

<Callout type="warning" title="Template-based IDs">
Fully template-based IDs provide **maximum flexibility** but require careful validation.
</Callout>

</Tab>
</Tabs>

### Signal Payload Structure

<Tabs items={["Simple Payload", "Complex Payload", "Template Payload"]}>
<Tab>

```yaml
signal:
  id: "task-done"
  payload:
    success: true
    task_id: "{{ .task.id }}"
    timestamp: "{{ now }}"
```

<FeatureCardList cols={2} size="sm">
  <FeatureCard
    title="Lightweight"
    description="Simple key-value data structures"
    icon={Bell}
  />
  <FeatureCard
    title="Fast Processing"
    description="Quick serialization and transmission"
    icon={Zap}
  />
</FeatureCardList>

</Tab>
<Tab>

```yaml
signal:
  id: "data-processed"
  payload:
    workflow_id: "{{ .workflow.id }}"
    execution_id: "{{ .workflow.exec_id }}"
    results: "{{ .task.output.results }}"
    metadata:
      processed_at: "{{ now }}"
      processor: "{{ .agent.id }}"
      duration: "{{ .task.duration }}"
```

<FeatureCardList cols={2} size="sm">
  <FeatureCard
    title="Rich Context"
    description="Nested structures with comprehensive data"
    icon={Database}
  />
  <FeatureCard
    title="System Integration"
    description="Full workflow and task context"
    icon={Network}
  />
</FeatureCardList>

</Tab>
<Tab>

```yaml
signal:
  id: "{{ .workflow.input.signal_type }}"
  payload:
    dynamic_field: "{{ .workflow.input.field_name }}"
    computed_value: "{{ .task.output | jsonPath '$.result.value' }}"
    conditional_data: "{{ .task.success | ternary 'success' 'failure' }}"
```

<FeatureCardList cols={2} size="sm">
  <FeatureCard
    title="Dynamic Content"
    description="Fully customizable signal structure"
    icon={Code}
  />
  <FeatureCard
    title="Advanced Logic"
    description="Complex template expressions and functions"
    icon={GitBranch}
  />
</FeatureCardList>

</Tab>
</Tabs>

## Signal Task Examples

### Common Signal Patterns

<FeatureCardList cols={4} size="sm">
  <FeatureCard
    title="Notifications"
    description="Simple event notifications"
    icon={Bell}
  />
  <FeatureCard
    title="Data Transfer"
    description="Share processed data"
    icon={Share}
  />
  <FeatureCard
    title="Status Changes"
    description="Workflow state updates"
    icon={Activity}
  />
  <FeatureCard
    title="Error Handling"
    description="Error notifications"
    icon={AlertCircle}
  />
</FeatureCardList>

<Tabs items={["Notifications", "Data Transfer", "Status Changes", "Error Handling"]}>
<Tab>

### Simple Notification

Send a basic completion notification:

```yaml
- id: notify-completion
  type: signal
  signal:
    id: "task-completed"
    payload:
      task_id: "{{ .task.id }}"
      status: "completed"
      timestamp: "{{ now }}"
  
  description: "Notify other workflows that task is complete"
```

<Callout type="info" title="Notification Patterns">
Perfect for **simple events** that don't require complex data but need to trigger downstream actions.
</Callout>

</Tab>
<Tab>

### Data Transfer Signal

Send processed data to waiting workflows:

```yaml
- id: share-processed-data
  type: signal
  signal:
    id: "data-ready"
    payload:
      dataset_id: "{{ .workflow.input.dataset_id }}"
      records_processed: "{{ .task.output.count }}"
      data_location: "{{ .task.output.file_path }}"
      schema_version: "{{ .workflow.input.schema_version }}"
      processing_metadata:
        started_at: "{{ .workflow.started_at }}"
        completed_at: "{{ now }}"
        processor_version: "v2.1.0"
```

<Callout type="success" title="Data Sharing">
Enable **rich data transfer** between workflows while maintaining loose coupling.
</Callout>

</Tab>
<Tab>

### Status Change Signal

Notify about workflow state changes:

```yaml
- id: workflow-status-change
  type: signal
  signal:
    id: "workflow-status-{{ .workflow.input.workflow_type }}"
    payload:
      workflow_id: "{{ .workflow.id }}"
      previous_status: "{{ .workflow.previous_status }}"
      current_status: "running"
      changed_by: "{{ .workflow.input.user_id }}"
      reason: "{{ .task.output.reason }}"
      context:
        environment: "{{ .env.ENVIRONMENT }}"
        region: "{{ .env.AWS_REGION }}"
```

<Callout type="info" title="State Tracking">
Ideal for **system monitoring** and maintaining audit trails of workflow state changes.
</Callout>

</Tab>
<Tab>

### Error Signal

Send error notifications:

```yaml
- id: send-error-signal
  type: signal
  signal:
    id: "workflow-error"
    payload:
      workflow_id: "{{ .workflow.id }}"
      error_type: "{{ .task.error.type }}"
      error_message: "{{ .task.error.message }}"
      failed_task: "{{ .task.id }}"
      context: "{{ .task.input }}"
      occurred_at: "{{ now }}"
```

<Callout type="warning" title="Error Handling">
Critical for **error monitoring** and implementing robust error handling patterns.
</Callout>

</Tab>
</Tabs>

## Advanced Signal Patterns

### Advanced Coordination Strategies

<FeatureCardList cols={3} size="sm">
  <FeatureCard
    title="Conditional Signals"
    description="Send signals based on runtime conditions"
    icon={Route}
  />
  <FeatureCard
    title="Multiple Dispatch"
    description="Send multiple signals from one task"
    icon={GitBranch}
  />
  <FeatureCard
    title="Dynamic Routing"
    description="Route signals based on runtime data"
    icon={Repeat}
  />
</FeatureCardList>

<Tabs items={["Conditional Signals", "Multiple Dispatch", "Dynamic Routing"]}>
<Tab>

### Conditional Signals

Send signals based on conditions:

```yaml
- id: conditional-approval
  type: router
  condition: '{{ .task.output.amount > 1000 }}'
  routes:
    true:
      # High-value approval signal
      - id: high-value-approval
        type: signal
        signal:
          id: "high-value-approval-needed"
          payload:
            amount: "{{ .task.output.amount }}"
            priority: "high"
    false:
      # Auto-approval signal
      - id: auto-approval
        type: signal
        signal:
          id: "auto-approved"
          payload:
            amount: "{{ .task.output.amount }}"
            priority: "low"
```

<Callout type="info" title="Conditional Logic">
Use **router tasks** to implement complex business logic and conditional signal dispatch.
</Callout>

</Tab>
<Tab>

### Multiple Signal Dispatch

Send multiple signals from one task:

```yaml
- id: multi-signal-dispatch
  type: composite
  tasks:
    - id: notify-completion
      type: signal
      signal:
        id: "task-completed"
        payload:
          task_id: "{{ .parent.id }}"
    
    - id: notify-stakeholders
      type: signal
      signal:
        id: "stakeholder-notification"
        payload:
          event: "task-completed"
          stakeholders: "{{ .workflow.input.stakeholders }}"
    
    - id: update-metrics
      type: signal
      signal:
        id: "metrics-update"
        payload:
          metric_type: "task_completion"
          value: 1
          tags:
            workflow: "{{ .workflow.id }}"
            task_type: "{{ .parent.type }}"
```

<Callout type="success" title="Composite Tasks">
Use **composite tasks** to coordinate multiple signal dispatches with shared context.
</Callout>

</Tab>
<Tab>

### Dynamic Signal Routing

Route signals based on runtime data:

```yaml
- id: dynamic-signal-routing
  type: collection
  items: "{{ .task.output.recipients }}"
  task:
    id: "notify-recipient-{{ .index }}"
    type: signal
    signal:
      id: "{{ .item.signal_type }}"
      payload:
        recipient_id: "{{ .item.id }}"
        message: "{{ .item.message }}"
        priority: "{{ .item.priority }}"
        data: "{{ .parent.output.data }}"
```

<Callout type="warning" title="Collection Tasks">
Use **collection tasks** for dynamic signal routing when recipients are determined at runtime.
</Callout>

</Tab>
</Tabs>

## Signal Task Integration

### Integration Patterns

<FeatureCardList cols={2} size="sm">
  <FeatureCard
    title="Error Handling"
    description="Handle signal dispatch failures gracefully"
    icon={Shield}
  />
  <FeatureCard
    title="Workflow Integration"
    description="Signal tasks within complex workflows"
    icon={Workflow}
  />
</FeatureCardList>

<Tabs items={["Error Handling", "Workflow Integration"]}>
<Tab>

### With Error Handling

Handle signal dispatch failures gracefully:

```yaml
- id: robust-signal
  type: signal
  signal:
    id: "important-notification"
    payload:
      data: "{{ .task.output }}"
  
  on_error: handle-signal-failure
  retry:
    max_attempts: 3
    backoff: exponential
  
  outputs:
    signal_sent: "{{ .task.success }}"
    signal_id: "important-notification"
```

<Callout type="warning" title="Resilience">
Always implement **error handling and retry logic** for critical signal dispatch operations.
</Callout>

</Tab>
<Tab>

### With Workflows

Signal tasks in workflow context:

```yaml
id: order-processing-workflow
tasks:
  - id: process-order
    type: basic
    tool:
      id: order-processor
    with:
      order_id: "{{ .workflow.input.order_id }}"
  
  - id: notify-fulfillment
    type: signal
    signal:
      id: "order-ready-for-fulfillment"
      payload:
        order_id: "{{ .workflow.input.order_id }}"
        processed_items: "{{ .tasks.process-order.output.items }}"
        shipping_address: "{{ .workflow.input.shipping_address }}"
        priority: "{{ .workflow.input.priority }}"
    
    depends_on: [process-order]
```

<Callout type="success" title="Dependencies">
Use **depends_on** to ensure signals are sent after prerequisite tasks complete successfully.
</Callout>

</Tab>
</Tabs>

## Signal Payload Best Practices

### Design Principles

<FeatureCardList cols={3} size="sm">
  <FeatureCard
    title="Essential Context"
    description="Provide all necessary information for receivers"
    icon={Info}
  />
  <FeatureCard
    title="Consistent Structure"
    description="Maintain standardized payload formats"
    icon={Layers}
  />
  <FeatureCard
    title="Data Validation"
    description="Ensure signal payloads are valid and complete"
    icon={Shield}
  />
</FeatureCardList>

<Tabs items={["Essential Context", "Consistent Structure", "Data Validation"]}>
<Tab>

### Include Essential Context

Provide all necessary information for receivers:

```yaml
# ✅ Comprehensive payload
signal:
  id: "payment-processed"
  payload:
    transaction_id: "{{ .task.output.transaction_id }}"
    amount: "{{ .workflow.input.amount }}"
    currency: "{{ .workflow.input.currency }}"
    customer_id: "{{ .workflow.input.customer_id }}"
    payment_method: "{{ .workflow.input.payment_method }}"
    processed_at: "{{ now }}"
    processing_time_ms: "{{ .task.duration_ms }}"

# ❌ Insufficient context
signal:
  id: "payment-done"
  payload:
    success: true
```

<Callout type="success" title="Context Guidelines">
Include **complete context** so receivers can process signals without additional lookups.
</Callout>

</Tab>
<Tab>

### Use Consistent Structure

Maintain consistent payload structures across signals:

```yaml
# Standard payload structure
signal:
  id: "{{ .signal_type }}"
  payload:
    # Core data
    entity_id: "{{ .entity.id }}"
    entity_type: "{{ .entity.type }}"
    
    # Event data
    event:
      type: "{{ .event.type }}"
      timestamp: "{{ now }}"
      source: "{{ .workflow.id }}"
    
    # Metadata
    metadata:
      workflow_id: "{{ .workflow.id }}"
      task_id: "{{ .task.id }}"
      user_id: "{{ .workflow.input.user_id }}"
    
    # Actual data
    data: "{{ .task.output }}"
```

<Callout type="info" title="Standardization">
Use **standard payload structures** to simplify signal processing and reduce integration complexity.
</Callout>

</Tab>
<Tab>

### Validate Signal Data

Ensure signal payloads are valid:

```yaml
- id: validated-signal
  type: signal
  
  # Validate before sending
  input:
    type: object
    properties:
      required_field:
        type: string
        minLength: 1
    required: [required_field]
  
  signal:
    id: "validated-event"
    payload:
      validated_data: "{{ .task.input.required_field }}"
      validation_passed: true
```

<Callout type="warning" title="Validation">
Always **validate payload data** before sending signals to prevent downstream processing errors.
</Callout>

</Tab>
</Tabs>

## Performance Considerations

### Signal Optimization Strategies

<FeatureCardList cols={3} size="sm">
  <FeatureCard
    title="Minimize Payload Size"
    description="Include only necessary data for efficient transmission"
    icon={Gauge}
  />
  <FeatureCard
    title="Use References"
    description="Pass IDs instead of large objects when possible"
    icon={Link}
  />
  <FeatureCard
    title="Batch Signals"
    description="Group related signals for optimized processing"
    icon={Layers}
  />
</FeatureCardList>

<Tabs items={["Payload Optimization", "Reference Patterns", "Batching Strategies"]}>
<Tab>

### Minimize Payload Size

```yaml
# ✅ Optimized signal
signal:
  id: "data-processed"
  payload:
    dataset_id: "{{ .dataset.id }}"  # Reference instead of full data
    record_count: "{{ .task.output.count }}"
    location: "{{ .task.output.path }}"

# ❌ Unoptimized signal
signal:
  id: "data-processed"
  payload:
    full_dataset: "{{ .task.output.all_records }}"  # Large payload
```

<Callout type="success" title="Payload Optimization">
Keep payloads **small and focused** to reduce Redis memory usage and improve dispatch performance.
</Callout>

</Tab>
<Tab>

### Use References

```yaml
# ✅ Reference-based approach
signal:
  id: "user-profile-updated"
  payload:
    user_id: "{{ .workflow.input.user_id }}"
    profile_version: "{{ .task.output.version }}"
    updated_fields: ["name", "email", "preferences"]
    cache_key: "user:{{ .workflow.input.user_id }}:profile"

# ❌ Data-heavy approach
signal:
  id: "user-profile-updated"
  payload:
    user_data: "{{ .task.output.complete_user_object }}"  # Large object
```

<Callout type="info" title="Reference Strategy">
Use **references and keys** to enable receivers to fetch full data when needed.
</Callout>

</Tab>
<Tab>

### Batching Strategies

```yaml
# ✅ Batch processing signal
signal:
  id: "batch-processed"
  payload:
    batch_id: "{{ .workflow.input.batch_id }}"
    processed_items: "{{ .task.output.item_ids }}"
    batch_size: "{{ .task.output.item_ids | length }}"
    processing_summary:
      success_count: "{{ .task.output.success_count }}"
      error_count: "{{ .task.output.error_count }}"
```

<Callout type="warning" title="Batching Benefits">
**Batch related signals** to reduce the number of dispatches and improve system throughput.
</Callout>

</Tab>
</Tabs>

## Testing Signal Tasks

### Testing Strategies

<FeatureCardList cols={2} size="sm">
  <FeatureCard
    title="Unit Testing"
    description="Test individual signal task configurations"
    icon={Code}
  />
  <FeatureCard
    title="Integration Testing"
    description="Test signal flow between workflows"
    icon={Network}
  />
</FeatureCardList>

<Tabs items={["Unit Testing", "Integration Testing"]}>
<Tab>

### Unit Testing

```yaml
# Test signal task configuration
- id: test-signal
  type: signal
  signal:
    id: "test-event"
    payload:
      test_data: "hello world"
      timestamp: "{{ now }}"
  
  # Verify signal is sent correctly
  outputs:
    signal_dispatched: true
    signal_id: "test-event"
```

<Callout type="info" title="Unit Testing">
Focus on **signal configuration** and payload structure validation in unit tests.
</Callout>

</Tab>
<Tab>

### Integration Testing

```yaml
# Sender workflow
- id: send-test-signal
  type: signal
  signal:
    id: "integration-test"
    payload:
      test_id: "{{ .workflow.input.test_id }}"
      data: "test payload"

# Receiver workflow (separate file)
- id: receive-test-signal
  type: wait
  wait_for: "integration-test"
  timeout: 10s
```

<Callout type="success" title="Integration Testing">
Test **end-to-end signal flow** between workflows to ensure proper coordination.
</Callout>

</Tab>
</Tabs>

## Error Handling

### Signal Dispatch Failures

Handle cases where signals cannot be sent:

```yaml
- id: monitored-signal
  type: signal
  signal:
    id: "critical-notification"
    payload:
      event: "critical-event"
      data: "{{ .task.output }}"
  
  on_error: 
    next: fallback-notification
    with:
      error_details: "{{ .task.error }}"
  
  outputs:
    signal_status: "{{ .task.success ? 'sent' : 'failed' }}"
```

<Callout type="warning" title="Error Handling">
Always implement **error handling** for signal dispatch failures to maintain workflow reliability.
</Callout>

## Next Steps

<ReferenceCardList>
  <ReferenceCard
    title="Wait Tasks"
    description="Learn to receive signals with conditions, timeouts, and processors"
    href="/docs/core/signals/wait-tasks"
    icon={Timer}
  />
  <ReferenceCard
    title="Signal Triggers"
    description="Explore workflow initiation and signal-based automation"
    href="/docs/core/signals/signal-triggers"
    icon={Play}
  />
  <ReferenceCard
    title="Event API"
    description="REST API for programmatic signal management and monitoring"
    href="/docs/core/signals/event-api"
    icon={Code}
  />
  <ReferenceCard
    title="Advanced Patterns"
    description="Study complex scenarios and signal coordination strategies"
    href="/docs/core/signals/advanced-patterns"
    icon={GitBranch}
  />
</ReferenceCardList>

### Related Documentation

<ReferenceCardList>
  <ReferenceCard
    title="Signal System Overview"
    description="Complete guide to Compozy's signal system and architecture"
    href="/docs/core/signals/signal-overview"
    icon={Radio}
  />
  <ReferenceCard
    title="Task Types"
    description="Understand all task types including signal and wait tasks"
    href="/docs/core/tasks/basic-tasks"
    icon={Box}
  />
  <ReferenceCard
    title="Workflow Orchestration"
    description="Learn workflow coordination patterns and best practices"
    href="/docs/core/workflows/orchestration"
    icon={Workflow}
  />
  <ReferenceCard
    title="Redis Configuration"
    description="Configure Redis backend for signal dispatch and persistence"
    href="/docs/core/configuration/redis"
    icon={Database}
  />
</ReferenceCardList>

### Use Cases & Examples

<ReferenceCardList>
  <ReferenceCard
    title="Weather System"
    description="Complete weather advisory system with signal coordination"
    href="/docs/core/examples/weather"
    icon={CloudSun}
  />
  <ReferenceCard
    title="Customer Support"
    description="Multi-agent support workflows with signal-based routing"
    href="/docs/core/examples/customer-support"
    icon={HeadphonesIcon}
  />
  <ReferenceCard
    title="Data Processing"
    description="Batch processing pipelines with signal orchestration"
    href="/docs/core/examples/data-processing"
    icon={Cpu}
  />
  <ReferenceCard
    title="Content Generation"
    description="AI-powered content workflows with signal coordination"
    href="/docs/core/examples/content-generation"
    icon={PenTool}
  />
</ReferenceCardList>
