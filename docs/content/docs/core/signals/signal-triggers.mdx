---
title: Signal Triggers
description: Complete guide to signal-based workflow triggers and event-driven workflow initiation in Compozy
---

Signal triggers enable **automatic workflow initiation** through event-driven patterns in Compozy, transforming reactive system design from manual orchestration to intelligent automation. Workflows start automatically when specific signals are received, creating sophisticated publish-subscribe architectures that respond to system events, external webhooks, user actions, or [signal tasks](/docs/core/signals/signal-tasks) from distributed workflows. This integration with [workflow configuration](/docs/core/configuration/workflows) and the [Event API](/docs/core/signals/event-api) creates the foundation for enterprise-scale reactive architectures.

<Callout type="info">
New to Compozy? Start with the [Quick Start guide](/docs/core/getting-started/quick-start) to understand basic concepts, then explore [your first workflow](/docs/core/getting-started/first-workflow) before diving into advanced signal-driven patterns.
</Callout>

## Enterprise Benefits

<FeatureCardList cols={2} size="default">
  <FeatureCard
    title="Reactive Architecture"
    description="Build systems that automatically respond to business events, system alerts, and user actions with zero manual intervention"
    icon="Zap"
  />
  <FeatureCard
    title="Loose Coupling"
    description="Decouple event producers from consumers using publish-subscribe patterns, enabling independent service evolution"
    icon="Network"
  />
  <FeatureCard
    title="Real-Time Processing"
    description="Process events as they occur with sub-second latency using Temporal's distributed execution engine"
    icon="Timer"
  />
  <FeatureCard
    title="Schema Validation"
    description="Use JSON Schema to validate signal payloads and ensure data integrity"
    icon="Filter"
  />
</FeatureCardList>

## Trigger Architecture

<Mermaid chart={`graph LR
    A[Signal Source] --> B[Temporal Signal Dispatcher]
    B --> C[Dispatcher Workflow]
    C --> D{Signal Match?}
    D -->|Yes| E[Start Child Workflow]
    D -->|No| F[Ignore Signal]
    E --> G[Merge Payload]
    G --> H[Execute Tasks]

    style A fill:#e1f5fe
    style B fill:#37474f,color:#fff
    style C fill:#673ab7,color:#fff
    style E fill:#e8f5e8`} />

<List className="mt-6">
  <ListItem title="Signal Publication" icon="Send">
    Events are published via [Event API](/docs/core/signals/event-api), [signal tasks](/docs/core/signals/signal-tasks), or external integrations
  </ListItem>
  <ListItem title="Signal Routing" icon="Target">
    Dispatcher Workflow routes signals to target workflows using signal name matching and schema validation
  </ListItem>
  <ListItem title="Child Workflow Execution" icon="Play">
    Target workflows start as child workflows with signal payload merged into input context and proper execution tracking
  </ListItem>
  <ListItem title="Temporal Orchestration" icon="Activity">
    Child workflows are managed by Temporal with built-in retry, timeout, and state persistence capabilities
  </ListItem>
</List>

<Callout type="info" className="mt-8">
  Signal triggers integrate seamlessly with Temporal workflows, providing durability, retry logic, and distributed execution. This ensures reliable event processing even during system failures.
</Callout>

## Configuration

Understanding signal trigger configuration is essential for building event-driven workflows. Signal triggers are defined in the `triggers` section of your [workflow configuration](/docs/core/configuration/workflows) and support sophisticated filtering and validation using template expressions for precise control over workflow activation.

<Callout type="warning">
Before implementing signal triggers, ensure you understand [workflow basics](/docs/core/getting-started/first-workflow) and [signal system concepts](/docs/core/signals/overview). Signal triggers build on these foundational concepts and integrate with the broader [Compozy ecosystem](/docs/core/getting-started/core-concepts).
</Callout>

<Steps>
<Step title="Define Trigger Type" description="Specify signal trigger in workflow configuration">

```yaml
id: user-registration-handler
version: "1.0"
description: "Handle new user registrations"

triggers:
  - type: signal
    name: "user-registered"
```

</Step>

<Step title="Configure Input Schema" description="Define expected signal payload structure using JSON Schema">

```yaml
input:
  type: object
  properties:
    user_id:
      type: string
      description: "Unique user identifier"
    email:
      type: string
      format: email
    registration_data:
      type: object
      properties:
        source: { type: string }
        plan: { type: string }
  required: [user_id, email]
```

</Step>

<Step title="Implement Processing Logic" description="Define tasks that execute when signal is received">

```yaml
tasks:
  - id: validate-registration
    type: basic
    tool: user-validator
    with:
      user_data: "{{ .workflow.input.registration_data }}"

  - id: create-profile
    type: basic
    agent: profile-creator
    instructions: "Create comprehensive user profile"
    with:
      user_id: "{{ .workflow.input.user_id }}"
      email: "{{ .workflow.input.email }}"
    depends_on: [validate-registration]
```

</Step>
</Steps>

## Properties

| Property   | Required | Description |
|------------|----------|-------------|
| **type**   | Yes      | Must be `signal` for signal-based triggers. Part of Compozy's [workflow trigger system](/docs/core/configuration/workflows#triggers). |
| **name**   | Yes      | Unique signal identifier matching events sent via [Event API](/docs/core/signals/event-api) or [signal tasks](/docs/core/signals/signal-tasks). Supports kebab-case naming convention. |
| **schema** | No       | JSON Schema validation for signal payload. Ensures data integrity and provides clear contracts for signal publishers. |

## Practical Examples

Explore real-world implementations of signal triggers across different use cases. These examples demonstrate best practices for event-driven workflow design.

<Tabs items={["User Registration", "Order Processing", "System Alerts"]}>
<Tab>

This example demonstrates a complete user onboarding workflow triggered by registration events. It showcases validation, parallel processing, and notification patterns commonly used in production systems.

```yaml
id: user-registration-handler
version: "1.0"
description: "Complete user onboarding triggered by registration events"

triggers:
  - type: signal
    name: "user-registered"

input:
  type: object
  properties:
    user_id:
      type: string
      description: "Unique user identifier"
    email:
      type: string
      format: email
    registration_data:
      type: object
      properties:
        name: { type: string }
        source: { type: string }
        plan: { type: string, enum: ["free", "pro", "enterprise"] }
  required: [user_id, email, registration_data]

tasks:
  - id: parallel-onboarding
    type: parallel
    strategy: best_effort
    tasks:
      - id: validate-registration
        type: basic
        tool: user-validator
        with:
          user_data: "{{ .workflow.input.registration_data }}"
          compliance_check: true

      - id: create-user-profile
        type: basic
        agent: profile-creator
        instructions: |
          Create a comprehensive user profile with:
          - Account preferences based on registration source
          - Default settings for their plan type
          - Personalization recommendations
        with:
          user_id: "{{ .workflow.input.user_id }}"
          email: "{{ .workflow.input.email }}"
          plan: "{{ .workflow.input.registration_data.plan }}"

  - id: route-by-plan
    type: router
    condition: 'workflow.input.registration_data.plan'
    routes:
      free:
        type: basic
        tool: email-sender
        with:
          template: "welcome-free"
          to: "{{ .workflow.input.email }}"

      pro:
        type: composite
        tasks:
          - id: send-pro-welcome
            type: basic
            tool: email-sender
            with:
              template: "welcome-pro"
              to: "{{ .workflow.input.email }}"

          - id: schedule-onboarding
            type: signal
            signal:
              id: "schedule-onboarding-call"
              payload:
                user_id: "{{ .workflow.input.user_id }}"
                plan: "pro"
            depends_on: [send-pro-welcome]

      enterprise:
        type: signal
        signal:
          id: "enterprise-onboarding-required"
          payload:
            user_id: "{{ .workflow.input.user_id }}"
            email: "{{ .workflow.input.email }}"
            priority: "high"

    depends_on: [parallel-onboarding]

  - id: notify-completion
    type: signal
    signal:
      id: "onboarding-completed"
      payload:
        user_id: "{{ .workflow.input.user_id }}"
        plan: "{{ .workflow.input.registration_data.plan }}"
        timestamp: "{{ now }}"
    depends_on: [route-by-plan]
```

<Callout type="info">
This example demonstrates several key patterns: [parallel task execution](/docs/core/tasks/parallel-processing) for concurrent operations, [router tasks](/docs/core/tasks/router-tasks) for conditional logic, and [signal tasks](/docs/core/signals/signal-tasks) for event propagation. The workflow structure follows Compozy's composable task approach.
</Callout>

</Tab>
<Tab>

Implement a robust order processing system that validates inventory, processes payments, and coordinates fulfillment - all triggered by order creation events.

```yaml
id: order-processing-pipeline
version: "1.0"
description: "Automated order processing with validation and fulfillment"

triggers:
  - type: signal
    name: "order-created"

input:
  type: object
  properties:
    order_id:
      type: string
      pattern: "^ORD-[0-9]+$"
    customer_id:
      type: string
    items:
      type: array
      items:
        type: object
        properties:
          sku: { type: string }
          quantity: { type: integer, minimum: 1 }
          price: { type: number }
        required: [sku, quantity, price]
    total_amount:
      type: number
      minimum: 0
  required: [order_id, customer_id, items, total_amount]

tasks:
  - id: validate-order
    type: composite
    strategy: fail_fast
    timeout: 30s
    tasks:
      - id: check-inventory
        type: basic
        tool: inventory-checker
        with:
          items: "{{ .workflow.input.items }}"
          reserve_stock: false

      - id: validate-customer
        type: basic
        agent: customer-validator
        instructions: "Validate customer creditworthiness and shipping address"
        with:
          customer_id: "{{ .workflow.input.customer_id }}"
          order_amount: "{{ .workflow.input.total_amount }}"

      - id: calculate-shipping
        type: basic
        tool: shipping-calculator
        with:
          items: "{{ .workflow.input.items }}"
          customer_id: "{{ .workflow.input.customer_id }}"

  - id: process-payment
    type: basic
    tool: payment-processor
    with:
      order_id: "{{ .workflow.input.order_id }}"
      amount: "{{ .workflow.input.total_amount }}"
      customer_id: "{{ .workflow.input.customer_id }}"
      shipping_cost: "{{ .tasks.validate-order.outputs.calculate-shipping.cost }}"

    retry:
      max_attempts: 3
      backoff: exponential
      initial_interval: 1s

    on_error:
      type: signal
      signal:
        id: "payment-failed"
        payload:
          order_id: "{{ .workflow.input.order_id }}"
          error: "{{ .task.error }}"

    depends_on: [validate-order]

  - id: finalize-order
    type: parallel
    strategy: best_effort
    tasks:
      - id: reserve-inventory
        type: basic
        tool: inventory-manager
        with:
          operation: "reserve"
          items: "{{ .workflow.input.items }}"
          order_id: "{{ .workflow.input.order_id }}"

      - id: create-shipment
        type: basic
        tool: shipment-creator
        with:
          order_id: "{{ .workflow.input.order_id }}"
          items: "{{ .workflow.input.items }}"
          shipping_method: "{{ .tasks.validate-order.outputs.calculate-shipping.method }}"

      - id: send-confirmation
        type: basic
        tool: notification-service
        with:
          type: "order-confirmation"
          customer_id: "{{ .workflow.input.customer_id }}"
          order_details:
            order_id: "{{ .workflow.input.order_id }}"
            total: "{{ .workflow.input.total_amount }}"
            items: "{{ .workflow.input.items }}"

    depends_on: [process-payment]

  - id: trigger-fulfillment
    type: signal
    signal:
      id: "order-ready-for-fulfillment"
      payload:
        order_id: "{{ .workflow.input.order_id }}"
        shipment_id: "{{ .tasks.finalize-order.outputs.create-shipment.shipment_id }}"
        warehouse: "{{ .tasks.finalize-order.outputs.reserve-inventory.warehouse }}"
        priority: |
          {{ if gt .workflow.input.total_amount 1000 }}
            high
          {{ else }}
            normal
          {{ end }}
    depends_on: [finalize-order]
```

<Callout type="info">
Notice the use of composite tasks with `fail_fast` strategy for validation, ensuring all checks pass before payment processing. The [retry configuration](/docs/core/tasks/basic-tasks#retry-configuration) on payment processing handles transient failures gracefully, while [error handling patterns](/docs/core/tasks/basic-tasks#error-handling) provide robust failure recovery.
</Callout>

</Tab>
<Tab>

Build an intelligent incident response system that automatically triages alerts, performs initial remediation, and escalates when necessary.

```yaml
id: incident-response-handler
version: "1.0"
description: "Intelligent incident response with automated remediation"

triggers:
  - type: signal
    name: "system-alert"

input:
  type: object
  properties:
    alert_id:
      type: string
      pattern: "^ALERT-[0-9]+$"
    severity:
      type: string
      enum: ["low", "medium", "high", "critical"]
    service:
      type: string
    message:
      type: string
    metrics:
      type: object
      properties:
        error_rate: { type: number }
        response_time: { type: number }
        cpu_usage: { type: number }
        memory_usage: { type: number }
  required: [alert_id, severity, service, message]

tasks:
  - id: enrich-context
    type: parallel
    tasks:
      - id: fetch-service-state
        type: basic
        tool: service-monitor
        with:
          service: "{{ .workflow.input.service }}"
          metrics: ["health", "dependencies", "recent_errors"]

      - id: check-recent-changes
        type: basic
        tool: deployment-tracker
        with:
          service: "{{ .workflow.input.service }}"
          time_window: "1h"

      - id: analyze-patterns
        type: basic
        agent: anomaly-detector
        instructions: "Identify patterns and anomalies in metrics"
        with:
          current_metrics: "{{ .workflow.input.metrics }}"
          service: "{{ .workflow.input.service }}"

  - id: assess-incident
    type: basic
    agent: incident-analyzer
    model: claude-4-opus
    instructions: |
      Analyze the incident with the enriched context and determine:
      1. Root cause analysis based on metrics and recent changes
      2. Blast radius and affected components
      3. Immediate remediation actions (safe to automate)
      4. Whether human intervention is required
      5. Priority score (0-100) for escalation
    with:
      alert: "{{ .workflow.input }}"
      service_state: "{{ .tasks.enrich-context.outputs.fetch-service-state }}"
      recent_changes: "{{ .tasks.enrich-context.outputs.check-recent-changes }}"
      patterns: "{{ .tasks.enrich-context.outputs.analyze-patterns }}"
    depends_on: [enrich-context]

  - id: automated-response
    type: router
    condition: |
      {{
        $priority := .tasks.assess-incident.output.priority_score
        $auto_safe := .tasks.assess-incident.output.auto_remediation_safe

        if and (lt $priority 50) $auto_safe
          "auto_remediate"
        else if and (ge $priority 50) (lt $priority 80)
          "assisted_remediate"
        else
          "escalate_only"
      }}

    routes:
      auto_remediate:
        type: composite
        strategy: best_effort
        tasks:
          - id: apply-fixes
            type: basic
            tool: auto-remediation
            with:
              actions: "{{ .tasks.assess-incident.output.remediation_actions }}"
              service: "{{ .workflow.input.service }}"
              dry_run: false

          - id: verify-fix
            type: wait
            wait_for: "service-healthy"
            timeout: "5m"
            on_timeout: "handle-timeout"
            depends_on: [apply-fixes]

      assisted_remediate:
        type: composite
        tasks:
          - id: prepare-runbook
            type: basic
            agent: runbook-generator
            instructions: "Generate step-by-step remediation runbook"
            with:
              incident: "{{ .tasks.assess-incident.output }}"

          - id: notify-oncall
            type: basic
            tool: pagerduty
            with:
              priority: "P2"
              incident_details:
                alert_id: "{{ .workflow.input.alert_id }}"
                service: "{{ .workflow.input.service }}"
                runbook: "{{ .tasks.prepare-runbook.output }}"

      escalate_only:
        type: signal
        signal:
          id: "critical-incident"
          payload:
            alert_id: "{{ .workflow.input.alert_id }}"
            service: "{{ .workflow.input.service }}"
            severity: "{{ .workflow.input.severity }}"
            assessment: "{{ .tasks.assess-incident.output }}"
            requires_immediate_attention: true

    depends_on: [assess-incident]

  - id: track-incident
    type: basic
    tool: incident-tracker
    with:
      alert_id: "{{ .workflow.input.alert_id }}"
      service: "{{ .workflow.input.service }}"
      severity: "{{ .workflow.input.severity }}"
      assessment: "{{ .tasks.assess-incident.output }}"
      response_type: "{{ .tasks.automated-response.selected_route }}"
      response_result: "{{ .tasks.automated-response.output }}"
      timestamp: "{{ now }}"
    depends_on: [automated-response]

  - id: monitor-stability
    type: wait
    wait_for: "service-stable"
    timeout: "10m"
    on_timeout: "handle-stability-timeout"

    processor:
      type: basic
      agent: stability-analyzer
      instructions: "Analyze service stability and confirm incident resolution"
      with:
        stability_data: "{{ .signal.payload }}"
        incident_id: "{{ .workflow.input.alert_id }}"

    depends_on: [track-incident]

  - id: handle-stability-timeout
    type: signal
    signal:
      id: "incident-not-resolved"
      payload:
        alert_id: "{{ .workflow.input.alert_id }}"
        service: "{{ .workflow.input.service }}"
        escalate: true
```

<Callout type="warning">
This example showcases advanced patterns including wait tasks for monitoring resolution, conditional [router tasks](/docs/core/tasks/router-tasks) for response strategies, and comprehensive error handling with escalation paths. The incident response pattern demonstrates event-driven architecture principles at scale.
</Callout>

</Tab>
</Tabs>

## Best Practices

<FeatureCardList cols={2} size="default">
  <FeatureCard
    title="Schema Validation"
    description="Use JSON Schema validation to ensure signal quality and prevent invalid workflows"
    icon="Filter"
  />
  <FeatureCard
    title="Resource Management"
    description="Configure concurrency limits and timeouts to maintain system stability under high load"
    icon="Gauge"
  />
  <FeatureCard
    title="Payload Efficiency"
    description="Minimize signal payload size while maintaining necessary context for processing"
    icon="Package"
  />
  <FeatureCard
    title="Monitoring & Metrics"
    description="Track trigger rates, execution times, and resource usage for optimization insights"
    icon="BarChart3"
  />
</FeatureCardList>

### Signal Design Guidelines

<List>
  <ListItem title="Naming Conventions" icon="Tag">
    **Use kebab-case with clear hierarchy**: `domain-entity-action` (e.g., `order-payment-completed`, `user-profile-updated`). See naming best practices for more details.
  </ListItem>
  <ListItem title="Payload Structure" icon="Package">
    **Define consistent schemas**: Use JSON Schema validation to ensure payload consistency across publishers and consumers
  </ListItem>
  <ListItem title="Version Management" icon="GitBranch">
    **Plan for evolution**: Include version info in signal names or payloads for backward compatibility during deployment cycles
  </ListItem>
  <ListItem title="Error Recovery" icon="Shield">
    **Design for failure**: Implement retry logic, dead letter queues, and compensation workflows using error handling patterns
  </ListItem>
</List>

## Next Steps

<ReferenceCardList>
  <ReferenceCard
    title="Signal System Overview"
    description="Master the fundamentals of Compozy's event-driven signal system and pub-sub architecture"
    href="/docs/core/signals/overview"
    icon="Radio"
  />
  <ReferenceCard
    title="Signal Tasks"
    description="Learn to send signals from workflows to trigger cascading event-driven processes"
    href="/docs/core/signals/signal-tasks"
    icon="Send"
  />
  <ReferenceCard
    title="Wait Tasks"
    description="Implement synchronization points where workflows pause for specific signals"
    href="/docs/core/tasks/wait-tasks"
    icon="Timer"
  />
  <ReferenceCard
    title="Event API"
    description="Integrate external systems with Compozy using the programmatic signal API"
    href="/docs/core/signals/event-api"
    icon="Code"
  />
  <ReferenceCard
    title="Router Tasks"
    description="Build conditional logic and dynamic routing within triggered workflows"
    href="/docs/core/tasks/router-tasks"
    icon="GitBranch"
  />
  <ReferenceCard
    title="Workflow Configuration"
    description="Configure complete workflows with triggers, tasks, and advanced orchestration"
    href="/docs/core/configuration/workflows"
    icon="Settings"
  />
  <ReferenceCard
    title="Getting Started Guide"
    description="New to Compozy? Start with core concepts and build your first event-driven workflow"
    href="/docs/core/getting-started/first-workflow"
    icon="Rocket"
  />
</ReferenceCardList>
