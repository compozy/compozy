---
title: Advanced Signal Patterns
description: Sophisticated signal patterns and architectural solutions for complex workflow coordination in Compozy
---

Advanced signal patterns enable sophisticated workflow coordination, complex event processing, and distributed system architectures. These patterns solve real-world challenges in enterprise workflow orchestration and event-driven systems.

## Saga Pattern

The Saga pattern manages distributed transactions across multiple services using compensating actions:

### Order Processing Saga

```yaml
id: order-processing-saga
version: "1.0"
description: "Distributed order processing with compensation"

tasks:
  - id: reserve-inventory
    type: basic
    tool:
      id: inventory-service
    with:
      items: "{{ .workflow.input.items }}"
      operation: "reserve"
    on_error: compensate-inventory
  
  - id: process-payment
    type: basic
    tool:
      id: payment-service
    with:
      amount: "{{ .workflow.input.total }}"
      payment_method: "{{ .workflow.input.payment_method }}"
    depends_on: [reserve-inventory]
    on_error: compensate-payment
  
  - id: ship-order
    type: basic
    tool:
      id: shipping-service
    with:
      order_id: "{{ .workflow.input.order_id }}"
      items: "{{ .workflow.input.items }}"
    depends_on: [process-payment]
    on_error: compensate-shipping
  
  - id: send-confirmation
    type: basic
    tool:
      id: notification-service
    with:
      customer_id: "{{ .workflow.input.customer_id }}"
      order_id: "{{ .workflow.input.order_id }}"
    depends_on: [ship-order]
  
  # Compensation tasks
  - id: compensate-inventory
    type: signal
    signal:
      id: "inventory-compensation"
      payload:
        order_id: "{{ .workflow.input.order_id }}"
        items: "{{ .workflow.input.items }}"
        operation: "release"
        reason: "order-failed"
  
  - id: compensate-payment
    type: composite
    tasks:
      - id: refund-payment
        type: signal
        signal:
          id: "payment-refund"
          payload:
            transaction_id: "{{ .tasks.process-payment.output.transaction_id }}"
            amount: "{{ .workflow.input.total }}"
      
      - id: compensate-inventory-after-payment
        type: signal
        signal:
          id: "inventory-compensation"
          payload:
            order_id: "{{ .workflow.input.order_id }}"
            items: "{{ .workflow.input.items }}"
            operation: "release"
  
  - id: compensate-shipping
    type: composite
    tasks:
      - id: cancel-shipment
        type: signal
        signal:
          id: "shipping-cancellation"
          payload:
            order_id: "{{ .workflow.input.order_id }}"
            tracking_id: "{{ .tasks.ship-order.output.tracking_id }}"
      
      - id: refund-payment-after-shipping
        type: signal
        signal:
          id: "payment-refund"
          payload:
            transaction_id: "{{ .tasks.process-payment.output.transaction_id }}"
            amount: "{{ .workflow.input.total }}"
      
      - id: compensate-inventory-after-shipping
        type: signal
        signal:
          id: "inventory-compensation"
          payload:
            order_id: "{{ .workflow.input.order_id }}"
            items: "{{ .workflow.input.items }}"
            operation: "release"
```

### Saga Orchestrator

```yaml
id: saga-orchestrator
version: "1.0"
description: "Central saga coordination service"

triggers:
  - type: signal
    name: "saga-step-completed"
  - type: signal
    name: "saga-step-failed"

tasks:
  - id: handle-saga-event
    type: router
    condition: '{{ .workflow.input.event_type }}'
    routes:
      saga-step-completed:
        - id: process-success
          type: basic
          agent:
            id: saga-coordinator
            instructions: "Process successful saga step and determine next action"
          with:
            saga_id: "{{ .workflow.input.saga_id }}"
            step_result: "{{ .workflow.input.step_result }}"
            current_step: "{{ .workflow.input.current_step }}"
      
      saga-step-failed:
        - id: process-failure
          type: basic
          agent:
            id: saga-coordinator
            instructions: "Process failed saga step and initiate compensation"
          with:
            saga_id: "{{ .workflow.input.saga_id }}"
            error: "{{ .workflow.input.error }}"
            failed_step: "{{ .workflow.input.failed_step }}"
  
  - id: execute-next-action
    type: router
    condition: '{{ .tasks.handle-saga-event.output.action }}'
    routes:
      continue:
        - id: trigger-next-step
          type: signal
          signal:
            id: "saga-step-trigger"
            payload:
              saga_id: "{{ .workflow.input.saga_id }}"
              step: "{{ .tasks.handle-saga-event.output.next_step }}"
      
      compensate:
        - id: trigger-compensation
          type: signal
          signal:
            id: "saga-compensation-trigger"
            payload:
              saga_id: "{{ .workflow.input.saga_id }}"
              failed_step: "{{ .workflow.input.failed_step }}"
              compensation_steps: "{{ .tasks.handle-saga-event.output.compensation_steps }}"
      
      complete:
        - id: mark-saga-complete
          type: signal
          signal:
            id: "saga-completed"
            payload:
              saga_id: "{{ .workflow.input.saga_id }}"
              result: "{{ .tasks.handle-saga-event.output.result }}"
    depends_on: [handle-saga-event]
```

## Event Sourcing Pattern

Implement event sourcing for auditability and state reconstruction:

### Event Store

```yaml
id: event-store-handler
version: "1.0"
description: "Event store for domain events"

triggers:
  - type: signal
    name: "domain-event"

tasks:
  - id: validate-event
    type: basic
    agent:
      id: event-validator
      instructions: "Validate domain event structure and integrity"
    with:
      event: "{{ .workflow.input.event }}"
      aggregate_id: "{{ .workflow.input.aggregate_id }}"
      event_type: "{{ .workflow.input.event_type }}"
  
  - id: store-event
    type: basic
    tool:
      id: event-database
    with:
      aggregate_id: "{{ .workflow.input.aggregate_id }}"
      event_type: "{{ .workflow.input.event_type }}"
      event_data: "{{ .workflow.input.event }}"
      sequence_number: "{{ .workflow.input.sequence_number }}"
      timestamp: "{{ now }}"
    depends_on: [validate-event]
  
  - id: update-projections
    type: parallel
    tasks:
      - id: update-read-model
        type: basic
        tool:
          id: read-model-updater
        with:
          aggregate_id: "{{ .workflow.input.aggregate_id }}"
          event: "{{ .workflow.input.event }}"
          event_type: "{{ .workflow.input.event_type }}"
      
      - id: update-analytics
        type: basic
        tool:
          id: analytics-updater
        with:
          event: "{{ .workflow.input.event }}"
          event_type: "{{ .workflow.input.event_type }}"
          timestamp: "{{ now }}"
      
      - id: update-search-index
        type: basic
        tool:
          id: search-indexer
        with:
          aggregate_id: "{{ .workflow.input.aggregate_id }}"
          searchable_data: "{{ .workflow.input.event.searchable_fields }}"
    depends_on: [store-event]
  
  - id: notify-subscribers
    type: collection
    items: "{{ .workflow.input.subscribers }}"
    task:
      id: "notify-subscriber-{{ .index }}"
      type: signal
      signal:
        id: "{{ .item.signal_name }}"
        payload:
          aggregate_id: "{{ .workflow.input.aggregate_id }}"
          event_type: "{{ .workflow.input.event_type }}"
          event: "{{ .workflow.input.event }}"
          subscriber: "{{ .item.id }}"
    depends_on: [update-projections]
```

### Aggregate Reconstruction

```yaml
id: aggregate-reconstructor
version: "1.0"
description: "Reconstruct aggregate state from events"

triggers:
  - type: signal
    name: "aggregate-state-requested"

tasks:
  - id: load-events
    type: basic
    tool:
      id: event-loader
    with:
      aggregate_id: "{{ .workflow.input.aggregate_id }}"
      from_version: "{{ .workflow.input.from_version | default(0) }}"
      to_version: "{{ .workflow.input.to_version | default(-1) }}"
  
  - id: reconstruct-state
    type: basic
    agent:
      id: aggregate-reconstructor
      instructions: "Reconstruct aggregate state by replaying events in order"
    with:
      aggregate_type: "{{ .workflow.input.aggregate_type }}"
      events: "{{ .tasks.load-events.output.events }}"
      initial_state: "{{ .workflow.input.initial_state }}"
    depends_on: [load-events]
  
  - id: validate-state
    type: basic
    agent:
      id: state-validator
      instructions: "Validate reconstructed state for consistency"
    with:
      aggregate_id: "{{ .workflow.input.aggregate_id }}"
      reconstructed_state: "{{ .tasks.reconstruct-state.output.state }}"
      expected_version: "{{ .tasks.load-events.output.latest_version }}"
    depends_on: [reconstruct-state]
  
  - id: return-state
    type: signal
    signal:
      id: "aggregate-state-reconstructed"
      payload:
        aggregate_id: "{{ .workflow.input.aggregate_id }}"
        state: "{{ .tasks.reconstruct-state.output.state }}"
        version: "{{ .tasks.load-events.output.latest_version }}"
        validation_result: "{{ .tasks.validate-state.output }}"
    depends_on: [validate-state]
```

## Circuit Breaker Pattern

Implement circuit breakers for resilient service communication:

### Circuit Breaker Implementation

```yaml
id: circuit-breaker-service
version: "1.0"
description: "Circuit breaker for external service calls"

triggers:
  - type: signal
    name: "service-call-request"

tasks:
  - id: check-circuit-state
    type: basic
    tool:
      id: circuit-breaker-checker
    with:
      service_name: "{{ .workflow.input.service_name }}"
      endpoint: "{{ .workflow.input.endpoint }}"
  
  - id: handle-circuit-state
    type: router
    condition: '{{ .tasks.check-circuit-state.output.state }}'
    routes:
      closed:
        - id: execute-service-call
          type: basic
          tool:
            id: service-caller
          with:
            service_name: "{{ .workflow.input.service_name }}"
            endpoint: "{{ .workflow.input.endpoint }}"
            request: "{{ .workflow.input.request }}"
          on_error: record-failure
          on_success: record-success
      
      open:
        - id: return-circuit-open-error
          type: signal
          signal:
            id: "service-call-failed"
            payload:
              error: "Circuit breaker is OPEN"
              service_name: "{{ .workflow.input.service_name }}"
              fallback_available: "{{ .workflow.input.fallback_available }}"
      
      half-open:
        - id: execute-test-call
          type: basic
          tool:
            id: service-caller
          with:
            service_name: "{{ .workflow.input.service_name }}"
            endpoint: "{{ .workflow.input.endpoint }}"
            request: "{{ .workflow.input.request }}"
            test_mode: true
          on_error: record-test-failure
          on_success: record-test-success
    depends_on: [check-circuit-state]
  
  - id: record-success
    type: parallel
    tasks:
      - id: update-circuit-metrics
        type: basic
        tool:
          id: circuit-breaker-updater
        with:
          service_name: "{{ .workflow.input.service_name }}"
          result: "success"
          response_time: "{{ .tasks.handle-circuit-state.output.response_time }}"
      
      - id: send-success-signal
        type: signal
        signal:
          id: "service-call-succeeded"
          payload:
            service_name: "{{ .workflow.input.service_name }}"
            response: "{{ .tasks.handle-circuit-state.output.response }}"
  
  - id: record-failure
    type: parallel
    tasks:
      - id: update-circuit-metrics-failure
        type: basic
        tool:
          id: circuit-breaker-updater
        with:
          service_name: "{{ .workflow.input.service_name }}"
          result: "failure"
          error: "{{ .tasks.handle-circuit-state.output.error }}"
      
      - id: send-failure-signal
        type: signal
        signal:
          id: "service-call-failed"
          payload:
            service_name: "{{ .workflow.input.service_name }}"
            error: "{{ .tasks.handle-circuit-state.output.error }}"
            fallback_available: "{{ .workflow.input.fallback_available }}"
  
  - id: record-test-success
    type: parallel
    tasks:
      - id: close-circuit
        type: basic
        tool:
          id: circuit-breaker-updater
        with:
          service_name: "{{ .workflow.input.service_name }}"
          action: "close"
      
      - id: send-test-success-signal
        type: signal
        signal:
          id: "service-call-succeeded"
          payload:
            service_name: "{{ .workflow.input.service_name }}"
            response: "{{ .tasks.handle-circuit-state.output.response }}"
            circuit_closed: true
  
  - id: record-test-failure
    type: parallel
    tasks:
      - id: open-circuit
        type: basic
        tool:
          id: circuit-breaker-updater
        with:
          service_name: "{{ .workflow.input.service_name }}"
          action: "open"
      
      - id: send-test-failure-signal
        type: signal
        signal:
          id: "service-call-failed"
          payload:
            service_name: "{{ .workflow.input.service_name }}"
            error: "{{ .tasks.handle-circuit-state.output.error }}"
            circuit_opened: true
```

## Bulkhead Pattern

Isolate resources to prevent cascading failures:

### Resource Pool Management

```yaml
id: resource-pool-manager
version: "1.0"
description: "Manage isolated resource pools"

triggers:
  - type: signal
    name: "resource-request"

tasks:
  - id: determine-resource-pool
    type: basic
    agent:
      id: resource-classifier
      instructions: "Classify request and determine appropriate resource pool"
    with:
      request_type: "{{ .workflow.input.request_type }}"
      priority: "{{ .workflow.input.priority }}"
      tenant_id: "{{ .workflow.input.tenant_id }}"
      resource_requirements: "{{ .workflow.input.resource_requirements }}"
  
  - id: check-pool-availability
    type: basic
    tool:
      id: resource-pool-checker
    with:
      pool_id: "{{ .tasks.determine-resource-pool.output.pool_id }}"
      required_resources: "{{ .workflow.input.resource_requirements }}"
    depends_on: [determine-resource-pool]
  
  - id: handle-resource-allocation
    type: router
    condition: '{{ .tasks.check-pool-availability.output.available }}'
    routes:
      true:
        - id: allocate-resources
          type: basic
          tool:
            id: resource-allocator
          with:
            pool_id: "{{ .tasks.determine-resource-pool.output.pool_id }}"
            resources: "{{ .workflow.input.resource_requirements }}"
            lease_duration: "{{ .workflow.input.lease_duration }}"
        
        - id: execute-work
          type: basic
          tool:
            id: work-executor
          with:
            work_spec: "{{ .workflow.input.work_spec }}"
            allocated_resources: "{{ .tasks.allocate-resources.output.resources }}"
          depends_on: [allocate-resources]
        
        - id: release-resources
          type: basic
          tool:
            id: resource-releaser
          with:
            pool_id: "{{ .tasks.determine-resource-pool.output.pool_id }}"
            resource_ids: "{{ .tasks.allocate-resources.output.resource_ids }}"
          depends_on: [execute-work]
        
        - id: send-success-signal
          type: signal
          signal:
            id: "resource-work-completed"
            payload:
              request_id: "{{ .workflow.input.request_id }}"
              result: "{{ .tasks.execute-work.output }}"
              pool_used: "{{ .tasks.determine-resource-pool.output.pool_id }}"
          depends_on: [release-resources]
      
      false:
        - id: handle-resource-unavailable
          type: router
          condition: '{{ .workflow.input.priority }}'
          routes:
            high:
              - id: queue-high-priority
                type: basic
                tool:
                  id: priority-queue
                with:
                  queue_type: "high_priority"
                  request: "{{ .workflow.input }}"
                  pool_id: "{{ .tasks.determine-resource-pool.output.pool_id }}"
              
              - id: wait-for-resources
                type: wait
                wait_for: "resources-available"
                timeout: 300s
                condition: 'signal.payload.pool_id == tasks.determine-resource-pool.output.pool_id'
                depends_on: [queue-high-priority]
            
            medium:
              - id: queue-medium-priority
                type: basic
                tool:
                  id: priority-queue
                with:
                  queue_type: "medium_priority"
                  request: "{{ .workflow.input }}"
                  pool_id: "{{ .tasks.determine-resource-pool.output.pool_id }}"
              
              - id: wait-for-resources-medium
                type: wait
                wait_for: "resources-available"
                timeout: 600s
                condition: 'signal.payload.pool_id == tasks.determine-resource-pool.output.pool_id'
                depends_on: [queue-medium-priority]
            
            low:
              - id: send-resource-unavailable
                type: signal
                signal:
                  id: "resource-request-rejected"
                  payload:
                    request_id: "{{ .workflow.input.request_id }}"
                    reason: "resources_unavailable"
                    pool_id: "{{ .tasks.determine-resource-pool.output.pool_id }}"
                    suggested_retry_after: "{{ .tasks.check-pool-availability.output.estimated_availability }}"
    depends_on: [check-pool-availability]
```

## Event Choreography

Implement event choreography for decoupled service coordination:

### Order Choreography

```yaml
id: order-choreography-participant
version: "1.0"
description: "Choreography participant for order processing"

triggers:
  - type: signal
    name: "order-created"
  - type: signal
    name: "payment-processed"
  - type: signal
    name: "inventory-reserved"
  - type: signal
    name: "shipping-scheduled"

tasks:
  - id: handle-order-event
    type: router
    condition: '{{ .workflow.input.event_type }}'
    routes:
      order-created:
        - id: validate-order
          type: basic
          tool:
            id: order-validator
          with:
            order: "{{ .workflow.input.order }}"
        
        - id: check-inventory
          type: basic
          tool:
            id: inventory-checker
          with:
            items: "{{ .workflow.input.order.items }}"
          depends_on: [validate-order]
        
        - id: reserve-inventory
          type: basic
          tool:
            id: inventory-reserver
          with:
            order_id: "{{ .workflow.input.order.id }}"
            items: "{{ .workflow.input.order.items }}"
          depends_on: [check-inventory]
        
        - id: emit-inventory-reserved
          type: signal
          signal:
            id: "inventory-reserved"
            payload:
              order_id: "{{ .workflow.input.order.id }}"
              items: "{{ .workflow.input.order.items }}"
              reservation_id: "{{ .tasks.reserve-inventory.output.reservation_id }}"
          depends_on: [reserve-inventory]
      
      payment-processed:
        - id: validate-payment
          type: basic
          tool:
            id: payment-validator
          with:
            payment: "{{ .workflow.input.payment }}"
            order_id: "{{ .workflow.input.order_id }}"
        
        - id: schedule-shipping
          type: basic
          tool:
            id: shipping-scheduler
          with:
            order_id: "{{ .workflow.input.order_id }}"
            payment_confirmation: "{{ .workflow.input.payment }}"
          depends_on: [validate-payment]
        
        - id: emit-shipping-scheduled
          type: signal
          signal:
            id: "shipping-scheduled"
            payload:
              order_id: "{{ .workflow.input.order_id }}"
              shipping_id: "{{ .tasks.schedule-shipping.output.shipping_id }}"
              estimated_delivery: "{{ .tasks.schedule-shipping.output.estimated_delivery }}"
          depends_on: [schedule-shipping]
      
      inventory-reserved:
        - id: process-payment
          type: basic
          tool:
            id: payment-processor
          with:
            order_id: "{{ .workflow.input.order_id }}"
            amount: "{{ .workflow.input.amount }}"
            payment_method: "{{ .workflow.input.payment_method }}"
        
        - id: emit-payment-processed
          type: signal
          signal:
            id: "payment-processed"
            payload:
              order_id: "{{ .workflow.input.order_id }}"
              transaction_id: "{{ .tasks.process-payment.output.transaction_id }}"
              amount: "{{ .workflow.input.amount }}"
          depends_on: [process-payment]
      
      shipping-scheduled:
        - id: finalize-order
          type: basic
          tool:
            id: order-finalizer
          with:
            order_id: "{{ .workflow.input.order_id }}"
            shipping_id: "{{ .workflow.input.shipping_id }}"
        
        - id: send-confirmation
          type: basic
          tool:
            id: notification-sender
          with:
            customer_id: "{{ .workflow.input.customer_id }}"
            order_id: "{{ .workflow.input.order_id }}"
            message_type: "order_confirmation"
          depends_on: [finalize-order]
        
        - id: emit-order-completed
          type: signal
          signal:
            id: "order-completed"
            payload:
              order_id: "{{ .workflow.input.order_id }}"
              completion_time: "{{ now }}"
              total_processing_time: "{{ .workflow.duration }}"
          depends_on: [send-confirmation]
```

## Stream Processing Pattern

Process continuous streams of events:

### Event Stream Processor

```yaml
id: event-stream-processor
version: "1.0"
description: "Process continuous event streams"

triggers:
  - type: signal
    name: "stream-event"

tasks:
  - id: classify-event
    type: basic
    agent:
      id: event-classifier
      instructions: "Classify incoming stream event and determine processing strategy"
    with:
      event: "{{ .workflow.input.event }}"
      stream_id: "{{ .workflow.input.stream_id }}"
      timestamp: "{{ .workflow.input.timestamp }}"
  
  - id: process-by-type
    type: router
    condition: '{{ .tasks.classify-event.output.event_type }}'
    routes:
      user-activity:
        - id: process-user-activity
          type: basic
          tool:
            id: user-activity-processor
          with:
            activity: "{{ .workflow.input.event }}"
            user_id: "{{ .workflow.input.event.user_id }}"
      
      system-metric:
        - id: process-system-metric
          type: basic
          tool:
            id: metric-processor
          with:
            metric: "{{ .workflow.input.event }}"
            system_id: "{{ .workflow.input.event.system_id }}"
      
      business-event:
        - id: process-business-event
          type: basic
          tool:
            id: business-event-processor
          with:
            event: "{{ .workflow.input.event }}"
            entity_id: "{{ .workflow.input.event.entity_id }}"
    depends_on: [classify-event]
  
  - id: aggregate-events
    type: basic
    tool:
      id: event-aggregator
    with:
      event: "{{ .workflow.input.event }}"
      processing_result: "{{ .tasks.process-by-type.output }}"
      stream_id: "{{ .workflow.input.stream_id }}"
      window_size: "{{ .env.AGGREGATION_WINDOW_SIZE }}"
    depends_on: [process-by-type]
  
  - id: check-alert-conditions
    type: basic
    agent:
      id: alert-checker
      instructions: "Check if processed events trigger any alert conditions"
    with:
      aggregated_data: "{{ .tasks.aggregate-events.output }}"
      event_type: "{{ .tasks.classify-event.output.event_type }}"
      thresholds: "{{ .env.ALERT_THRESHOLDS }}"
    depends_on: [aggregate-events]
  
  - id: emit-alerts
    type: collection
    items: "{{ .tasks.check-alert-conditions.output.triggered_alerts }}"
    task:
      id: "emit-alert-{{ .index }}"
      type: signal
      signal:
        id: "alert-triggered"
        payload:
          alert_type: "{{ .item.type }}"
          severity: "{{ .item.severity }}"
          message: "{{ .item.message }}"
          source_event: "{{ .workflow.input.event }}"
          aggregated_data: "{{ .tasks.aggregate-events.output }}"
    depends_on: [check-alert-conditions]
    condition: 'tasks.check-alert-conditions.output.triggered_alerts | length > 0'
  
  - id: update-stream-state
    type: basic
    tool:
      id: stream-state-updater
    with:
      stream_id: "{{ .workflow.input.stream_id }}"
      processed_event: "{{ .workflow.input.event }}"
      processing_result: "{{ .tasks.process-by-type.output }}"
      aggregation_result: "{{ .tasks.aggregate-events.output }}"
    depends_on: [aggregate-events]
```

## Best Practices for Advanced Patterns

### 1. Pattern Selection

Choose patterns based on specific requirements:

```yaml
# âœ… Appropriate pattern selection
use_cases:
  distributed_transactions: "saga-pattern"
  service_resilience: "circuit-breaker-pattern"
  resource_isolation: "bulkhead-pattern"
  event_processing: "stream-processing-pattern"
  audit_requirements: "event-sourcing-pattern"
```

### 2. Monitoring and Observability

Implement comprehensive monitoring:

```yaml
- id: pattern-monitoring
  type: basic
  agent:
    id: pattern-monitor
    instructions: "Monitor pattern health and performance"
  with:
    pattern_type: "{{ .workflow.pattern_type }}"
    metrics: "{{ .workflow.metrics }}"
    health_indicators: "{{ .workflow.health_indicators }}"
```

### 3. Error Handling

Implement robust error handling for complex patterns:

```yaml
- id: pattern-error-handler
  type: basic
  agent:
    id: error-analyzer
    instructions: "Analyze pattern-specific errors and determine recovery strategy"
  with:
    error: "{{ .task.error }}"
    pattern_type: "{{ .workflow.pattern_type }}"
    pattern_state: "{{ .workflow.pattern_state }}"
```

### 4. Testing Complex Patterns

Test patterns thoroughly:

```yaml
# Integration test for saga pattern
id: saga-pattern-test
version: "1.0"
description: "Test saga pattern implementation"

tasks:
  - id: test-happy-path
    type: basic
    tool:
      id: saga-tester
    with:
      test_type: "happy_path"
      scenario: "successful_order_processing"
  
  - id: test-compensation
    type: basic
    tool:
      id: saga-tester
    with:
      test_type: "compensation"
      scenario: "payment_failure"
  
  - id: test-timeout
    type: basic
    tool:
      id: saga-tester
    with:
      test_type: "timeout"
      scenario: "shipping_timeout"
```

<ReferenceCardList>
  <ReferenceCard
    title="Signal Overview"
    description="Review foundational concepts of Compozy's signal system"
    href="/docs/core/signals/signal-overview"
    icon="BookOpen"
  />
  <ReferenceCard
    title="Signal Tasks"
    description="Study how to send signals from within workflows"
    href="/docs/core/signals/signal-tasks"
    icon="Send"
  />
  <ReferenceCard
    title="Wait Tasks"
    description="Learn to receive signals with conditions and processors"
    href="/docs/core/signals/wait-tasks"
    icon="Timer"
  />
  <ReferenceCard
    title="Signal Triggers"
    description="Explore event-driven workflow initiation patterns"
    href="/docs/core/signals/signal-triggers"
    icon="Play"
  />
  <ReferenceCard
    title="Event API"
    description="Check programmatic access for external integrations"
    href="/docs/core/signals/event-api"
    icon="Code"
  />
</ReferenceCardList>
