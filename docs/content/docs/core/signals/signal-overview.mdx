---
title: Signal System Overview
description: Comprehensive guide to Compozy's signal system for inter-workflow communication and event-driven patterns
---

import {
  Signal,
  Radio,
  MessageSquare,
  Zap,
  Clock,
  Network,
  CheckCircle,
  AlertCircle,
  ArrowRight,
  Users,
  Database,
  Workflow,
  GitBranch,
  Share,
  Bell,
  Timer,
  RefreshCw,
  Code,
  Settings,
  Shield,
  TrendingUp,
  FileText,
  AlertTriangle,
  CheckCircle2,
  Info,
  BookOpen,
  ExternalLink,
  Link,
  Layers,
  Activity,
  Target,
  Repeat,
  Box,
  Play,
  Pause,
  Route,
  Gauge,
} from "lucide-react";
import { FeatureCard, FeatureCardList } from "@/components/ui/feature-card";
import { ReferenceCard, ReferenceCardList } from "@/components/ui/reference-card";
import { Callout } from "@/components/ui/callout";
import { Tabs, Tab } from "@/components/ui/tabs";
import { Steps, Step } from "@/components/ui/step";
import { Mermaid } from "@/components/ui/mermaid";

# Signal System Overview

Compozy's signal system provides **event-driven communication** between workflows and tasks, enabling sophisticated coordination patterns and decoupled architectures. Signals allow workflows to communicate asynchronously, coordinate complex processes, and implement reactive patterns.

<Callout type="info" title="Key Insight">
Signals use **Redis** for high-performance message dispatch, ensuring reliable delivery and scalability across distributed workflow systems.
</Callout>

## Core Concepts

### What are Signals?

Signals are **lightweight messages** that can be sent between workflows to trigger actions, share data, or coordinate execution. They provide a publish-subscribe mechanism that enables:

<FeatureCardList cols={2} size="sm">
  <FeatureCard
    title="Inter-workflow Communication"
    description="Different workflows can coordinate through signals"
    icon={Network}
  />
  <FeatureCard
    title="Event-driven Patterns"
    description="React to events and state changes across the system"
    icon={Zap}
  />
  <FeatureCard
    title="Asynchronous Coordination"
    description="Workflows can proceed independently while signaling completion"
    icon={Clock}
  />
  <FeatureCard
    title="Data Sharing"
    description="Pass structured data between workflows through signal payloads"
    icon={Share}
  />
</FeatureCardList>

### Signal Components

The signal system consists of three main components that work together:

<FeatureCardList cols={3} size="sm">
  <FeatureCard
    title="Signal Tasks"
    description="Send signals to the system with structured payloads"
    icon={Radio}
  />
  <FeatureCard
    title="Wait Tasks"
    description="Listen for specific signals with optional conditions"
    icon={Timer}
  />
  <FeatureCard
    title="Signal Dispatcher"
    description="Routes signals to waiting tasks via Redis backend"
    icon={Activity}
  />
</FeatureCardList>

## How Signals Work

<Mermaid chart={`graph TD
    A[Workflow A] --> B[Signal Task]
    B --> C[Signal Dispatcher<br/>Redis Backend]
    C --> D[Wait Task]
    D --> E[Workflow B]
    
    B -.-> F[Signal Payload<br/>JSON Data]
    F -.-> D
    
    style B fill:#e1f5fe
    style D fill:#f3e5f5
    style C fill:#fff3e0`} />

### Signal Flow

<Steps numbered size="sm">
  <Step title="Emission" description="A signal task sends a signal with an ID and optional payload" icon={Play}>
    
The signal task uses `type: signal` with a `signal.id` and optional `signal.payload` structure.

  </Step>
  
  <Step title="Dispatch" description="The signal dispatcher routes the signal to waiting tasks" icon={Activity}>
    
Redis handles high-performance message routing and ensures reliable delivery to all matching wait tasks.

  </Step>
  
  <Step title="Reception" description="Wait tasks with matching signal IDs receive the signal" icon={Target}>
    
Wait tasks using `type: wait` and `wait_for` receive signals with matching IDs.

  </Step>
  
  <Step title="Processing" description="Optional processors can transform signal data" icon={Code}>
    
Optional processors can transform signal data using agents or tools before continuing workflow execution.

  </Step>
  
  <Step title="Continuation" description="Waiting workflows resume execution" icon={ArrowRight}>
    
Workflows resume with signal data available in the execution context.

  </Step>
</Steps>

## Basic Example

### Sending a Signal

```yaml
# Workflow A - Send completion signal
- id: notify-completion
  type: signal
  signal:
    id: "task-completed"
    payload:
      status: "success"
      result: "{{ .task.output.result }}"
      timestamp: "{{ now }}"
```

### Waiting for a Signal

```yaml
# Workflow B - Wait for completion
- id: wait-for-completion
  type: wait
  wait_for: "task-completed"
  timeout: 300s
  
  # Optional: Process signal data
  processor:
    type: basic
    agent:
      id: result-processor
      instructions: "Analyze the completion data"
    with:
      signal_data: "{{ .signal.payload }}"
```

## Signal Types and Patterns

Different signal patterns serve various coordination needs:

<Tabs items={["Notification", "Data Transfer", "Status Change"]}>
<Tab>

### Notification Signals

Simple event notifications without complex data:

```yaml
signal:
  id: "user-registered"
  payload:
    user_id: "{{ .workflow.input.user_id }}"
    timestamp: "{{ now }}"
```

<FeatureCardList cols={2} size="sm">
  <FeatureCard
    title="Lightweight"
    description="Minimal data, maximum efficiency"
    icon={Bell}
  />
  <FeatureCard
    title="Event-driven"
    description="Trigger reactions to system events"
    icon={Zap}
  />
</FeatureCardList>

</Tab>

<Tab>

### Data Transfer Signals

Signals carrying rich data payloads:

```yaml
signal:
  id: "order-processed"
  payload:
    order_id: "{{ .workflow.input.order_id }}"
    items: "{{ .task.output.processed_items }}"
    total_amount: "{{ .task.output.total }}"
    customer_data: "{{ .workflow.input.customer }}"
```

<FeatureCardList cols={2} size="sm">
  <FeatureCard
    title="Rich Payloads"
    description="Transfer complex structured data"
    icon={Database}
  />
  <FeatureCard
    title="Cross-Workflow"
    description="Share data between workflows"
    icon={Share}
  />
</FeatureCardList>

</Tab>

<Tab>

### Status Change Signals

Workflow state transition notifications:

```yaml
signal:
  id: "workflow-status-change"
  payload:
    workflow_id: "{{ .workflow.id }}"
    previous_status: "{{ .workflow.previous_status }}"
    current_status: "{{ .workflow.status }}"
    reason: "{{ .task.output.reason }}"
```

<FeatureCardList cols={2} size="sm">
  <FeatureCard
    title="State Tracking"
    description="Monitor workflow state changes"
    icon={Activity}
  />
  <FeatureCard
    title="Audit Trail"
    description="Maintain change history"
    icon={FileText}
  />
</FeatureCardList>

</Tab>
</Tabs>

## Advanced Signal Features

<FeatureCardList cols={3} size="sm">
  <FeatureCard
    title="Conditional Processing"
    description="Filter signals with custom conditions"
    icon={Route}
  />
  <FeatureCard
    title="Signal Timeouts"
    description="Handle scenarios where signals may not arrive"
    icon={Timer}
  />
  <FeatureCard
    title="Multi-Signal Coordination"
    description="Coordinate multiple signals for complex workflows"
    icon={GitBranch}
  />
</FeatureCardList>

<Tabs items={["Conditional Processing", "Signal Timeouts", "Multi-Signal Coordination"]}>
<Tab>

### Conditional Signal Processing

Wait tasks can include conditions to filter signals:

```yaml
- id: conditional-wait
  type: wait
  wait_for: "order-update"
  condition: 'signal.payload.priority == "high"'
  processor:
    type: basic
    with:
      priority_order: "{{ .signal.payload }}"
```

<Callout type="info">
Use JavaScript expressions in conditions to filter signals based on payload content, enabling selective processing.
</Callout>

</Tab>

<Tab>

### Signal Timeouts

Handle scenarios where signals may not arrive:

```yaml
- id: wait-with-timeout
  type: wait
  wait_for: "approval-signal"
  timeout: 60s
  on_timeout: handle-timeout-case
  
  processor:
    type: basic
    with:
      approval_data: "{{ .signal.payload }}"
```

<Callout type="warning">
Always implement timeout handling for external signals to prevent workflows from hanging indefinitely.
</Callout>

</Tab>

<Tab>

### Multi-Signal Coordination

Coordinate multiple signals for complex workflows:

```yaml
# Wait for multiple conditions
- id: wait-all-approvals
  type: composite
  tasks:
    - id: wait-manager-approval
      type: wait
      wait_for: "manager-approved"
    
    - id: wait-legal-approval
      type: wait
      wait_for: "legal-approved"
```

<Callout type="success">
Use composite tasks to coordinate multiple signals, ensuring all required approvals are received before proceeding.
</Callout>

</Tab>
</Tabs>

## Signal Best Practices

<FeatureCardList cols={3} size="sm">
  <FeatureCard
    title="Naming Conventions"
    description="Use descriptive, consistent signal names"
    icon={FileText}
  />
  <FeatureCard
    title="Payload Structure"
    description="Include essential context in signal payloads"
    icon={Database}
  />
  <FeatureCard
    title="Error Handling"
    description="Plan for signal failures and timeouts"
    icon={Shield}
  />
</FeatureCardList>

<Tabs items={["Naming Conventions", "Payload Structure", "Error Handling"]}>
<Tab>

### Naming Conventions

Use descriptive, consistent signal names:

```yaml
# ✅ Good
signal:
  id: "payment-completed"
  id: "user-profile-updated"
  id: "document-processed"

# ❌ Avoid
signal:
  id: "done"
  id: "finished"
  id: "signal1"
```

<Callout type="info" title="Best Practice">
Use **action-object** naming pattern: `payment-completed`, `user-registered`, `document-processed`.
</Callout>

</Tab>

<Tab>

### Payload Structure

Include essential context in signal payloads:

```yaml
# ✅ Comprehensive payload
signal:
  id: "order-shipped"
  payload:
    order_id: "{{ .order.id }}"
    tracking_number: "{{ .shipping.tracking }}"
    estimated_delivery: "{{ .shipping.eta }}"
    customer_email: "{{ .customer.email }}"
    items_count: "{{ .order.items | length }}"
```

<Callout type="success" title="Payload Guidelines">
Always include enough context for receivers to process the signal without additional lookups.
</Callout>

</Tab>

<Tab>

### Error Handling

Plan for signal failures and timeouts:

```yaml
- id: robust-wait
  type: wait
  wait_for: "external-service-response"
  timeout: 30s
  
  on_timeout: fallback-task
  on_error: error-handler
  
  processor:
    type: basic
    with:
      response: "{{ .signal.payload }}"
```

<Callout type="warning" title="Resilience">
Always implement timeout and error handling for external signals to maintain workflow reliability.
</Callout>

</Tab>
</Tabs>

## Use Cases

<FeatureCardList cols={3} size="sm">
  <FeatureCard
    title="Approval Workflows"
    description="Human approval processes and business logic"
    icon={CheckCircle}
  />
  <FeatureCard
    title="Service Coordination"
    description="Coordinate distributed services and microservices"
    icon={Network}
  />
  <FeatureCard
    title="Event-Driven Pipelines"
    description="Data processing and event-driven architectures"
    icon={Workflow}
  />
</FeatureCardList>

<Tabs items={["Approval Workflows", "Service Coordination", "Event-Driven Pipelines"]}>
<Tab>

### Human Approval Processes

```yaml
# Human approval process
- id: request-approval
  type: signal
  signal:
    id: "approval-requested"
    payload:
      request_type: "budget-increase"
      amount: "{{ .workflow.input.amount }}"
      requestor: "{{ .workflow.input.user }}"

# Later in another workflow
- id: wait-approval
  type: wait
  wait_for: "approval-requested"
  processor:
    type: basic
    agent:
      id: approval-handler
      instructions: "Process approval request"
```

<Callout type="info" title="Use Case">
Perfect for business processes requiring human intervention: budget approvals, content moderation, manual reviews.
</Callout>

</Tab>

<Tab>

### Service Coordination

```yaml
# Service A completion
- id: service-a-complete
  type: signal
  signal:
    id: "service-a-done"
    payload:
      result: "{{ .task.output }}"

# Service B waiting for A
- id: service-b-start
  type: wait
  wait_for: "service-a-done"
  processor:
    type: basic
    with:
      service_a_result: "{{ .signal.payload.result }}"
```

<Callout type="success" title="Microservices">
Enable loose coupling between services while maintaining coordination and data flow.
</Callout>

</Tab>

<Tab>

### Event-Driven Pipelines

```yaml
# Data pipeline trigger
- id: data-ready
  type: signal
  signal:
    id: "new-data-available"
    payload:
      dataset_id: "{{ .workflow.input.dataset }}"
      record_count: "{{ .task.output.count }}"

# Processing pipeline
- id: process-data
  type: wait
  wait_for: "new-data-available"
  condition: 'signal.payload.record_count > 100'
  processor:
    type: basic
    tool:
      id: data-processor
    with:
      dataset: "{{ .signal.payload.dataset_id }}"
```

<Callout type="info" title="Event-Driven Architecture">
Build reactive systems that respond to data changes and system events automatically.
</Callout>

</Tab>
</Tabs>

## Next Steps

<ReferenceCardList>
  <ReferenceCard
    title="Signal Tasks"
    description="Learn to send signals with structured payloads and trigger coordination"
    href="/docs/core/signals/signal-tasks"
    icon={Radio}
  />
  <ReferenceCard
    title="Wait Tasks"
    description="Explore receiving signals with conditions, timeouts, and processors"
    href="/docs/core/signals/wait-tasks"
    icon={Timer}
  />
  <ReferenceCard
    title="Signal Triggers"
    description="Understand workflow initiation and signal-based automation"
    href="/docs/core/signals/signal-triggers"
    icon={Play}
  />
  <ReferenceCard
    title="Advanced Patterns"
    description="Review complex scenarios and signal coordination strategies"
    href="/docs/core/signals/advanced-patterns"
    icon={GitBranch}
  />
  <ReferenceCard
    title="Event API"
    description="REST API for programmatic signal management and monitoring"
    href="/docs/core/signals/event-api"
    icon={Code}
  />
</ReferenceCardList>

### Related Documentation

<ReferenceCardList>
  <ReferenceCard
    title="Task Types"
    description="Understand all task types including signal and wait tasks"
    href="/docs/core/tasks/basic-tasks"
    icon={Box}
  />
  <ReferenceCard
    title="Workflow Orchestration"
    description="Learn workflow coordination patterns and best practices"
    href="/docs/core/workflows/orchestration"
    icon={Workflow}
  />
  <ReferenceCard
    title="Redis Configuration"
    description="Configure Redis backend for signal dispatch and persistence"
    href="/docs/core/configuration/redis"
    icon={Database}
  />
</ReferenceCardList>
