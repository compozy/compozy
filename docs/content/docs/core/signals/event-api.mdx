---
title: Event API
description: The Event API provides programmatic access to Compozy's signal system, enabling external applications, services, and integrations to participate in event-driven workflows. This RESTful API is essential for building complex integrations, webhook handlers, and distributed system coordination with Compozy workflows.
---

## API Implementation Status

Compozy's signal system is **production-ready** and fully operational, providing robust workflow-to-workflow communication. The Event API offers multiple endpoints for different integration patterns, from direct workflow signaling to event-driven triggers.

<FeatureCardList cols={2}>
  <FeatureCard
    title="Signal to Workflow Execution"
    description="Send signals to running workflows via POST /api/v0/executions/workflows/:exec_id/signals"
    icon="Send"
  />
  <FeatureCard
    title="Event Endpoint (Experimental)"
    description="Trigger workflows with events via POST /api/v0/events"
    icon="Zap"
  />
</FeatureCardList>

## Architecture

Compozy's Event API integrates seamlessly with the [signal system architecture](/docs/core/signals/overview) through multiple coordination patterns:

<FeatureCardList cols={3} size="sm">
  <FeatureCard
    title="Internal Signaling"
    description="Workflow-to-workflow communication via signal tasks"
    icon="ArrowRightLeft"
  />
  <FeatureCard
    title="External Integration"
    description="API-driven signals from external systems and services"
    icon="Globe"
  />
  <FeatureCard
    title="Hybrid Coordination"
    description="Mixed internal/external signal patterns for complex scenarios"
    icon="Network"
  />
</FeatureCardList>

<Steps>
  <Step title="Signal Publication" icon="Send">
    [Signal tasks](/docs/core/signals/signal-tasks) and Event API endpoints dispatch structured signals
  </Step>
  <Step title="Signal Reception" icon="Inbox">
    [Wait tasks](/docs/core/tasks/wait-tasks) and [signal triggers](/docs/core/signals/signal-triggers) receive and process signals
  </Step>
  <Step title="Workflow Orchestration" icon="Workflow">
    Signals coordinate workflow execution, trigger new workflows, and enable complex patterns
  </Step>
</Steps>

## Endpoints

### Signal to Workflow Execution

Send signals to running workflow executions:

```http
POST /api/v0/executions/workflows/{exec_id}/signals
Content-Type: application/json
Authorization: Bearer YOUR_API_KEY

{
  "signal_name": "user-approved",
  "payload": {
    "user_id": "123",
    "approval_status": "approved",
    "approved_by": "manager@company.com"
  }
}
```

<Callout type="info">
This endpoint allows external systems to send signals to specific workflow executions. The workflow must have [wait tasks](/docs/core/tasks/wait-tasks) configured to receive these signals.
</Callout>

### Event Endpoint

Trigger workflows using events:

```http
POST /api/v0/events
Content-Type: application/json

{
  "name": "workflow.trigger",
  "payload": {
    "user_id": "123",
    "request_type": "approval"
  }
}
```

## Authentication

When [authentication is enabled](/docs/core/mcp/security-authentication), all API requests require proper credentials:

<Tabs items={["API Key", "JWT Token"]}>
  <Tab>
    ```bash
    # Using API key authentication
    curl -X POST http://localhost:8080/api/v0/executions/workflows/{exec_id}/signals \
      -H "Authorization: Bearer YOUR_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "signal_name": "approval-decision",
        "payload": {"status": "approved"}
      }'
    ```
  </Tab>
  <Tab>
    ```bash
    # Using JWT authentication
    curl -X POST http://localhost:8080/api/v0/executions/workflows/{exec_id}/signals \
      -H "Authorization: Bearer YOUR_JWT_TOKEN" \
      -H "Content-Type: application/json" \
      -d '{
        "signal_name": "approval-decision",
        "payload": {"status": "approved"}
      }'
    ```
  </Tab>
</Tabs>

## Integration Examples

### External Approval System

Integrate Compozy with your existing approval systems:

<Tabs items={["Node.js", "Python", "Go"]}>
  <Tab>
    ```javascript
    const axios = require('axios');

    class ApprovalIntegration {
      constructor(compozyUrl, apiKey) {
        this.client = axios.create({
          baseURL: compozyUrl,
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
          }
        });
      }

      async sendApprovalDecision(workflowExecId, decision) {
        try {
          const response = await this.client.post(
            `/api/v0/executions/workflows/${workflowExecId}/signals`,
            {
              signal_name: 'approval-decision',
              payload: {
                decision: decision,
                approved_by: 'external-system',
                timestamp: new Date().toISOString()
              }
            }
          );
          return response.data;
        } catch (error) {
          console.error('Failed to send approval signal:', error);
          throw error;
        }
      }
    }

    // Usage
    const approval = new ApprovalIntegration('http://localhost:8080', 'your-api-key');
    await approval.sendApprovalDecision('exec_123', 'approved');
    ```
  </Tab>
  <Tab>
    ```python
    import requests
    from datetime import datetime

    class ApprovalIntegration:
        def __init__(self, compozy_url, api_key):
            self.base_url = compozy_url
            self.headers = {
                'Authorization': f'Bearer {api_key}',
                'Content-Type': 'application/json'
            }

        def send_approval_decision(self, workflow_exec_id, decision):
            """Send approval decision to a waiting workflow"""
            url = f"{self.base_url}/api/v0/executions/workflows/{workflow_exec_id}/signals"

            payload = {
                'signal_name': 'approval-decision',
                'payload': {
                    'decision': decision,
                    'approved_by': 'external-system',
                    'timestamp': datetime.now().isoformat()
                }
            }

            response = requests.post(url, json=payload, headers=self.headers)
            response.raise_for_status()
            return response.json()

    # Usage
    approval = ApprovalIntegration('http://localhost:8080', 'your-api-key')
    approval.send_approval_decision('exec_123', 'approved')
    ```
  </Tab>
  <Tab>
    ```go
    package main

    import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
        "time"
    )

    type ApprovalIntegration struct {
        BaseURL string
        APIKey  string
    }

    type SignalPayload struct {
        SignalName string                 `json:"signal_name"`
        Payload  map[string]interface{} `json:"payload"`
    }

    func (a *ApprovalIntegration) SendApprovalDecision(execID, decision string) error {
        url := fmt.Sprintf("%s/api/v0/executions/workflows/%s/signals", a.BaseURL, execID)

        signal := SignalPayload{
            SignalName: "approval-decision",
            Payload: map[string]interface{}{
                "decision":    decision,
                "approved_by": "external-system",
                "timestamp":   time.Now().Format(time.RFC3339),
            },
        }

        body, _ := json.Marshal(signal)
        req, _ := http.NewRequest("POST", url, bytes.NewBuffer(body))
        req.Header.Set("Authorization", "Bearer "+a.APIKey)
        req.Header.Set("Content-Type", "application/json")

        client := &http.Client{}
        resp, err := client.Do(req)
        if err != nil {
            return err
        }
        defer resp.Body.Close()

        return nil
    }
    ```
  </Tab>
</Tabs>

### Payment Gateway Integration

Handle payment webhooks and notify workflows:

<Tabs items={["Express.js Webhook", "FastAPI Webhook"]}>
  <Tab>
    ```javascript
    // Express.js webhook handler for payment gateway
    const express = require('express');
    const app = express();
    app.use(express.json());

    app.post('/webhooks/payment', async (req, res) => {
      const { event_type, transaction_id, workflow_exec_id, amount, status } = req.body;

      try {
        // Send payment status to waiting workflow
        if (workflow_exec_id) {
          await axios.post(
            `http://localhost:8080/api/v0/executions/workflows/${workflow_exec_id}/signals`,
            {
              signal_name: 'payment-status',
              payload: {
                transaction_id,
                status,
                amount,
                event_type,
                processed_at: new Date().toISOString()
              }
            },
            {
              headers: {
                'Authorization': 'Bearer YOUR_API_KEY',
                'Content-Type': 'application/json'
              }
            }
          );
        }

        res.json({ success: true });
      } catch (error) {
        console.error('Failed to process payment webhook:', error);
        res.status(500).json({ error: 'Processing failed' });
      }
    });
    ```
  </Tab>
  <Tab>
    ```python
    from fastapi import FastAPI, HTTPException
    from pydantic import BaseModel
    import httpx
    from datetime import datetime

    app = FastAPI()

    class PaymentWebhook(BaseModel):
        event_type: str
        transaction_id: str
        workflow_exec_id: str
        amount: float
        status: str

    @app.post("/webhooks/payment")
    async def handle_payment_webhook(webhook: PaymentWebhook):
        """Process payment gateway webhooks and notify workflows"""

        if webhook.workflow_exec_id:
            async with httpx.AsyncClient() as client:
                try:
                    response = await client.post(
                        f"http://localhost:8080/api/v0/executions/workflows/{webhook.workflow_exec_id}/signals",
                        json={
                            "signal_name": "payment-status",
                            "payload": {
                                "transaction_id": webhook.transaction_id,
                                "status": webhook.status,
                                "amount": webhook.amount,
                                "event_type": webhook.event_type,
                                "processed_at": datetime.now().isoformat()
                            }
                        },
                        headers={
                            "Authorization": "Bearer YOUR_API_KEY",
                            "Content-Type": "application/json"
                        }
                    )
                    response.raise_for_status()
                except httpx.HTTPError as e:
                    raise HTTPException(status_code=500, detail=str(e))

        return {"success": True}
    ```
  </Tab>
</Tabs>

## Working with Workflow YAML

When building workflows that integrate with external systems, use [signal tasks](/docs/core/signals/signal-tasks) and [wait tasks](/docs/core/tasks/wait-tasks):

```yaml
# Workflow that processes external approvals
workflows:
  - id: approval-processor
    triggers:
      - type: signal
        name: approval-request

    tasks:
      - id: wait-for-decision
        type: wait
        wait_for: approval-decision
        on_timeout: handle-timeout

      - id: process-approval
        type: basic
        agent: processor-agent
        prompt: |
          Process the approval decision:
          Decision: {{ .tasks.wait_for_decision.result.payload.decision }}
          Approved by: {{ .tasks.wait_for_decision.result.payload.approved_by }}
```

## Best Practices

<FeatureCardList cols={2}>
  <FeatureCard
    title="Use Consistent Signal Naming"
    description="Adopt a naming convention like `domain-action` (e.g., `user-approved`, `payment-completed`) for maintainable signal systems."
    icon="Tag"
  />
  <FeatureCard
    title="Structure Payloads Thoughtfully"
    description="Include essential data in signal payloads while keeping them lightweight. Use consistent field names across similar signals."
    icon="Package"
  />
  <FeatureCard
    title="Implement Retry Logic"
    description="Add retry mechanisms with exponential backoff for transient failures, especially for critical signals."
    icon="RefreshCw"
  />
  <FeatureCard
    title="Monitor Signal Activity"
    description="Track signal delivery and processing to ensure reliable workflow execution."
    icon="Activity"
  />
</FeatureCardList>

## Next Steps

<ReferenceCardList>
  <ReferenceCard
    title="Signal System Overview"
    description="Understand the fundamental concepts of Compozy's signal system"
    href="/docs/core/signals/overview"
    icon="BookOpen"
  />
  <ReferenceCard
    title="Signal Tasks"
    description="Learn how to send signals from within workflows using signal tasks"
    href="/docs/core/signals/signal-tasks"
    icon="Send"
  />
  <ReferenceCard
    title="Wait Tasks"
    description="Explore how tasks can wait for signals within workflow execution"
    href="/docs/core/tasks/wait-tasks"
    icon="Timer"
  />
  <ReferenceCard
    title="Signal Triggers"
    description="Understand how to trigger workflows automatically with signal events"
    href="/docs/core/signals/signal-triggers"
    icon="Zap"
  />
  <ReferenceCard
    title="Workflow API"
    description="Learn about workflow execution and management APIs"
    href="/docs/api/workflows"
    icon="Play"
  />
  <ReferenceCard
    title="API Reference"
    description="Complete API documentation for all Compozy endpoints"
    href="/docs/api/overview"
    icon="FileJson"
  />
  <ReferenceCard
    title="Authentication Guide"
    description="Comprehensive guide to API authentication and security"
    href="/docs/core/mcp/security-authentication"
    icon="Lock"
  />
  <ReferenceCard
    title="Agent Tools"
    description="Understand how agents can use tools for external integrations"
    href="/docs/core/agents/tools"
    icon="Wrench"
  />
  <ReferenceCard
    title="Tool Overview"
    description="Learn about Compozy's extensible tool system"
    href="/docs/core/tools/overview"
    icon="Package"
  />
</ReferenceCardList>
