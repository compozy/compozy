---
title: "Integration Patterns"
description: "Common patterns and best practices for integrating MCP servers with agents, workflows, and external systems"
---

MCP (Model Context Protocol) integration patterns provide proven approaches for connecting external tools and services with Compozy agents and workflows. This guide covers common patterns, best practices, and implementation strategies for building robust MCP integrations using Compozy's simple HTTP-based architecture.

<Callout type="info" icon="Network">
  **Simple Architecture**: Compozy uses a straightforward HTTP-based MCP proxy architecture for reliable tool integration.
</Callout>

## Integration Architecture

The MCP integration architecture in Compozy follows a simple, effective pattern:

<Mermaid chart={`graph TB
    subgraph "Compozy Application"
        AGENT[AI Agent]
        WORKFLOW[Workflow Engine]
        TOOL[MCP Tool]
    end

    subgraph "MCP Proxy Service"
        PROXY[MCP Proxy<br/>:8081]
        REG[Registration Service]
    end

    subgraph "MCP Servers"
        SERVER1[Filesystem<br/>stdio]
        SERVER2[Database<br/>stdio]
        SERVER3[API Server<br/>SSE]
    end

    AGENT --> TOOL
    WORKFLOW --> TOOL
    TOOL --> PROXY
    PROXY --> REG
    REG --> SERVER1
    REG --> SERVER2  
    REG --> SERVER3

    classDef app fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef proxy fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef servers fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px

    class AGENT,WORKFLOW,TOOL app
    class PROXY,REG proxy
    class SERVER1,SERVER2,SERVER3 servers
`} />

**Key architectural principles:**
- **HTTP-based communication**: Simple REST API for MCP proxy communication
- **Registration service**: Manages MCP server lifecycle and discovery
- **Support for stdio and SSE transports**: Covers most MCP server implementations
- **Direct tool integration**: Agents and workflows use MCP tools through the proxy

## Integration Patterns Overview

<FeatureCardList cols={2} size="sm" className="mb-12">
  <FeatureCard
    title="Agent Integration"
    description="Connect AI agents directly to MCP servers for intelligent tool usage"
    icon="BrainCircuit"
  />
  <FeatureCard
    title="Workflow Integration"
    description="Use MCP servers within workflow task orchestration"
    icon="Workflow"
  />
  <FeatureCard
    title="Multi-Server Configuration"
    description="Configure multiple MCP servers for different capabilities"
    icon="Users"
  />
  <FeatureCard
    title="External Tool Integration"
    description="Connect external tools through MCP protocol adapters"
    icon="Link2"
  />
</FeatureCardList>

## Agent Integration Patterns

### Single MCP Server Integration

The simplest integration pattern connects one agent to one MCP server for focused functionality:

```yaml title="workflow-with-mcp.yaml"
resource: workflow
id: file-management-workflow
description: Workflow using MCP filesystem server

# MCP server configuration
mcps:
  - id: filesystem
    transport: stdio
    command: "mcp-server-filesystem"
    args: ["--root", "/workspace"]
    env:
      LOG_LEVEL: "info"

agents:
  - id: file_manager
    instructions: |
      You are a file management assistant with access to the file system.
      You can read, write, and organize files in the workspace directory.
      Always confirm destructive operations before executing them.

tasks:
  - id: list_workspace_files
    type: basic
    agent: file_manager
    prompt: "List all files in the workspace directory"

  - id: read_specific_file
    type: basic
    agent: file_manager
    prompt: "Read the contents of: {{ .workflow.input.filename }}"
    condition: "{{ .workflow.input.filename }}"

  - id: create_summary
    type: basic
    agent: file_manager
    prompt: |
      Create a summary of the workspace contents:
      Files found: {{ .tasks.list_workspace_files.output }}
      {{ if .tasks.read_specific_file.output }}
      Content of {{ .workflow.input.filename }}: {{ .tasks.read_specific_file.output }}
      {{ end }}
```

**This pattern demonstrates:**
- **Simple MCP registration**: Single filesystem server using stdio transport
- **Agent tool access**: Agent can use MCP tools transparently
- **Workflow integration**: MCP servers available throughout the workflow
- **Error handling**: Built-in error handling for MCP server failures

### Multiple MCP Servers Integration

For more complex scenarios, you can configure multiple MCP servers within a single workflow. Use the CLI to manage these workflows:

```yaml title="multi-server-workflow.yaml"
resource: workflow
id: multi-server-example
description: Workflow using multiple MCP servers

# Multiple MCP server configuration
mcps:
  - id: filesystem
    transport: stdio
    command: "mcp-server-filesystem"
    args: ["--root", "/workspace"]
    env:
      LOG_LEVEL: "info"
  
  - id: database
    transport: stdio
    command: "mcp-server-database"
    args: ["--connection", "postgresql://localhost/db"]
    env:
      QUERY_TIMEOUT: "30s"

agents:
  - id: data_processor
    instructions: |
      You can access both the filesystem and database.
      Use the filesystem for reading configuration files and the database for storing results.

tasks:
  - id: read_config
    type: basic
    agent: data_processor
    prompt: "Read the configuration file from /workspace/config.json"

  - id: process_data
    type: basic
    agent: data_processor
    prompt: |
      Process the data based on the configuration: {{ .tasks.read_config.output }}
      Store the results in the database.

  - id: verify_storage
    type: basic
    agent: data_processor
    prompt: "Verify that the data was stored correctly in the database"
```

**CLI Workflow Management:**
```bash
# List all workflows
compozy workflow list

# Get workflow details
compozy workflow get multi-server-example

# Execute the workflow
compozy workflow execute multi-server-example

# Execute with custom input
compozy workflow execute multi-server-example --input '{"config_path": "/custom/config.json"}'
```

**Multi-server benefits:**
- **Specialized capabilities**: Each server provides focused functionality
- **Automatic registration**: All servers are registered when workflow starts
- **Transparent access**: Agents can use tools from any registered server
- **Simple configuration**: No complex orchestration needed

## Workflow Integration Patterns

### Direct MCP Tool Usage

You can create custom tools that directly interface with MCP servers:

```typescript title="tools/mcp-proxy-tool.ts"
// MCP proxy tool implementation - matches actual client API
export interface MCPProxyInput {
  server: string;
  tool: string;
  arguments: Record<string, any>;
}

export interface MCPProxyOutput {
  result: any;
  error?: string;
}

export default async function mcpProxyTool(input: MCPProxyInput): Promise<MCPProxyOutput> {
  const { server, tool, arguments: args } = input;
  
  try {
    // Connect to MCP proxy service
    const proxyUrl = process.env.MCP_PROXY_URL || 'http://localhost:8081';
    const response = await fetch(`${proxyUrl}/admin/tools/call`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.MCP_PROXY_ADMIN_TOKEN}`
      },
      body: JSON.stringify({
        mcpName: server,
        toolName: tool,
        arguments: args
      })
    });

    if (!response.ok) {
      // Handle structured error response matching ProxyRequestError
      const errorBody = await response.text();
      throw new Error(`HTTP ${response.status}: ${errorBody}`);
    }

    const result = await response.json();
    
    // Check for tool execution errors in response
    if (result.error) {
      return {
        result: null,
        error: result.error
      };
    }
    
    return { result: result.result };
  } catch (error) {
    return {
      result: null,
      error: error.message
    };
  }
}

// Note: This implementation matches the actual client.go CallTool method
// and handles ProxyRequestError structured responses
```

**Usage in workflow:**
```yaml title="workflow-with-mcp-tool.yaml"
resource: workflow
id: direct-mcp-tool-usage
description: Using MCP tools directly in workflows

tools:
  - id: mcp_proxy
    $ref: "./tools/mcp-proxy-tool.ts"

tasks:
  - id: list_files
    type: basic
    $use: tool(local::tools.#(id=="mcp_proxy"))
    with:
      server: "filesystem"
      tool: "list_files"
      arguments:
        path: "/workspace"
```

This example shows how to create a custom tool that interfaces with the MCP proxy to call tools on registered MCP servers. The workflow uses this tool to perform file operations through the filesystem MCP server.

### Dynamic MCP Server Selection

You can configure conditional MCP server loading based on workflow context:

```yaml
resource: workflow
id: adaptive-mcp-workflow
description: Conditional MCP server selection based on input parameters

mcps:
  - id: local_filesystem
    transport: stdio
    command: npx
    args: ["-y", "@modelcontextprotocol/server-filesystem", "./"]
    condition: '{{ eq .workflow.input.environment "local" }}'

  - id: database_server
    transport: stdio
    command: python
    args: ["mcp_server_database.py", "--connection-string", "{{ .env.DATABASE_URL }}"]
    condition: '{{ eq .workflow.input.operation_type "database" }}'

agents:
  - id: adaptive_assistant
    instructions: |
      You are an assistant that uses different MCP servers based on the task context.
      The available MCP servers will vary based on the environment and operation type.

tasks:
  - id: adaptive_operation
    type: basic
    agent: adaptive_assistant
    prompt: |
      Task: {{ .workflow.input.task }}
      Environment: {{ .workflow.input.environment }}
      Operation Type: {{ .workflow.input.operation_type }}

      Use the appropriate MCP tools available for this context to complete the task.
```

**Key benefits of conditional MCP loading:**
- **Resource efficiency**: Only load MCP servers when needed
- **Environment-specific behavior**: Different servers for different environments
- **Operation-specific access**: Control which servers are available for specific operations
- **Simple configuration**: Use standard template conditions

## Workflow Integration Patterns

### CLI Development Workflow

The recommended development workflow uses the Compozy CLI for seamless integration:

```bash
# 1. Initialize project with MCP support
compozy init data-processing-project
cd data-processing-project

# 2. Start development server with hot reload
compozy dev --watch

# 3. In another terminal, start MCP proxy
compozy mcp-proxy --port 8081 --debug

# 4. Test your workflow
compozy workflow execute data-processing-workflow
```

### Basic MCP Tool Usage

For simple data processing workflows, refer to the **Single MCP Server Integration** pattern above with these key principles:

- Use focused agents with clear instructions for specific data operations
- Structure tasks in logical sequence (read → process → save)  
- Leverage template variables for dynamic file paths and formats
- Implement proper error handling for file operations

### Error Handling with Fallbacks

Simple error handling pattern for MCP operations:

```yaml
resource: workflow
id: resilient_mcp_workflow
description: Workflow with basic error handling

mcps:
  - id: filesystem
    transport: stdio
    command: npx
    args: ["-y", "@modelcontextprotocol/server-filesystem", "/workspace"]

agents:
  - id: resilient_agent
    instructions: |
      You are a resilient assistant that can handle errors gracefully.
      If one approach fails, try alternative approaches.

tasks:
  - id: primary_operation
    type: basic
    agent: resilient_agent
    prompt: |
      Try to read the data from: {{ .workflow.input.primary_source }}
      If that fails, try reading from: {{ .workflow.input.backup_source }}
      If both fail, create a default dataset and save it to backup_data.json

  - id: process_data
    type: basic
    agent: resilient_agent
    prompt: |
      Process the data from the previous task: {{ .tasks.primary_operation.output }}
      Generate a summary report.
```

## MCP Tool Implementation Patterns

### Generic MCP Proxy Tool

Simple tool for MCP server communication:

```typescript
// mcp_proxy_tool.ts
interface MCPProxyInput {
  mcp_server: string;
  tool_name: string;
  parameters: Record<string, any>;
}

interface MCPProxyOutput {
  success: boolean;
  result?: any;
  error?: string;
}

export default async function mcpProxyTool(input: MCPProxyInput): Promise<MCPProxyOutput> {
  const { mcp_server, tool_name, parameters } = input;

  try {
    // Connect to MCP proxy service
    const proxyUrl = process.env.MCP_PROXY_URL || 'http://localhost:8081';
    const response = await fetch(`${proxyUrl}/admin/tools/call`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.MCP_PROXY_ADMIN_TOKEN}`
      },
      body: JSON.stringify({
        mcpName: mcp_server,
        toolName: tool_name,
        arguments: parameters
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const result = await response.json();
    return { success: true, result };

  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
}
```

This tool provides a simple interface to call any tool on any registered MCP server through the proxy service. The implementation matches the actual MCP proxy API endpoints available in the codebase.

### Specialized MCP Tools

You can create domain-specific tools that simplify common operations:

```typescript
// filesystem_tool.ts
interface FilesystemInput {
  operation: 'read' | 'write' | 'list';
  path: string;
  content?: string;
}

export default async function filesystemTool(input: FilesystemInput): Promise<any> {
  const { operation, path, content } = input;

  switch (operation) {
    case 'read':
      return mcpProxyTool({
        mcp_server: 'filesystem',
        tool_name: 'read_file',
        parameters: { path }
      });
    case 'write':
      return mcpProxyTool({
        mcp_server: 'filesystem',
        tool_name: 'write_file',
        parameters: { path, content }
      });
    case 'list':
      return mcpProxyTool({
        mcp_server: 'filesystem',
        tool_name: 'list_directory',
        parameters: { path }
      });
    default:
      throw new Error(`Unsupported operation: ${operation}`);
  }
}
```

These specialized tools simplify common MCP operations by providing higher-level interfaces that map to the underlying MCP tool calls.

## External System Integration

### HTTP API Integration

Integrate external APIs using SSE transport:

```yaml
resource: workflow
id: api_integration_workflow
description: Workflow integrating external APIs via MCP

mcps:
  - id: web_api
    transport: sse
    url: "http://localhost:3001/mcp"
    env:
      API_BASE_URL: "{{ .env.API_BASE_URL }}"
      API_TOKEN: "{{ .env.API_TOKEN }}"

agents:
  - id: api_client
    instructions: |
      You are an API client that can make HTTP requests to external services.
      Use the available tools to fetch and send data to external APIs.

tasks:
  - id: fetch_external_data
    type: basic
    agent: api_client
    prompt: |
      Fetch user data for user ID: {{ .workflow.input.user_id }}
      Use the HTTP API tools to make the request.

  - id: process_and_send
    type: basic
    agent: api_client
    prompt: |
      Process the data from the previous task: {{ .tasks.fetch_external_data.output }}
      Send the processed data back to the API.
```

### Database Integration

Simple database integration with MCP:

```yaml
resource: workflow
id: database_workflow
description: Workflow using database MCP server

mcps:
  - id: database
    transport: stdio
    command: python
    args:
      - mcp_server_database.py
      - "--connection-string"
      - "{{ .env.DATABASE_URL }}"

agents:
  - id: db_client
    instructions: |
      You are a database client that can query and update database records.
      Use the database tools to perform operations.

tasks:
  - id: query_data
    type: basic
    agent: db_client
    prompt: |
      Query the database for records matching: {{ .workflow.input.query_criteria }}
      Return the results in a structured format.

  - id: update_records
    type: basic
    agent: db_client
    prompt: |
      Based on the query results: {{ .tasks.query_data.output }}
      Update the necessary records according to: {{ .workflow.input.update_criteria }}
```

### File System Integration

For file system operations, refer to the **Single MCP Server Integration** pattern above. Key considerations for filesystem workflows:

- **Configuration-driven processing**: Read config files to determine processing parameters
- **Multi-step file operations**: Structure tasks as read → process → save sequence
- **Dynamic path handling**: Use template variables for flexible file path management
- **Error resilience**: Handle file not found and permission errors gracefully

See the complete filesystem workflow example in the Single MCP Server Integration section.

## Best Practices

### Error Handling

Handle MCP integration errors gracefully:

```typescript
// Simple error handling in MCP tools
export default async function robustMCPTool(input: MCPProxyInput): Promise<MCPProxyOutput> {
  try {
    const result = await mcpProxyTool(input);
    
    if (!result.success) {
      // Log the error and provide fallback
      console.error(`MCP call failed: ${result.error}`);
      return {
        success: false,
        error: result.error,
        fallback: "Consider implementing fallback logic"
      };
    }
    
    return result;
  } catch (error) {
    console.error('MCP tool execution failed:', error);
    return {
      success: false,
      error: error.message
    };
  }
}
```

### Configuration Management

```yaml
# Environment-specific MCP configurations
mcps:
  - id: filesystem
    transport: stdio
    command: npx
    args:
      - -y
      - "@modelcontextprotocol/server-filesystem"
      - "{{ .env.WORKSPACE_PATH | default './workspace' }}"
    env:
      LOG_LEVEL: "{{ .env.MCP_LOG_LEVEL | default 'INFO' }}"

  - id: database
    transport: stdio
    command: python
    args:
      - mcp_server_database.py
      - "--connection-string"
      - "{{ .env.DATABASE_URL }}"
    env:
      POOL_SIZE: "{{ .env.DB_POOL_SIZE | default '10' }}"
      TIMEOUT: "{{ .env.DB_TIMEOUT | default '30' }}"
```

### Monitoring and Logging

Simple logging for MCP operations:

```typescript
// Basic MCP operation logging
class MCPLogger {
  static logOperation(operation: string, serverName: string, toolName: string, success: boolean, error?: string): void {
    const logEntry = {
      timestamp: new Date().toISOString(),
      operation,
      server_name: serverName,
      tool_name: toolName,
      success,
      error,
    };

    // Log to console (can be replaced with structured logging)
    console.log(JSON.stringify(logEntry));
  }
}

// Usage in MCP tools
export default async function loggedMCPTool(input: MCPProxyInput): Promise<MCPProxyOutput> {
  try {
    const result = await mcpProxyTool(input);
    
    MCPLogger.logOperation(
      'tool_call',
      input.mcp_server,
      input.tool_name,
      result.success,
      result.error
    );
    
    return result;
  } catch (error) {
    MCPLogger.logOperation(
      'tool_call',
      input.mcp_server,
      input.tool_name,
      false,
      error.message
    );
    
    throw error;
  }
}
```

## Integration Checklist

<List className="mb-12">
  <ListItem title="Project Setup" icon="Rocket">
    Use `compozy init` to create a new project with MCP support
  </ListItem>
  <ListItem title="Development Environment" icon="Code">
    Start development server with `compozy dev --watch` for hot reload
  </ListItem>
  <ListItem title="MCP Proxy Setup" icon="Settings">
    Start MCP proxy with `compozy mcp-proxy --debug` for development
  </ListItem>
  <ListItem title="Configuration Phase" icon="Settings">
    Configure MCP servers with proper command arguments and environment variables
  </ListItem>
  <ListItem title="Implementation Phase" icon="Code">
    Create agents with access to MCP tools and build workflows
  </ListItem>
  <ListItem title="Testing Phase" icon="CheckCircle">
    Test with `compozy workflow execute` and verify tool registration
  </ListItem>
  <ListItem title="Deployment Phase" icon="Cloud">
    Deploy with `compozy start` and proper logging configuration
  </ListItem>
  <ListItem title="Maintenance Phase" icon="RefreshCw">
    Monitor with CLI commands and update configurations as needed
  </ListItem>
</List>

This guide provides practical patterns for integrating MCP servers with Compozy agents and workflows using the simple HTTP-based proxy architecture.

## Integration Best Practices

<FeatureCardList cols={2} size="sm" className="mb-12">
  <FeatureCard
    title="Simple Configuration"
    description="Use clear MCP server commands with proper arguments and environment variables"
    icon="Settings"
  />
  <FeatureCard
    title="Error Handling"
    description="Handle MCP server failures gracefully with clear error messages"
    icon="Shield"
  />
  <FeatureCard
    title="Environment Management"
    description="Use environment variables for configuration and secrets"
    icon="Key"
  />
  <FeatureCard
    title="Transport Selection"
    description="Choose appropriate transport (stdio or SSE) based on MCP server capabilities"
    icon="Network"
  />
  <FeatureCard
    title="Tool Organization"
    description="Structure your MCP tools for easy discovery and maintenance"
    icon="FolderOpen"
  />
  <FeatureCard
    title="Testing Strategy"
    description="Test MCP integrations with realistic data and scenarios"
    icon="CheckCircle"
  />
</FeatureCardList>

## Common Integration Patterns

### Single-Purpose MCP Servers

Use focused MCP servers for specific functionality:

```yaml
# Filesystem-focused workflow
mcps:
  - id: filesystem
    transport: stdio
    command: npx
    args: ["-y", "@modelcontextprotocol/server-filesystem", "/workspace"]
    env:
      LOG_LEVEL: "info"

# Database-focused workflow  
mcps:
  - id: database
    transport: stdio
    command: python
    args: ["mcp_server_database.py", "--connection-string", "{{ .env.DATABASE_URL }}"]
    env:
      QUERY_TIMEOUT: "30s"
```

### Multi-Server Workflows

Combine multiple MCP servers for comprehensive functionality:

```yaml
# Complete data processing workflow
mcps:
  - id: filesystem
    transport: stdio
    command: npx
    args: ["-y", "@modelcontextprotocol/server-filesystem", "/data"]
    
  - id: database
    transport: stdio
    command: python
    args: ["mcp_server_database.py", "--connection-string", "{{ .env.DATABASE_URL }}"]
    
  - id: api_client
    transport: sse
    url: "http://localhost:3001/mcp"
    env:
      API_BASE_URL: "{{ .env.API_BASE_URL }}"
      API_TOKEN: "{{ .env.API_TOKEN }}"
```

## Next Steps

<ReferenceCardList>
  <ReferenceCard
    title="Storage Backends"
    description="Configure and manage storage backends for MCP data persistence"
    href="/docs/core/mcp/storage-backends"
    icon="Database"
  />
  <ReferenceCard
    title="Client Manager"
    description="Manage MCP client connections and lifecycle"
    href="/docs/core/mcp/client-manager"
    icon="Network"
  />
  <ReferenceCard
    title="Monitoring & Metrics"
    description="Monitor integration health and performance metrics"
    href="/docs/core/mcp/monitoring-metrics"
    icon="Monitor"
  />
  <ReferenceCard
    title="Production Deployment"
    description="Deploy MCP integrations in production environments"
    href="/docs/core/mcp/production-deployment"
    icon="Cloud"
  />
  <ReferenceCard
    title="Development & Debugging"
    description="Debug and troubleshoot MCP integration issues"
    href="/docs/core/mcp/development-debugging"
    icon="Code"
  />
  <ReferenceCard
    title="MCP Overview"
    description="Learn about MCP architecture and core concepts"
    href="/docs/core/mcp/mcp-overview"
    icon="BookOpen"
  />
</ReferenceCardList>
