---
title: "Production Deployment"
description: "Simple and practical deployment strategies for MCP proxy in production environments"
---

Deploy the MCP proxy in production environments with practical, straightforward deployment patterns that match the actual implementation.

## Overview

The MCP proxy is a simple HTTP server that provides access to MCP servers. Production deployment focuses on:
- **Basic reliability** with health checks
- **Security** with authentication and IP restrictions
- **Monitoring** through logs and health endpoints
- **Scalability** through simple load balancing

<Callout type="info">
**Simple by Design**: The MCP proxy is intentionally lightweight and simple to deploy. Complex orchestration is generally not needed.
</Callout>

## Basic Production Setup

### Single Instance Deployment

The simplest production deployment runs a single MCP proxy instance:

```bash
# Start MCP proxy for production
compozy mcp-proxy \
  --host 0.0.0.0 \
  --port 8081 \
  --global-auth-tokens "your-production-token" \
  --admin-tokens "admin-secret" \
  --admin-allow-ips "10.0.0.0/8,192.168.0.0/16"
```

### Environment Configuration

Configure using environment variables for production:

```bash
# Production environment
export MCP_PROXY_HOST=0.0.0.0
export MCP_PROXY_PORT=8081
export MCP_PROXY_BASE_URL=https://mcp.yourdomain.com

# Start with environment config
compozy mcp-proxy
```

## Docker Deployment

### Basic Docker Setup

```dockerfile
# Dockerfile
FROM compozy/compozy:latest

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8081/health || exit 1

# Expose port
EXPOSE 8081

# Run MCP proxy
CMD ["compozy", "mcp-proxy"]
```

### Docker Compose

```yaml
version: '3.8'
services:
  mcp-proxy:
    image: compozy/compozy:latest
    ports:
      - "8081:8081"
    environment:
      - MCP_PROXY_HOST=0.0.0.0
      - MCP_PROXY_PORT=8081
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8081/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped
    
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: redis-server --requirepass your-redis-password
    volumes:
      - redis-data:/data
    restart: unless-stopped

volumes:
  redis-data:
```

Start the services:

```bash
docker-compose up -d
```

## Kubernetes Deployment

### Basic Kubernetes Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mcp-proxy
  labels:
    app: mcp-proxy
spec:
  replicas: 2
  selector:
    matchLabels:
      app: mcp-proxy
  template:
    metadata:
      labels:
        app: mcp-proxy
    spec:
      containers:
      - name: mcp-proxy
        image: compozy/compozy:latest
        ports:
        - containerPort: 8081
        env:
        - name: MCP_PROXY_HOST
          value: "0.0.0.0"
        - name: MCP_PROXY_PORT
          value: "8081"
        livenessProbe:
          httpGet:
            path: /health
            port: 8081
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8081
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "256Mi"
            cpu: "200m"

---
apiVersion: v1
kind: Service
metadata:
  name: mcp-proxy-service
spec:
  selector:
    app: mcp-proxy
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8081
  type: LoadBalancer
```

Deploy to Kubernetes:

```bash
kubectl apply -f mcp-proxy-k8s.yaml
```

## Load Balancing

### NGINX Configuration

Simple load balancing with NGINX:

```nginx
upstream mcp_proxy {
    server mcp-proxy-1:8081;
    server mcp-proxy-2:8081;
    server mcp-proxy-3:8081;
}

server {
    listen 80;
    server_name mcp.yourdomain.com;
    
    location / {
        proxy_pass http://mcp_proxy;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    location /health {
        proxy_pass http://mcp_proxy/health;
        access_log off;
    }
}
```

### HAProxy Configuration

Alternative load balancing with HAProxy:

```
global
    daemon

defaults
    mode http
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

frontend mcp_frontend
    bind *:80
    default_backend mcp_backend

backend mcp_backend
    balance roundrobin
    option httpchk GET /health
    server mcp1 mcp-proxy-1:8081 check
    server mcp2 mcp-proxy-2:8081 check
    server mcp3 mcp-proxy-3:8081 check
```

## Security Configuration

### Authentication Setup

```bash
# Generate secure tokens
TOKEN1=$(openssl rand -hex 32)
TOKEN2=$(openssl rand -hex 32)
ADMIN_TOKEN=$(openssl rand -hex 32)

# Start with authentication
compozy mcp-proxy \
  --global-auth-tokens "$TOKEN1,$TOKEN2" \
  --admin-tokens "$ADMIN_TOKEN" \
  --admin-allow-ips "10.0.0.0/8,172.16.0.0/12,192.168.0.0/16"
```

### TLS Termination

Use a reverse proxy for TLS termination:

```nginx
server {
    listen 443 ssl http2;
    server_name mcp.yourdomain.com;
    
    ssl_certificate /path/to/certificate.crt;
    ssl_certificate_key /path/to/private.key;
    
    location / {
        proxy_pass http://localhost:8081;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
    }
}
```

### Firewall Configuration

Basic firewall rules:

```bash
# Allow only necessary ports
sudo ufw allow 22/tcp    # SSH
sudo ufw allow 80/tcp    # HTTP
sudo ufw allow 443/tcp   # HTTPS
sudo ufw deny 8081/tcp   # Block direct access to MCP proxy

# Enable firewall
sudo ufw --force enable
```

## Monitoring and Logging

### Health Check Monitoring

Set up basic health monitoring:

```bash
#!/bin/bash
# health-check.sh

HEALTH_URL="http://localhost:8081/health"
MAX_FAILURES=3
FAILURE_COUNT=0

while true; do
    if curl -f "$HEALTH_URL" > /dev/null 2>&1; then
        FAILURE_COUNT=0
        echo "$(date): Health check passed"
    else
        FAILURE_COUNT=$((FAILURE_COUNT + 1))
        echo "$(date): Health check failed (attempt $FAILURE_COUNT/$MAX_FAILURES)"
        
        if [ $FAILURE_COUNT -ge $MAX_FAILURES ]; then
            echo "$(date): Max failures reached, restarting service"
            systemctl restart mcp-proxy
            FAILURE_COUNT=0
        fi
    fi
    
    sleep 30
done
```

### Log Configuration

Configure logging for production:

```yaml
# mcp-proxy.yaml
logging:
  level: "info"
  format: "json"
  output: "/var/log/compozy/mcp-proxy.log"
```

### Log Rotation

Set up log rotation:

```
# /etc/logrotate.d/mcp-proxy
/var/log/compozy/mcp-proxy.log {
    daily
    missingok
    rotate 7
    compress
    delaycompress
    notifempty
    copytruncate
}
```

### Basic Monitoring Script

```bash
#!/bin/bash
# monitor-mcp.sh

LOG_FILE="/var/log/compozy/mcp-proxy.log"
ALERT_EMAIL="admin@yourdomain.com"

# Monitor error rate
ERROR_COUNT=$(grep -c '"level":"error"' "$LOG_FILE" | tail -100)
if [ "$ERROR_COUNT" -gt 10 ]; then
    echo "High error rate detected: $ERROR_COUNT errors" | \
        mail -s "MCP Proxy Alert" "$ALERT_EMAIL"
fi

# Monitor disk space
DISK_USAGE=$(df /var/log | awk 'NR==2 {print $5}' | sed 's/%//')
if [ "$DISK_USAGE" -gt 80 ]; then
    echo "Low disk space: ${DISK_USAGE}% used" | \
        mail -s "Disk Space Alert" "$ALERT_EMAIL"
fi
```

## Backup and Recovery

### Configuration Backup

```bash
#!/bin/bash
# backup-config.sh

BACKUP_DIR="/backup/mcp-proxy"
DATE=$(date +%Y%m%d_%H%M%S)

# Create backup directory
mkdir -p "$BACKUP_DIR"

# Backup configuration
cp /etc/compozy/mcp-proxy.yaml "$BACKUP_DIR/config_$DATE.yaml"

# Backup logs
tar -czf "$BACKUP_DIR/logs_$DATE.tar.gz" /var/log/compozy/

# Clean old backups (keep 7 days)
find "$BACKUP_DIR" -type f -mtime +7 -delete
```

### Recovery Procedures

1. **Service Recovery**:
   ```bash
   # Restart service
   systemctl restart mcp-proxy
   
   # Check status
   systemctl status mcp-proxy
   
   # Check logs
   journalctl -u mcp-proxy -f
   ```

2. **Configuration Recovery**:
   ```bash
   # Restore from backup
   cp /backup/mcp-proxy/config_YYYYMMDD_HHMMSS.yaml /etc/compozy/mcp-proxy.yaml
   
   # Restart service
   systemctl restart mcp-proxy
   ```

## Performance Tuning

### Resource Limits

Set appropriate resource limits:

```
# /etc/systemd/system/mcp-proxy.service
[Unit]
Description=MCP Proxy Server
After=network.target

[Service]
Type=simple
User=mcp-proxy
Group=mcp-proxy
ExecStart=/usr/local/bin/compozy mcp-proxy
Restart=always
RestartSec=5

# Resource limits
LimitNOFILE=65536
LimitNPROC=32768
MemoryLimit=512M

[Install]
WantedBy=multi-user.target
```

### Connection Tuning

Tune for high concurrency:

```yaml
# mcp-proxy.yaml
server:
  read_timeout: 30s
  write_timeout: 30s
  idle_timeout: 120s
  max_header_bytes: 1048576
```

## Troubleshooting

### Common Issues

1. **High Memory Usage**
   ```bash
   # Monitor memory
   ps aux | grep mcp-proxy
   
   # Check for memory leaks
   valgrind compozy mcp-proxy
   ```

2. **Connection Issues**
   ```bash
   # Check port availability
   netstat -tlnp | grep 8081
   
   # Test connectivity
   curl -v http://localhost:8081/health
   ```

3. **Performance Issues**
   ```bash
   # Monitor request rates
   tail -f /var/log/compozy/mcp-proxy.log | grep -E '"method":|"status":'
   
   # Check resource usage
   top -p $(pgrep mcp-proxy)
   ```

### Debug Mode

Enable debug logging for troubleshooting:

```bash
# Start with debug logging
compozy mcp-proxy --debug --log-level debug

# Or via environment
export LOG_LEVEL=debug
compozy mcp-proxy
```

## Best Practices

### Security
- Use strong authentication tokens
- Implement IP allowlists for admin access
- Run behind a reverse proxy with TLS
- Regularly update dependencies

### Reliability
- Use health checks for load balancers
- Implement proper logging and monitoring
- Set up automated restarts on failure
- Regular backup of configurations

### Performance
- Monitor resource usage and scale horizontally
- Use connection pooling where appropriate
- Implement request rate limiting if needed
- Regular performance testing

### Operations
- Automate deployments with CI/CD
- Use infrastructure as code
- Implement proper alerting
- Document operational procedures

## Next Steps

<FeatureCardList cols={2}>
  <FeatureCard title="Monitoring & Metrics" href="/docs/core/mcp/monitoring-metrics">
    Set up monitoring and metrics collection
  </FeatureCard>
  <FeatureCard title="Development & Debugging" href="/docs/core/mcp/development-debugging">
    Debug and troubleshoot MCP issues
  </FeatureCard>
  <FeatureCard title="Storage Backends" href="/docs/core/mcp/storage-backends">
    Configure storage for production
  </FeatureCard>
  <FeatureCard title="Admin API" href="/docs/core/mcp/admin-api">
    Administrative operations and management
  </FeatureCard>
</FeatureCardList>