---
title: "MCP Proxy Server"
description: "Understanding the MCP proxy server architecture and deployment"
---

import {
  Radio,
  Database,
  Shield,
  Settings,
  Users,
  BarChart3,
  RefreshCw,
  Terminal,
  Globe,
  Lock,
  Eye,
  Zap,
  Package,
  Code,
  Cloud,
  Link2,
  FileCode,
  TrendingUp,
  AlertTriangle,
  CheckCircle,
  XCircle,
  Clock,
  Server,
  Cpu,
  Memory,
  HardDrive,
  Network,
  GitBranch,
  Layers,
  MessageSquare,
  Key,
  Monitor,
  Activity,
  AlertCircle,
  Info,
  Warning,
  Check,
} from "lucide-react";

The MCP Proxy Server is the central gateway that manages all MCP server connections in Compozy. It acts as a reverse proxy, connection manager, and administration hub for MCP servers, providing a unified HTTP interface for multiple MCP servers.

<Callout type="info">
**Central Hub**: The MCP Proxy Server eliminates the need for individual MCP client connections by providing a single point of access for all MCP servers.
</Callout>

## Architecture Overview

<Mermaid>
{`
graph TB
    subgraph "Client Layer"
        A1[AI Agent 1]
        A2[AI Agent 2]
        A3[AI Agent N]
    end

    subgraph "MCP Proxy Server"
        B[HTTP Router]
        C[Admin API]
        D[Connection Manager]
        E[Transport Layer]
        F[Storage Backend]
        G[Auth Manager]
        H[Health Monitor]
    end

    subgraph "MCP Servers"
        I[stdio Server]
        J[SSE Server]
        K[HTTP Server]
        L[Docker Server]
    end

    A1 --> B
    A2 --> B
    A3 --> B

    B --> D
    C --> D
    D --> E
    E --> I
    E --> J
    E --> K
    E --> L

    D --> F
    B --> G
    C --> G
    D --> H

    style B fill:#e1f5fe
    style C fill:#f3e5f5
    style D fill:#e8f5e8
    style E fill:#fff3e0
    style F fill:#fce4ec
    style G fill:#f1f8e9
    style H fill:#e0f2f1
`}
</Mermaid>

## Core Components

<AccordionGroup>
<Accordion title="HTTP Router" icon="radio">
The main entry point that handles all incoming requests and routes them to appropriate handlers.

**Responsibilities:**
- Request routing to MCP servers
- Authentication and authorization
- Request/response transformation
- Error handling and status codes
</Accordion>

<Accordion title="Admin API" icon="settings">
Management interface for dynamic server registration and configuration.

**Capabilities:**
- Register/unregister MCP servers
- Update server configurations
- Monitor server health and status
- Access control and authentication
</Accordion>

<Accordion title="Connection Manager" icon="link-2">
Manages all MCP server connections with pooling and lifecycle management.

**Features:**
- Connection pooling and reuse
- Health monitoring and recovery
- Automatic reconnection with backoff
- Resource cleanup and management
</Accordion>

<Accordion title="Transport Layer" icon="network">
Handles different transport protocols for MCP server communication.

**Supported Transports:**
- stdio (Standard I/O)
- SSE (Server-Sent Events)
- streamable-http (HTTP with streaming)
- Custom transport implementations
</Accordion>

<Accordion title="Storage Backend" icon="database">
Persistent storage for MCP server configurations and state.

**Options:**
- In-memory storage (development)
- Redis storage (production)
- Custom storage backends
- Configuration persistence
</Accordion>

<Accordion title="Authentication Manager" icon="shield">
Handles security and access control for the proxy server.

**Security Features:**
- Token-based authentication
- IP allow-lists and restrictions
- Trusted proxy support
- Role-based access control
</Accordion>
</AccordionGroup>

## Key Features

<FeatureCardList cols={2}>
  <FeatureCard
    title="Multi-Transport Support"
    description="stdio, SSE, and streamable-http transports for different communication patterns"
    icon="network"
  />
  <FeatureCard
    title="Dynamic Registration"
    description="Hot-add, update, or remove servers via Admin API with zero downtime"
    icon="refresh-cw"
  />
  <FeatureCard
    title="Security & Authentication"
    description="Token-based auth, IP restrictions, and trusted proxy support"
    icon="shield"
  />
  <FeatureCard
    title="Storage Flexibility"
    description="In-memory for development, Redis for production persistence"
    icon="database"
  />
</FeatureCardList>

### Transport Support Details

<Tabs defaultValue="stdio" items={["stdio", "sse", "streamable-http"]}>
<Tab value="stdio">
**Standard I/O Transport**

For local process communication with high performance:

- **Use Case**: Local MCP servers, Docker containers, command-line tools
- **Performance**: Low latency, high throughput
- **Security**: Process-level isolation
- **Management**: Automatic process lifecycle management

<Callout type="info">
**Best For**: Development environments and local tool integration
</Callout>
</Tab>

<Tab value="sse">
**Server-Sent Events Transport**

For HTTP-based real-time streaming:

- **Use Case**: Remote APIs, cloud services, real-time data feeds
- **Performance**: Medium latency, good for streaming
- **Security**: HTTPS encryption, token authentication
- **Management**: Automatic reconnection with backoff

<Callout type="info">
**Best For**: Third-party APIs and real-time integrations
</Callout>
</Tab>

<Tab value="streamable-http">
**Streamable HTTP Transport**

For large responses and file transfers:

- **Use Case**: File processing, bulk data operations, media handling
- **Performance**: High throughput, handles large payloads
- **Security**: HTTPS encryption, authentication headers
- **Management**: Chunked transfer encoding support

<Callout type="info">
**Best For**: Large data processing and file operations
</Callout>
</Tab>
</Tabs>

## Configuration

### Server Configuration

<Callout type="info">
**Configuration Structure**: The proxy server uses a Go configuration struct with environment variable support for production deployments.
</Callout>

<Tabs defaultValue="structure" items={["structure", "defaults", "validation"]}>
<Tab value="structure">
**Configuration Structure**

```go title="Configuration Structure"
type Config struct {
    Port               string        // TCP port (default: "8081")
    Host               string        // Listen address (default: "0.0.0.0")
    BaseURL            string        // Base URL for generating paths
    ShutdownTimeout    time.Duration // Graceful shutdown timeout
    AdminTokens        []string      // Admin API bearer tokens
    AdminAllowIPs      []string      // Admin API IP allow-list
    TrustedProxies     []string      // Trusted proxy IPs
    GlobalAuthTokens   []string      // Global auth tokens
    StorageType        string        // Storage backend type
    MaxConnections     int           // Maximum concurrent connections
    IdleTimeout        time.Duration // Connection idle timeout
    ReadTimeout        time.Duration // HTTP read timeout
    WriteTimeout       time.Duration // HTTP write timeout
}
```
</Tab>

<Tab value="defaults">
**Default Configuration**

```go title="Default Values"
func DefaultConfig() *Config {
    return &Config{
        Port:            "8081",
        Host:            "0.0.0.0",
        BaseURL:         "http://localhost:8081",
        ShutdownTimeout: 30 * time.Second,
        StorageType:     "memory",
        MaxConnections:  100,
        IdleTimeout:     30 * time.Second,
        ReadTimeout:     10 * time.Second,
        WriteTimeout:    10 * time.Second,
    }
}
```
</Tab>

<Tab value="validation">
**Configuration Validation**

```go title="Validation Rules"
func (c *Config) Validate() error {
    // Port validation
    if c.Port == "" {
        return errors.New("port is required")
    }

    // Host validation
    if c.Host == "" {
        return errors.New("host is required")
    }

    // BaseURL validation
    if c.BaseURL == "" {
        return errors.New("base URL is required")
    }

    // Timeout validation
    if c.ShutdownTimeout < 0 {
        return errors.New("shutdown timeout cannot be negative")
    }

    return nil
}
```
</Tab>
</Tabs>

### Environment Variables

<Tabs defaultValue="basic" items={["basic", "security", "advanced"]}>
<Tab value="basic">
**Basic Server Configuration**

```bash title="Basic Environment Variables"
# Server configuration
MCP_PROXY_HOST=0.0.0.0
MCP_PROXY_PORT=8081
MCP_PROXY_BASE_URL=http://localhost:8081

# Shutdown timeout
MCP_PROXY_SHUTDOWN_TIMEOUT=30s
```
</Tab>

<Tab value="security">
**Security Configuration**

```bash title="Security Environment Variables"
# Admin API security
MCP_PROXY_ADMIN_TOKEN=your-secure-admin-token
MCP_PROXY_ADMIN_ALLOW_IPS=127.0.0.1,::1,10.0.0.0/8

# Global authentication
MCP_PROXY_GLOBAL_AUTH_TOKEN=global-access-token

# Trusted proxies
MCP_PROXY_TRUSTED_PROXIES=127.0.0.1,::1
```

<Callout type="warning">
**Security Best Practice**: Always use strong, unique tokens and restrict IP access in production environments.
</Callout>
</Tab>

<Tab value="advanced">
**Advanced Configuration**

```bash title="Advanced Environment Variables"
# Storage backend
MCP_PROXY_STORAGE_TYPE=redis
REDIS_URL=redis://localhost:6379/0

# Connection settings
MCP_PROXY_MAX_CONNECTIONS=100
MCP_PROXY_IDLE_TIMEOUT=30s
MCP_PROXY_READ_TIMEOUT=10s
MCP_PROXY_WRITE_TIMEOUT=10s

# Logging
MCP_PROXY_LOG_LEVEL=info
MCP_PROXY_LOG_FORMAT=json
```
</Tab>
</Tabs>

## Deployment Options

### CLI Deployment

<Steps>
<Step title="Basic Start">
Start with default configuration:

```bash
compozy mcp-proxy
```
</Step>

<Step title="Custom Configuration">
Start with custom settings:

```bash
compozy mcp-proxy \
  --host 0.0.0.0 \
  --port 8081 \
  --admin-tokens "secure-admin-token" \
  --admin-allow-ips "10.0.0.0/8,192.168.1.0/24"
```
</Step>

<Step title="Production Configuration">
Use environment variables for production:

```bash
export MCP_PROXY_ADMIN_TOKEN="$(openssl rand -hex 32)"
export MCP_PROXY_GLOBAL_AUTH_TOKEN="$(openssl rand -hex 32)"
compozy mcp-proxy --host 0.0.0.0 --port 8081
```
</Step>
</Steps>

### Docker Deployment

<Tabs defaultValue="simple" items={["simple", "compose", "kubernetes"]}>
<Tab value="simple">
**Simple Docker Container**

```dockerfile title="Dockerfile"
FROM compozy/compozy:latest

EXPOSE 8081

CMD ["compozy", "mcp-proxy", "--host", "0.0.0.0", "--port", "8081"]
```

```bash title="Run Container"
docker run -p 8081:8081 \
  -e MCP_PROXY_ADMIN_TOKEN=secure-token \
  -e MCP_PROXY_GLOBAL_AUTH_TOKEN=global-token \
  compozy/compozy:latest \
  compozy mcp-proxy
```
</Tab>

<Tab value="compose">
**Docker Compose Setup**

```yaml title="docker-compose.yml"
version: '3.8'

services:
  mcp-proxy:
    image: compozy/compozy:latest
    ports:
      - "8081:8081"
    environment:
      - MCP_PROXY_HOST=0.0.0.0
      - MCP_PROXY_PORT=8081
      - MCP_PROXY_ADMIN_TOKEN=${MCP_PROXY_ADMIN_TOKEN}
      - MCP_PROXY_GLOBAL_AUTH_TOKEN=${MCP_PROXY_GLOBAL_AUTH_TOKEN}
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      - redis
    command: ["compozy", "mcp-proxy"]

  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data

volumes:
  redis_data:
```
</Tab>

<Tab value="kubernetes">
**Kubernetes Deployment**

```yaml title="k8s-deployment.yaml"
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mcp-proxy
  labels:
    app: mcp-proxy
    version: v1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: mcp-proxy
  template:
    metadata:
      labels:
        app: mcp-proxy
        version: v1
    spec:
      containers:
      - name: mcp-proxy
        image: compozy/compozy:latest
        ports:
        - containerPort: 8081
          name: http
        env:
        - name: MCP_PROXY_HOST
          value: "0.0.0.0"
        - name: MCP_PROXY_PORT
          value: "8081"
        - name: MCP_PROXY_ADMIN_TOKEN
          valueFrom:
            secretKeyRef:
              name: mcp-proxy-secrets
              key: admin-token
        - name: MCP_PROXY_GLOBAL_AUTH_TOKEN
          valueFrom:
            secretKeyRef:
              name: mcp-proxy-secrets
              key: global-token
        - name: REDIS_URL
          value: "redis://redis-service:6379/0"
        - name: MCP_PROXY_MAX_CONNECTIONS
          value: "200"
        - name: MCP_PROXY_IDLE_TIMEOUT
          value: "60s"
        command: ["compozy", "mcp-proxy"]
        livenessProbe:
          httpGet:
            path: /healthz
            port: 8081
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /healthz
            port: 8081
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"

---
apiVersion: v1
kind: Service
metadata:
  name: mcp-proxy-service
  labels:
    app: mcp-proxy
spec:
  selector:
    app: mcp-proxy
  ports:
  - port: 8081
    targetPort: 8081
    protocol: TCP
    name: http
  type: LoadBalancer

---
apiVersion: v1
kind: Secret
metadata:
  name: mcp-proxy-secrets
type: Opaque
data:
  # Base64 encoded tokens
  admin-token: <base64-encoded-admin-token>
  global-token: <base64-encoded-global-token>
```
</Tab>
</Tabs>

### Programmatic Usage

```go
package main

import (
    "context"
    "time"

    "github.com/compozy/compozy/pkg/mcp-proxy"
)

func main() {
    // Create configuration
    config := &mcpproxy.Config{
        Host:             "0.0.0.0",
        Port:             "8081",
        BaseURL:          "http://localhost:8081",
        ShutdownTimeout:  30 * time.Second,
        AdminTokens:      []string{"secure-admin-token"},
        AdminAllowIPs:    []string{"127.0.0.1", "::1"},
        GlobalAuthTokens: []string{"global-token"},
    }

    // Create storage
    storage := mcpproxy.NewInMemoryStorage()

    // Create and start proxy
    proxy := mcpproxy.NewProxy(config, storage)
    if err := proxy.Start(); err != nil {
        panic(err)
    }

    defer proxy.Stop()

    // Server is now running on http://localhost:8081
    select {}
}
```

## API Endpoints

### System Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/healthz` | GET | Health check |
| `/metrics` | GET | Prometheus metrics |

### Admin API Endpoints

All admin endpoints require authentication via `Authorization: Bearer <token>`.

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/admin/mcps` | POST | Register MCP server |
| `/admin/mcps` | GET | List all MCP servers |
| `/admin/mcps/{name}` | GET | Get specific MCP server |
| `/admin/mcps/{name}` | PUT | Update MCP server |
| `/admin/mcps/{name}` | DELETE | Remove MCP server |
| `/admin/tools` | GET | List all tools |

### Proxy Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/{name}/sse` | GET | SSE proxy endpoint |
| `/{name}/stream` | POST | Streamable HTTP proxy |

## Storage Backends

### In-Memory Storage (Default)

```go
// For development and testing
storage := mcpproxy.NewInMemoryStorage()
```

**Pros:**
- Fast and simple
- No external dependencies
- Good for development

**Cons:**
- Data lost on restart
- Not suitable for production

### Redis Storage

```go
// For production environments
redisConfig := &mcpproxy.RedisConfig{
    Addr:     "localhost:6379",
    Password: "secret",
    DB:       0,
}

storage, err := mcpproxy.NewRedisStorage(redisConfig)
```

**Pros:**
- Persistent storage
- High availability
- Scalable

**Cons:**
- Requires Redis instance
- Additional complexity

## Health Checks & Monitoring

### Health Check Endpoints

<Tabs defaultValue="health" items={["health", "metrics", "admin"]}>
<Tab value="health">
**Health Check Endpoint**

```bash
# Basic health check
curl http://localhost:8081/healthz

# Response format
{
  "status": "healthy",
  "timestamp": "2024-01-15T10:30:00Z",
  "uptime": "2h30m15s",
  "connections": {
    "active": 25,
    "total": 150
  },
  "storage": {
    "type": "redis",
    "status": "connected"
  }
}
```

**Health Check Features:**
- Server availability status
- Connection pool health
- Storage backend connectivity
- Uptime information
- Resource utilization
</Tab>

<Tab value="metrics">
**Metrics Endpoint**

```bash
# Prometheus metrics
curl http://localhost:8081/metrics

# Sample metrics output
# HELP mcp_proxy_connections_total Total number of connections
# TYPE mcp_proxy_connections_total counter
mcp_proxy_connections_total 1234

# HELP mcp_proxy_requests_duration_seconds Request duration in seconds
# TYPE mcp_proxy_requests_duration_seconds histogram
mcp_proxy_requests_duration_seconds_bucket{le="0.1"} 950
mcp_proxy_requests_duration_seconds_bucket{le="0.5"} 1200
mcp_proxy_requests_duration_seconds_bucket{le="1.0"} 1234

# HELP mcp_proxy_errors_total Total number of errors
# TYPE mcp_proxy_errors_total counter
mcp_proxy_errors_total{type="connection"} 5
mcp_proxy_errors_total{type="timeout"} 2
```

**Available Metrics:**
- Connection counts and durations
- Request latency distributions
- Error rates by type
- Storage backend performance
- Transport-specific metrics
</Tab>

<Tab value="admin">
**Admin API Status**

```bash
# Admin API health (requires token)
curl -H "Authorization: Bearer $MCP_PROXY_ADMIN_TOKEN" \
     http://localhost:8081/admin/status

# Response format
{
  "admin_api": "healthy",
  "registered_servers": 5,
  "active_sessions": 12,
  "server_health": {
    "filesystem": "healthy",
    "database": "healthy",
    "weather-api": "reconnecting",
    "python-runtime": "healthy",
    "docker-postgres": "healthy"
  }
}
```

**Admin Status Features:**
- Server registration status
- Individual server health
- Session management info
- Admin API availability
- Authentication status
</Tab>
</Tabs>

## Security Considerations

### Authentication
- Use strong, unique admin tokens
- Rotate tokens regularly
- Store tokens securely (environment variables)

### Network Security
- Configure IP allow-lists for admin API
- Use HTTPS in production
- Set up proper firewall rules

### Access Control
- Limit admin API access to specific IP ranges
- Use global auth tokens for client access
- Configure trusted proxies correctly

## Monitoring

### Metrics
- Connection counts per MCP server
- Request latency and error rates
- Health check status
- Resource utilization

### Logging
- Structured logging with configurable levels
- Request/response logging
- Error tracking and alerting

## Troubleshooting

### Common Issues & Solutions

<Tabs defaultValue="connection" items={["connection", "auth", "performance", "servers"]}>
<Tab value="connection">
**Connection Issues**

| Issue | Symptoms | Solution |
|-------|----------|----------|
| **Connection Refused** | `curl: (7) Failed to connect` | Check if proxy is running on correct port |
| **Port Already in Use** | `bind: address already in use` | Change port or stop conflicting process |
| **Firewall Blocking** | Connections timeout | Configure firewall rules for port 8081 |
| **DNS Resolution** | `no such host` | Verify hostname/IP configuration |

**Debug Commands:**
```bash
# Check if proxy is running
ps aux | grep mcp-proxy

# Verify port is open
netstat -tulpn | grep :8081

# Test connectivity
telnet localhost 8081
```
</Tab>

<Tab value="auth">
**Authentication Issues**

| Issue | Symptoms | Solution |
|-------|----------|----------|
| **Invalid Token** | `401 Unauthorized` | Verify admin token is correct |
| **Missing Headers** | `403 Forbidden` | Include Authorization header |
| **IP Restrictions** | `403 Forbidden` | Check IP allow-lists |
| **Token Expiration** | `401 Unauthorized` | Refresh or rotate tokens |

**Debug Commands:**
```bash
# Test admin API access
curl -H "Authorization: Bearer $MCP_PROXY_ADMIN_TOKEN" \
     http://localhost:8081/admin/mcps

# Check IP allow-list
curl -H "Authorization: Bearer $TOKEN" \
     -H "X-Forwarded-For: 192.168.1.100" \
     http://localhost:8081/admin/mcps
```
</Tab>

<Tab value="performance">
**Performance Issues**

| Issue | Symptoms | Solution |
|-------|----------|----------|
| **High Latency** | Slow response times | Check connection pool settings |
| **Memory Leaks** | Increasing memory usage | Monitor connection cleanup |
| **CPU Spikes** | High CPU utilization | Review request patterns |
| **Connection Limits** | `Connection refused` | Increase max_connections |

**Performance Monitoring:**
```bash
# Monitor resource usage
top -p $(pgrep mcp-proxy)

# Check connection stats
curl http://localhost:8081/metrics | grep mcp_proxy_connections

# Monitor request latency
curl http://localhost:8081/metrics | grep mcp_proxy_requests_duration
```
</Tab>

<Tab value="servers">
**MCP Server Issues**

| Issue | Symptoms | Solution |
|-------|----------|----------|
| **Server Not Starting** | `stdio` processes fail | Check command and arguments |
| **Connection Timeouts** | `SSE` connections drop | Verify URL and network |
| **Auth Failures** | `401/403` from servers | Check server authentication |
| **Health Check Fails** | Server marked unhealthy | Review server logs |

**Server Debugging:**
```bash
# List registered servers
curl -H "Authorization: Bearer $TOKEN" \
     http://localhost:8081/admin/mcps

# Check specific server health
curl -H "Authorization: Bearer $TOKEN" \
     http://localhost:8081/admin/mcps/filesystem

# View server logs
journalctl -f -u mcp-proxy
```
</Tab>
</Tabs>

### Debug Mode

<Callout type="warning">
**Debug Mode**: Enable debug logging for troubleshooting, but avoid in production due to performance impact.
</Callout>

```bash
# Enable debug logging
compozy mcp-proxy --debug

# Or with environment variable
MCP_PROXY_LOG_LEVEL=debug compozy mcp-proxy

# Debug with specific components
MCP_PROXY_LOG_LEVEL=debug \
MCP_PROXY_LOG_COMPONENTS=router,auth,transport \
compozy mcp-proxy
```

**Debug Features:**
- Detailed request/response logging
- Connection lifecycle tracking
- Authentication decision logging
- Transport protocol debugging
- Error stack traces

## Production Deployment

### High Availability

```yaml
# docker-compose.yml
version: '3.8'
services:
  mcp-proxy-1:
    image: compozy/compozy:latest
    ports:
      - "8081:8081"
    environment:
      - MCP_PROXY_ADMIN_TOKEN=secure-token
      - REDIS_URL=redis://redis:6379
    depends_on:
      - redis

  mcp-proxy-2:
    image: compozy/compozy:latest
    ports:
      - "8082:8081"
    environment:
      - MCP_PROXY_ADMIN_TOKEN=secure-token
      - REDIS_URL=redis://redis:6379
    depends_on:
      - redis

  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data

volumes:
  redis_data:
```

### Load Balancing

```nginx
upstream mcp_proxy {
    server mcp-proxy-1:8081;
    server mcp-proxy-2:8081;
}

server {
    listen 80;
    location / {
        proxy_pass http://mcp_proxy;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

## Next Steps

<ReferenceCardList>
  <ReferenceCard
    title="Client Manager"
    description="Learn about MCP client management"
    href="/docs/core/mcp/client-manager"
    icon="Network"
  />
  <ReferenceCard
    title="Transport Configuration"
    description="Configure transport types"
    href="/docs/core/mcp/transport-configuration"
    icon="Settings"
  />
  <ReferenceCard
    title="Security & Authentication"
    description="Secure your deployment"
    href="/docs/core/mcp/security-authentication"
    icon="Shield"
  />
  <ReferenceCard
    title="Monitoring & Metrics"
    description="Monitor your proxy server"
    href="/docs/core/mcp/monitoring-metrics"
    icon="Monitor"
  />
</ReferenceCardList>
