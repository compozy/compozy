---
title: "Admin API"
description: "Administrative API for managing MCP servers, monitoring operations, and system configuration"
---

The MCP Admin API provides administrative capabilities for managing MCP servers through Compozy's HTTP proxy architecture. This API enables operational teams to register, monitor, and manage MCP server deployments using a simple REST interface.

<Callout type="info" icon="Settings">
  **Administrative Control**: The Admin API provides operational control over your MCP deployment through HTTP endpoints and basic authentication.
</Callout>

## API Overview

The Admin API is built on top of Compozy's MCP proxy service, providing a simple HTTP interface for managing MCP servers. The architecture follows a straightforward client-proxy-server pattern:

<Mermaid chart={`graph TB
    subgraph "Admin API"
        API[HTTP Admin API<br/>:6001/admin]
        AUTH[Token Authentication<br/>Basic Auth]
    end

    subgraph "MCP Proxy"
        PROXY[MCP Proxy Service<br/>:6001]
        REG[Registration Service<br/>Server Management]
    end

    subgraph "MCP Servers"
        S1[MCP Server 1<br/>stdio/SSE]
        S2[MCP Server 2<br/>stdio/SSE]
        S3[MCP Server N<br/>stdio/SSE]
    end

    API --> AUTH
    AUTH --> PROXY
    PROXY --> REG
    REG --> S1
    REG --> S2
    REG --> S3

    classDef api fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef proxy fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef servers fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px

    class API,AUTH api
    class PROXY,REG proxy
    class S1,S2,S3 servers
`} />

The admin API provides essential MCP management capabilities through simple HTTP endpoints. Unlike complex enterprise systems, Compozy's admin API focuses on practical operational needs with a lightweight implementation.

### Core Admin Capabilities

<FeatureCardList cols={3} size="sm">
  <FeatureCard
    title="Server Registration"
    description="Register and manage MCP servers with the proxy"
    icon="Server"
  />
  <FeatureCard
    title="Tool Execution"
    description="Execute tools on registered MCP servers"
    icon="Wrench"
  />
  <FeatureCard
    title="Health Monitoring"
    description="Basic health checks and server status"
    icon="Monitor"
  />
  <FeatureCard
    title="Configuration Management"
    description="Update proxy and server configurations"
    icon="Settings"
  />
  <FeatureCard
    title="Authentication"
    description="Token-based authentication for admin access"
    icon="Shield"
  />
  <FeatureCard
    title="Proxy Management"
    description="Control proxy service operations"
    icon="Router"
  />
</FeatureCardList>

## Implementation Overview

Compozy's admin API is implemented using the existing MCP proxy infrastructure. The core components work together to provide a simple but effective management interface.

### MCP Client Implementation

The foundation of the admin API is the MCP client, which provides HTTP communication with the proxy service:

```go
// From engine/mcp/client.go - The actual MCP client implementation
type Client struct {
    baseURL   string
    http      *http.Client
    adminTok  string
    retryConf RetryConfig
}

// Core operations available through the client
func (c *Client) Register(ctx context.Context, def *Definition) error
func (c *Client) Deregister(ctx context.Context, name string) error
func (c *Client) ListMCPs(ctx context.Context) ([]Definition, error)
func (c *Client) CallTool(ctx context.Context, mcpName, toolName string, arguments map[string]any) (any, error)
```

**Why this implementation matters:**
- **Simple HTTP operations**: Direct communication with the proxy service
- **Token-based authentication**: Basic but secure admin token system
- **Retry logic**: Built-in retry configuration for reliability
- **Context support**: Proper cancellation and timeout handling

### Tool Execution

Execute tools on registered MCP servers:

```go
// Execute tool on specific server
func (h *AdminHandler) ExecuteTool(c *gin.Context) {
    ctx := c.Request.Context()
    log := logger.FromContext(ctx)

    var request ToolCallRequest
    if err := c.ShouldBindJSON(&request); err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }

    // Execute tool via proxy
    response, err := h.mcpClient.CallTool(ctx, request.MCPName, request.ToolName, request.Arguments)
    if err != nil {
        log.Error("tool execution failed", "error", err, "mcp", request.MCPName, "tool", request.ToolName)
        c.JSON(500, gin.H{"error": "Tool execution failed"})
        return
    }

    c.JSON(200, gin.H{"result": response})
}
```

## API Usage Examples

### Basic Server Operations

Here are practical examples of using the admin API:

```bash
# List all registered MCP servers
curl -X GET http://localhost:6001/admin/mcps \
  -H "Authorization: Bearer YOUR_ADMIN_TOKEN"

# Register a new MCP server
curl -X POST http://localhost:6001/admin/mcps \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_ADMIN_TOKEN" \
  -d '{
    "name": "filesystem_server",
    "transport": "stdio",
    "command": "mcp-server-filesystem",
    "args": ["--root", "/workspace"]
  }'
```

### Tool Management

Execute tools on registered servers:

```bash
# List available tools for all servers
curl -X GET http://localhost:6001/admin/tools \
  -H "Authorization: Bearer YOUR_ADMIN_TOKEN"

# Execute a tool with arguments
curl -X POST http://localhost:6001/admin/tools/call \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_ADMIN_TOKEN" \
  -d '{
    "mcpName": "filesystem_server",
    "toolName": "read_file",
    "arguments": {
      "path": "/workspace/README.md"
    }
  }'
```

## CLI Management

Compozy provides comprehensive CLI commands for managing the system:

### Authentication Commands

```bash
# Generate a new API key
compozy auth generate --name "admin-key" --description "Admin API access"

# List all API keys
compozy auth list --format table

# Revoke an API key
compozy auth revoke [key-id] --force

# User management
compozy auth create-user --email "admin@example.com" --name "Admin User" --role "admin"
compozy auth list-users --role admin
compozy auth update-user [user-id] --role "user"
compozy auth delete-user [user-id] --force
```

### Configuration Commands

```bash
# Show current configuration
compozy config show --format yaml

# Run configuration diagnostics
compozy config diagnostics --verbose

# Validate configuration file
compozy config validate
```

### MCP Proxy Commands

```bash
# Start MCP proxy server
compozy-mcp-proxy \
  --host 0.0.0.0 \
  --port 6001 \
  --admin-tokens "your-admin-token" \
  --debug

# With environment variables
MCP_PROXY_HOST=0.0.0.0 \
MCP_PROXY_PORT=6001 \
compozy-mcp-proxy --debug
```

### Workflow Commands

```bash
# List all workflows
compozy workflow list --format table

# Get specific workflow details
compozy workflow get [workflow-id] --format yaml

# Execute a workflow
compozy workflow execute [workflow-id] --json='{"key": "value"}'
```

### Development Commands

```bash
# Initialize new project
compozy init [project-name]

# Start development server
compozy dev --port 8080 --reload

# Start production server
compozy start --config production.yaml
```

## MCP Configuration Reference

### Complete Config Structure

```go
// From engine/mcp/config.go - Complete Config struct
type Config struct {
    // Resource reference for the MCP server (optional)
    Resource string `yaml:"resource,omitempty" json:"resource,omitempty"`

    // ID is the unique identifier for this MCP server configuration
    ID string `yaml:"id" json:"id"`

    // URL is the endpoint for remote MCP servers
    URL string `yaml:"url" json:"url"`

    // Command is the executable command to spawn a local MCP server process
    Command string `yaml:"command,omitempty" json:"command,omitempty"`

    // Env contains environment variables to pass to the MCP server process
    Env map[string]string `yaml:"env,omitempty" json:"env,omitempty"`

    // Proto specifies the MCP protocol version to use (YYYY-MM-DD format)
    Proto string `yaml:"proto,omitempty" json:"proto,omitempty"`

    // Transport defines the communication transport mechanism
    // Supported: "sse", "streamable-http", "stdio"
    Transport mcpproxy.TransportType `yaml:"transport,omitempty" json:"transport,omitempty"`

    // StartTimeout is the maximum time to wait for the MCP server to start
    StartTimeout time.Duration `yaml:"start_timeout,omitempty" json:"start_timeout,omitempty"`

    // MaxSessions defines the maximum number of concurrent sessions allowed
    MaxSessions int `yaml:"max_sessions,omitempty" json:"max_sessions,omitempty"`
}
```

### Configuration Examples

```yaml
# Local MCP server configuration
mcps:
  - id: filesystem
    command: "mcp-server-filesystem"
    args: ["--root", "/workspace"]
    transport: stdio
    env:
      LOG_LEVEL: "debug"
    start_timeout: 30s
    max_sessions: 10

# Remote MCP server configuration
  - id: github-api
    url: "https://api.github.com/mcp/v1"
    transport: sse
    proto: "2025-03-26"
    env:
      GITHUB_TOKEN: "{{ .env.GITHUB_TOKEN }}"
```

## Best Practices

<Tabs items={["Security", "Configuration", "Performance", "Development"]}>

<Tab>
### Security Best Practices

- Generate strong admin tokens with sufficient entropy
- Use HTTPS for all admin API communications
- Implement proper permission validation for admin operations
- Log all administrative actions for audit purposes

</Tab>

<Tab>
### Configuration Best Practices

- Use environment variables for sensitive configuration
- Validate all configuration parameters before server registration
- Document configuration options and their effects
- Provide sensible defaults to minimize configuration complexity

</Tab>

<Tab>
### Performance Best Practices

- Configure HTTP client connection pooling for efficiency
- Set appropriate timeouts for admin operations
- Monitor server health through regular health checks
- Use efficient operations to minimize resource usage

</Tab>

<Tab>
### Development Best Practices

- Use environment-specific configurations for different deployments
- Enable debug logging during development for troubleshooting
- Write comprehensive tests for all admin operations
- Maintain up-to-date documentation for all admin endpoints

</Tab>
</Tabs>

## Next Steps

<ReferenceCardList>
  <ReferenceCard
    title="MCP Overview"
    description="Learn about MCP architecture and concepts"
    href="/docs/core/mcp/overview"
    icon="Network"
  />
  <ReferenceCard
    title="Client Manager"
    description="Understand MCP client management"
    href="/docs/core/mcp/client-manager"
    icon="Settings"
  />
  <ReferenceCard
    title="Development & Debugging"
    description="Debug and develop MCP integrations"
    href="/docs/core/mcp/development-debugging"
    icon="Bug"
  />
  <ReferenceCard
    title="Integration Patterns"
    description="Learn common MCP integration patterns"
    href="/docs/core/mcp/integration-patterns"
    icon="Workflow"
  />
</ReferenceCardList>
