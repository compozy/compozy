---
title: "Client Manager"
description: "Understanding MCP client management and connection handling in Compozy"
---

The MCP Client Manager in Compozy handles connections to MCP servers through the proxy service. It provides a simple but effective interface for managing MCP server connections, handling registration, and facilitating communication between agents and external tools.

<Callout type="info" icon="Network">
  **Connection Management**: The client manager provides a straightforward HTTP-based approach to managing MCP server connections through the proxy service.
</Callout>

## Architecture Overview

The client manager operates through Compozy's MCP proxy architecture:

<Mermaid chart={`graph TB
    subgraph "Compozy Application"
        AGENT[AI Agent]
        WORKFLOW[Workflow Engine]
        CLIENT[MCP Client]
    end

    subgraph "MCP Proxy Service"
        PROXY[MCP Proxy<br/>:8081]
        REG[Registration Service]
        CONN[Connection Pool]
    end

    subgraph "MCP Servers"
        SERVER1[MCP Server 1<br/>stdio]
        SERVER2[MCP Server 2<br/>SSE]
        SERVER3[MCP Server N<br/>stdio/SSE]
    end

    AGENT --> CLIENT
    WORKFLOW --> CLIENT
    CLIENT --> PROXY
    PROXY --> REG
    PROXY --> CONN
    REG --> SERVER1
    REG --> SERVER2
    REG --> SERVER3
    CONN --> SERVER1
    CONN --> SERVER2
    CONN --> SERVER3

    classDef app fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef proxy fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef servers fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px

    class AGENT,WORKFLOW,CLIENT app
    class PROXY,REG,CONN proxy
    class SERVER1,SERVER2,SERVER3 servers
`} />

The client manager architecture is designed for simplicity and reliability, focusing on the core functionality needed for MCP integration.

## Core Components

### MCP Client

The MCP client provides the primary interface for communicating with MCP servers:

```go
// From engine/mcp/client.go - The actual MCP client implementation
type Client struct {
    baseURL   string
    http      *http.Client
    adminTok  string
    retryConf RetryConfig
}

// NewClient creates a new MCP client with configuration
func NewClient(baseURL, adminToken string, timeout time.Duration) *Client {
    return &Client{
        baseURL:  baseURL,
        adminTok: adminToken,
        http: &http.Client{
            Timeout: timeout,
        },
        retryConf: RetryConfig{
            MaxAttempts: 3,
            BaseDelay:   100 * time.Millisecond,
            MaxDelay:    5 * time.Second,
        },
    }
}
```

**Client capabilities:**
- **HTTP communication**: Direct HTTP communication with the MCP proxy
- **Token authentication**: Secure authentication using admin tokens
- **Retry logic**: Built-in retry mechanism for handling transient failures
- **Timeout management**: Configurable timeouts for operations

### Registration Service

The registration service manages the lifecycle of MCP server connections:

```go
// From engine/mcp/service.go - Registration service implementation
type RegisterService struct {
    proxy *Client
}

func NewRegisterService(proxyClient *Client) *RegisterService {
    return &RegisterService{
        proxy: proxyClient,
    }
}

// Register multiple MCPs from workflow configuration
func (s *RegisterService) RegisterAll(ctx context.Context, config WorkflowConfig) error {
    mcps := config.GetMCPs()
    
    var g errgroup.Group
    for _, mcp := range mcps {
        mcp := mcp // capture loop variable
        g.Go(func() error {
            return s.Ensure(ctx, &mcp)
        })
    }
    
    return g.Wait()
}
```

**Registration features:**
- **Bulk registration**: Register multiple MCP servers simultaneously
- **Idempotent operations**: Ensure operations prevent duplicate registrations
- **Concurrent processing**: Parallel registration for improved performance
- **Error handling**: Comprehensive error handling for registration failures

## Connection Management

### Connection Lifecycle

The client manager handles the complete connection lifecycle:

```go
// Check if MCP server is registered (actual client implementation)
func (c *Client) verifyMCPRegistration(ctx context.Context, mcpName string) error {
    log := logger.FromContext(ctx)
    
    // List all registered MCPs
    mcps, err := c.ListMCPs(ctx)
    if err != nil {
        return fmt.Errorf("failed to list MCPs: %w", err)
    }
    
    // Check if the MCP is registered
    for _, mcp := range mcps {
        if mcp.Name == mcpName {
            log.Info("MCP verified as registered", "mcp", mcpName)
            return nil
        }
    }
    
    return fmt.Errorf("MCP %s not found in registered MCPs", mcpName)
}
```

**Connection management features:**
- **Connection validation**: Verify server registration before operations
- **Connection reuse**: Efficient connection reuse through the proxy
- **Health monitoring**: Basic health checks for server connectivity
- **Error recovery**: Graceful handling of connection failures

### Tool Execution

The client manager facilitates tool execution on registered MCP servers:

```go
// Tool execution through the MCP client (actual implementation)
func (c *Client) CallTool(ctx context.Context, mcpName, toolName string, arguments map[string]any) (any, error) {
    // Validate inputs
    if mcpName == "" || toolName == "" {
        return nil, fmt.Errorf("mcp name and tool name are required")
    }
    
    // Create tool call request
    req := ToolCallRequest{
        MCPName:   mcpName,
        ToolName:  toolName,
        Arguments: arguments,
    }
    
    // Execute HTTP request with retry logic
    return c.executeWithRetry(ctx, func() (any, error) {
        return c.makeToolCallRequest(ctx, req)
    })
}
```

**Tool execution features:**
- **Request validation**: Validate MCP name and tool name before execution
- **Error handling**: Comprehensive error handling with retry logic
- **Logging**: Detailed logging for debugging and monitoring
- **Type safety**: Proper handling of JSON responses and type conversion

## Configuration Management

### MCP Server Configuration

Configuration for MCP servers is handled through the workflow configuration:

```go
// MCP configuration from engine/mcp/config.go (actual implementation)
type Config struct {
    ID           string             `yaml:"id" json:"id"`
    Resource     string             `yaml:"resource,omitempty" json:"resource,omitempty"`
    Proto        string             `yaml:"proto,omitempty" json:"proto,omitempty"`
    Transport    TransportType      `yaml:"transport" json:"transport"`
    Command      string             `yaml:"command,omitempty" json:"command,omitempty"`
    Args         []string           `yaml:"args,omitempty" json:"args,omitempty"`
    Env          map[string]string  `yaml:"env,omitempty" json:"env,omitempty"`
    URL          string             `yaml:"url,omitempty" json:"url,omitempty"`
    StartTimeout Duration           `yaml:"start_timeout,omitempty" json:"start_timeout,omitempty"`
    MaxSessions  int                `yaml:"max_sessions,omitempty" json:"max_sessions,omitempty"`
}

// Transport types supported by the MCP system
type TransportType string

const (
    TransportStdio           TransportType = "stdio"
    TransportSSE             TransportType = "sse"
    TransportStreamableHTTP  TransportType = "streamable-http"
)
```

**Configuration features:**
- **Transport support**: Support for stdio, SSE, and streamable-http transports
- **Resource specification**: Optional resource and protocol fields
- **Environment variables**: Configurable environment variables for servers
- **Timeout control**: Configurable start timeout and session limits
- **Command-line arguments**: Flexible command-line argument configuration

### Dynamic Configuration

The client manager supports dynamic configuration updates:

```go
// Ensure MCP server registration (actual service implementation)
func (s *RegisterService) Ensure(ctx context.Context, def *Definition) error {
    log := logger.FromContext(ctx)
    
    // Check if already registered
    mcps, err := s.proxy.ListMCPs(ctx)
    if err != nil {
        return fmt.Errorf("failed to list MCPs: %w", err)
    }
    
    for _, mcp := range mcps {
        if mcp.Name == def.Name {
            log.Info("MCP already registered", "name", def.Name)
            return nil
        }
    }
    
    // Register new MCP
    if err := s.proxy.Register(ctx, def); err != nil {
        return fmt.Errorf("failed to register MCP %s: %w", def.Name, err)
    }
    
    log.Info("MCP registered successfully", "name", def.Name)
    return nil
}
```

**Registration service features:**
- **Idempotent registration**: Prevent duplicate MCP registrations
- **Bulk registration**: Register multiple MCPs concurrently using errgroup
- **Configuration validation**: Validate MCP configurations before registration
- **Error handling**: Comprehensive error handling for registration failures

## Error Handling and Recovery

### Retry Logic

The client manager implements comprehensive retry logic:

```go
// Retry configuration and implementation (actual client structure)
type RetryConfig struct {
    MaxAttempts int
    BaseDelay   time.Duration
    MaxDelay    time.Duration
}

func (c *Client) executeWithRetry(ctx context.Context, operation func() (any, error)) (any, error) {
    var lastErr error
    
    for attempt := 0; attempt < c.retryConf.MaxAttempts; attempt++ {
        result, err := operation()
        if err == nil {
            return result, nil
        }
        
        lastErr = err
        if attempt < c.retryConf.MaxAttempts-1 {
            delay := c.calculateBackoffDelay(attempt)
            select {
            case <-time.After(delay):
                continue
            case <-ctx.Done():
                return nil, ctx.Err()
            }
        }
    }
    
    return nil, fmt.Errorf("operation failed after %d attempts: %w", c.retryConf.MaxAttempts, lastErr)
}
```

**Retry features:**
- **Exponential backoff**: Intelligent backoff strategy for retries
- **Configurable retries**: Customizable retry attempts and delays
- **Context awareness**: Respect context cancellation during retries
- **Error classification**: Distinguish between retryable and non-retryable errors

### Error Recovery

The client manager provides robust error recovery mechanisms:

```go
// HTTP request handling with error classification (actual client implementation)
func (c *Client) makeHTTPRequest(ctx context.Context, method, path string, body io.Reader) (*http.Response, error) {
    url := fmt.Sprintf("%s%s", c.baseURL, path)
    
    req, err := http.NewRequestWithContext(ctx, method, url, body)
    if err != nil {
        return nil, fmt.Errorf("creating request: %w", err)
    }
    
    // Set headers
    req.Header.Set("Content-Type", "application/json")
    if c.adminTok != "" {
        req.Header.Set("Authorization", "Bearer "+c.adminTok)
    }
    
    resp, err := c.http.Do(req)
    if err != nil {
        return nil, fmt.Errorf("executing request: %w", err)
    }
    
    return resp, nil
}
```

**HTTP client features:**
- **Authentication**: Bearer token authentication for admin operations
- **Request building**: Proper HTTP request construction with context
- **Header management**: Automatic Content-Type and Authorization headers
- **Error handling**: Comprehensive error handling for HTTP operations

## Integration with Workflows

### Workflow Configuration

MCP servers are configured directly in workflow files:

```yaml
# Example workflow with MCP server configuration
resource: workflow
id: mcp-workflow-example
description: Example workflow using MCP servers

mcps:
  - id: filesystem
    transport: stdio
    command: "mcp-server-filesystem"
    args: ["--root", "/workspace"]
    env:
      LOG_LEVEL: "info"
  
  - id: database
    transport: stdio
    command: "mcp-server-database"
    args: ["--connection", "postgresql://localhost/db"]
    env:
      QUERY_TIMEOUT: "30s"

agents:
  - id: file-agent
    instructions: "You can access files and database through MCP tools"
    
tasks:
  - id: process-data
    agent: file-agent
    prompt: "Read data from files and store in database"
```

**Workflow integration features:**
- **Declarative configuration**: Define MCP servers in workflow configuration
- **Automatic registration**: Servers are automatically registered when workflow starts
- **Environment isolation**: Each workflow can have its own set of MCP servers
- **Configuration validation**: Validate MCP configurations at workflow start

### Agent Integration

Agents can seamlessly use MCP tools through the client manager:

```go
// Agent integration with MCP tools (using actual client interface)
func (a *Agent) executeMCPTool(ctx context.Context, mcpName, toolName string, args map[string]any) (any, error) {
    log := logger.FromContext(ctx)
    
    // Execute tool through MCP client
    result, err := a.mcpClient.CallTool(ctx, mcpName, toolName, args)
    if err != nil {
        log.Error("MCP tool execution failed", 
            "mcp", mcpName, 
            "tool", toolName, 
            "error", err)
        return nil, fmt.Errorf("tool execution failed: %w", err)
    }
    
    log.Info("MCP tool executed successfully", 
        "mcp", mcpName, 
        "tool", toolName)
    
    return result, nil
}
```

**Agent integration features:**
- **Direct tool access**: Agents call MCP tools using simple interface
- **Error handling**: Comprehensive error handling for tool execution
- **Context propagation**: Proper context propagation for cancellation
- **Result handling**: Flexible handling of tool execution results

## Best Practices

<Tabs items={["Configuration", "Error Handling", "Performance", "Monitoring"]}>

<Tab>
### Configuration Best Practices

<FeatureCardList cols={2} size="sm">
  <FeatureCard
    title="Environment Variables"
    description="Use environment variables for sensitive configuration"
    icon="Settings"
  />
  <FeatureCard
    title="Validation"
    description="Validate configurations before registration"
    icon="CheckCircle"
  />
  <FeatureCard
    title="Documentation"
    description="Document all configuration options"
    icon="FileText"
  />
  <FeatureCard
    title="Defaults"
    description="Provide sensible defaults for common configurations"
    icon="Layers"
  />
</FeatureCardList>

**Configuration recommendations:**
- Use environment variables for sensitive data like connection strings
- Validate all configuration parameters before server registration
- Document configuration options and their effects
- Provide sensible defaults to minimize configuration complexity

</Tab>

<Tab>
### Error Handling Best Practices

<FeatureCardList cols={2} size="sm">
  <FeatureCard
    title="Retry Logic"
    description="Implement appropriate retry strategies"
    icon="RefreshCw"
  />
  <FeatureCard
    title="Error Classification"
    description="Classify errors for appropriate handling"
    icon="AlertTriangle"
  />
  <FeatureCard
    title="Graceful Degradation"
    description="Provide fallback options for failures"
    icon="Shield"
  />
  <FeatureCard
    title="Monitoring"
    description="Monitor and alert on error patterns"
    icon="Monitor"
  />
</FeatureCardList>

**Error handling guidelines:**
- Implement exponential backoff for transient failures
- Classify errors to determine appropriate recovery strategies
- Provide graceful degradation when servers are unavailable
- Monitor error patterns to identify systemic issues

</Tab>

<Tab>
### Performance Best Practices

<FeatureCardList cols={2} size="sm">
  <FeatureCard
    title="Connection Reuse"
    description="Reuse connections through the proxy"
    icon="Network"
  />
  <FeatureCard
    title="Timeout Management"
    description="Set appropriate timeouts for operations"
    icon="Clock"
  />
  <FeatureCard
    title="Concurrent Operations"
    description="Use parallel processing where appropriate"
    icon="Zap"
  />
  <FeatureCard
    title="Resource Monitoring"
    description="Monitor resource usage and performance"
    icon="Gauge"
  />
</FeatureCardList>

**Performance recommendations:**
- Leverage connection pooling in the proxy for efficiency
- Set appropriate timeouts based on expected operation duration
- Use parallel processing for bulk operations
- Monitor resource usage to identify performance bottlenecks

</Tab>

<Tab>
### Monitoring Best Practices

<FeatureCardList cols={2} size="sm">
  <FeatureCard
    title="Health Checks"
    description="Implement regular health checks"
    icon="Activity"
  />
  <FeatureCard
    title="Metrics Collection"
    description="Collect performance and usage metrics"
    icon="BarChart3"
  />
  <FeatureCard
    title="Alerting"
    description="Set up alerts for critical issues"
    icon="Bell"
  />
  <FeatureCard
    title="Logging"
    description="Implement comprehensive logging"
    icon="FileText"
  />
</FeatureCardList>

**Monitoring guidelines:**
- Implement regular health checks for all registered servers
- Collect metrics on tool execution performance and success rates
- Set up alerts for server failures and performance degradation
- Use structured logging for debugging and operational visibility

</Tab>
</Tabs>

## Next Steps

<ReferenceCardList>
  <ReferenceCard
    title="MCP Overview"
    description="Understand the basics of MCP architecture"
    href="/docs/core/mcp/mcp-overview"
    icon="Network"
  />
  <ReferenceCard
    title="Admin API"
    description="Learn about MCP administrative operations"
    href="/docs/core/mcp/admin-api"
    icon="Settings"
  />
  <ReferenceCard
    title="Development & Debugging"
    description="Debug and develop MCP integrations"
    href="/docs/core/mcp/development-debugging"
    icon="Bug"
  />
  <ReferenceCard
    title="Integration Patterns"
    description="Explore common integration patterns"
    href="/docs/core/mcp/integration-patterns"
    icon="Workflow"
  />
</ReferenceCardList>