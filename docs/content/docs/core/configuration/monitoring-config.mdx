---
title: "Monitoring Configuration"
description: "Configure monitoring, metrics, and observability for Compozy applications with Prometheus integration, system health metrics, and performance tracking"
---

# Monitoring Configuration

Compozy provides comprehensive monitoring and observability features through Prometheus integration, system health metrics, and performance tracking. This guide covers monitoring configuration, metrics collection, and observability setup.

## Overview

The monitoring system in Compozy includes:

- **Prometheus Metrics**: Export application metrics in Prometheus format
- **System Health Metrics**: Track build information, uptime, and system status
- **HTTP Metrics**: Monitor API endpoint performance and usage
- **Temporal Metrics**: Track workflow execution and performance
- **Memory Metrics**: Monitor memory usage and operations
- **Custom Metrics**: Create application-specific metrics

## Configuration Structure

### Basic Monitoring Configuration

```yaml
# System-wide monitoring configuration
monitoring:
  enabled: true
  path: "/metrics"
  
# Server configuration with monitoring endpoint
server:
  host: "0.0.0.0"
  port: 8080
  cors_enabled: true
  timeout: 30s
```

### Environment Variables

Monitoring configuration can be controlled through environment variables:

```bash
# Enable/disable monitoring
export MONITORING_ENABLED=true

# Custom metrics endpoint path
export MONITORING_PATH="/custom-metrics"

# Server configuration
export SERVER_HOST="0.0.0.0"
export SERVER_PORT=8080
```

### Configuration Validation

The monitoring configuration includes validation rules:

```go
// Monitoring path validation
func (c *Config) Validate() error {
    if c.Path == "" {
        return fmt.Errorf("monitoring path cannot be empty")
    }
    if c.Path[0] != '/' {
        return fmt.Errorf("monitoring path must start with '/'")
    }
    if strings.HasPrefix(c.Path, "/api/") {
        return fmt.Errorf("monitoring path cannot be under /api/")
    }
    return nil
}
```

## Metrics Categories

### System Health Metrics

Track basic system information and health:

```yaml
# System metrics configuration
system_metrics:
  build_info: true      # Build version and commit hash
  uptime: true          # Service uptime in seconds
  go_version: true      # Go runtime version
```

**Available System Metrics:**
- `compozy_build_info`: Build information with version, commit, and Go version labels
- `compozy_uptime_seconds`: Service uptime in seconds

### HTTP Metrics

Monitor API endpoint performance:

```yaml
# HTTP metrics configuration
http_metrics:
  enabled: true
  track_requests: true
  track_duration: true
  track_response_size: true
```

**Available HTTP Metrics:**
- `http_requests_total`: Total number of HTTP requests
- `http_request_duration_seconds`: HTTP request duration
- `http_response_size_bytes`: HTTP response size

### Temporal Metrics

Monitor workflow execution:

```yaml
# Temporal metrics configuration
temporal_metrics:
  enabled: true
  track_workflows: true
  track_activities: true
  track_errors: true
```

**Available Temporal Metrics:**
- `temporal_workflow_executions_total`: Total workflow executions
- `temporal_workflow_duration_seconds`: Workflow execution duration
- `temporal_activity_executions_total`: Total activity executions

### Memory Metrics

Track memory system operations:

```yaml
# Memory metrics configuration
memory_metrics:
  enabled: true
  track_operations: true
  track_token_usage: true
  track_flush_operations: true
```

**Available Memory Metrics:**
- `memory_operations_total`: Total memory operations
- `memory_token_usage`: Token usage in memory instances
- `memory_flush_operations_total`: Total flush operations

## Service Configuration

### Monitoring Service Setup

```go
// Initialize monitoring service
func initMonitoring(ctx context.Context) (*monitoring.Service, error) {
    config := &monitoring.Config{
        Enabled: true,
        Path:    "/metrics",
    }
    
    service, err := monitoring.NewMonitoringService(ctx, config)
    if err != nil {
        return nil, fmt.Errorf("failed to initialize monitoring: %w", err)
    }
    
    return service, nil
}
```

### Graceful Degradation

The monitoring service supports graceful degradation:

```go
// Create monitoring service with fallback
service := monitoring.NewMonitoringServiceWithFallback(ctx, config)

// Check if monitoring is available
if service.IsInitialized() {
    log.Info("Monitoring initialized successfully")
} else {
    log.Warn("Monitoring failed to initialize", "error", service.InitializationError())
}
```

## Integration Patterns

### Gin Middleware Integration

```go
// Add monitoring middleware to Gin router
func setupRouter(monitoringService *monitoring.Service) *gin.Engine {
    router := gin.New()
    
    // Add monitoring middleware
    router.Use(monitoringService.GinMiddleware(ctx))
    
    // Add metrics endpoint
    router.GET("/metrics", gin.WrapH(monitoringService.ExporterHandler()))
    
    return router
}
```

### Temporal Interceptor Integration

```go
// Add monitoring interceptor to Temporal worker
func setupTemporalWorker(monitoringService *monitoring.Service) {
    worker := worker.New(client, "task-queue", worker.Options{
        Interceptors: []interceptor.WorkerInterceptor{
            monitoringService.TemporalInterceptor(ctx),
        },
    })
}
```

### Custom Metrics

Create application-specific metrics:

```go
// Create custom metrics
func createCustomMetrics(meter metric.Meter) error {
    // Counter for custom operations
    operationCounter, err := meter.Int64Counter(
        "custom_operations_total",
        metric.WithDescription("Total custom operations"),
    )
    if err != nil {
        return err
    }
    
    // Histogram for custom durations
    durationHistogram, err := meter.Float64Histogram(
        "custom_operation_duration_seconds",
        metric.WithDescription("Custom operation duration"),
    )
    if err != nil {
        return err
    }
    
    return nil
}
```

## Configuration Examples

### Development Environment

```yaml
# Development monitoring configuration
monitoring:
  enabled: true
  path: "/metrics"

server:
  host: "localhost"
  port: 8080
  cors_enabled: true
  timeout: 30s

# Enable detailed logging
logging:
  level: "debug"
  format: "json"
```

### Production Environment

```yaml
# Production monitoring configuration
monitoring:
  enabled: true
  path: "/metrics"

server:
  host: "0.0.0.0"
  port: 8080
  cors_enabled: false
  timeout: 60s

# Production logging
logging:
  level: "info"
  format: "json"
  structured: true
```

### Kubernetes Deployment

```yaml
# Kubernetes monitoring configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: compozy-monitoring-config
data:
  config.yaml: |
    monitoring:
      enabled: true
      path: "/metrics"
    server:
      host: "0.0.0.0"
      port: 8080
      timeout: 30s

---
apiVersion: v1
kind: Service
metadata:
  name: compozy-monitoring
  labels:
    app: compozy
spec:
  selector:
    app: compozy
  ports:
    - name: metrics
      port: 8080
      targetPort: 8080
      protocol: TCP
  type: ClusterIP
```

### Docker Compose

```yaml
# Docker Compose monitoring setup
version: '3.8'
services:
  compozy:
    image: compozy:latest
    ports:
      - "8080:8080"
    environment:
      - MONITORING_ENABLED=true
      - MONITORING_PATH=/metrics
      - SERVER_HOST=0.0.0.0
      - SERVER_PORT=8080
    volumes:
      - ./config:/app/config
      
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
```

## Prometheus Configuration

### Scrape Configuration

```yaml
# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'compozy'
    static_configs:
      - targets: ['localhost:8080']
    metrics_path: '/metrics'
    scrape_interval: 10s
    scrape_timeout: 10s
```

### Service Discovery

```yaml
# Kubernetes service discovery
scrape_configs:
  - job_name: 'compozy-k8s'
    kubernetes_sd_configs:
      - role: pod
    relabel_configs:
      - source_labels: [__meta_kubernetes_pod_label_app]
        action: keep
        regex: compozy
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
```

## Monitoring Best Practices

### 1. Metric Naming

Use consistent metric naming conventions:

```go
// Good metric names
"compozy_http_requests_total"
"compozy_workflow_duration_seconds"
"compozy_memory_operations_total"

// Avoid generic names
"requests"
"duration"
"operations"
```

### 2. Label Management

Use labels effectively:

```go
// Good label usage
operationCounter.Add(ctx, 1, 
    metric.WithAttributes(
        attribute.String("operation", "create"),
        attribute.String("status", "success"),
        attribute.String("service", "workflow"),
    ),
)

// Avoid high cardinality labels
// DON'T use user IDs, request IDs, or timestamps as labels
```

### 3. Performance Considerations

Monitor the monitoring system itself:

```go
// Check monitoring overhead
func monitoringMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        
        // Process request
        c.Next()
        
        // Record monitoring overhead
        monitoringDuration := time.Since(start)
        if monitoringDuration > 100*time.Millisecond {
            log.Warn("High monitoring overhead detected", 
                "duration", monitoringDuration)
        }
    }
}
```

### 4. Graceful Degradation

Handle monitoring failures gracefully:

```go
// Safe metric recording
func recordMetricSafely(meter metric.Meter, name string, value float64) {
    if meter == nil {
        return // No-op when monitoring is disabled
    }
    
    counter, err := meter.Float64Counter(name)
    if err != nil {
        log.Debug("Failed to create counter", "name", name, "error", err)
        return
    }
    
    counter.Add(context.Background(), value)
}
```

## Alerting Rules

### Prometheus Alerting Rules

```yaml
# alerting_rules.yml
groups:
  - name: compozy_alerts
    rules:
      - alert: CompozyServiceDown
        expr: up{job="compozy"} == 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Compozy service is down"
          description: "Compozy service has been down for more than 5 minutes"
      
      - alert: HighErrorRate
        expr: rate(compozy_http_requests_total{status=~"5.."}[5m]) > 0.1
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "High error rate detected"
          description: "Error rate is above 10% for 2 minutes"
      
      - alert: HighMemoryUsage
        expr: compozy_memory_operations_total > 1000
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "High memory operations detected"
          description: "Memory operations are above normal levels"
```

## Troubleshooting

### Common Issues

1. **Metrics endpoint not accessible:**
   ```bash
   # Check if monitoring is enabled
   curl -f http://localhost:8080/metrics
   
   # Verify configuration
   echo $MONITORING_ENABLED
   echo $MONITORING_PATH
   ```

2. **Missing metrics:**
   ```bash
   # Check service initialization
   grep "monitoring" /var/log/compozy/app.log
   
   # Verify metric registration
   curl -s http://localhost:8080/metrics | grep compozy_
   ```

3. **High monitoring overhead:**
   ```bash
   # Monitor monitoring performance
   curl -s http://localhost:8080/metrics | grep monitoring_duration
   ```

### Debug Configuration

```yaml
# Debug monitoring configuration
monitoring:
  enabled: true
  path: "/metrics"
  
logging:
  level: "debug"
  modules:
    - "monitoring"
    - "metrics"
```

## Next Steps

- Review [Health Checks](/docs/core/metrics/health-checks) for health monitoring
- Explore [Observability](/docs/core/metrics/observability) for distributed tracing
- Check [Security](/docs/core/metrics/security) for monitoring security considerations
- Study [Troubleshooting](/docs/core/metrics/troubleshooting) for common monitoring issues
