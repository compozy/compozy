---
title: Workflow Configuration
description: Configuring AI workflows with tasks, agents, and tools
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { Callout } from 'fumadocs-ui/components/callout';

# Workflow Configuration

Learn how to configure AI workflows that orchestrate agents, tools, and tasks in Compozy.

## Overview

**Workflows** are the core building blocks of Compozy projects that define task execution sequences. A workflow acts as a blueprint that:

- **Defines a sequence of tasks** to be executed with conditional branching
- **Coordinates AI agents** with specific instructions and capabilities
- **Integrates external tools** and Model Context Protocol (MCP) servers
- **Manages data flow** between tasks using Go template expressions
- **Handles scheduling** and triggering of automated executions
- **Validates inputs and outputs** according to defined JSON schemas

## Core Concepts

### Tasks
The building blocks of workflows. Each task performs a specific action using either an agent (AI-powered) or tool (deterministic function).

### Agents
AI models with specific instructions that can use tools and perform complex reasoning tasks.

### Tools
External programs or scripts that perform specific operations, like data processing, API calls, or file manipulation.

### MCP Servers
Model Context Protocol servers that extend AI capabilities with specialized tools and knowledge bases.

### Data Flow
Tasks can access outputs from previous tasks using template expressions like `{{ .tasks.previous-task.output.field }}`.

## Basic Workflow Structure

Here's a minimal workflow configuration:

```yaml
id: basic-workflow
version: "1.0.0"
description: "Basic AI workflow example"

config:
  input:
    type: object
    properties:
      message:
        type: string
        description: "Input message to process"
    required: ["message"]

tasks:
  - id: process-message
    type: basic
    $use: agent(local::agents.#(id="assistant"))
    with:
      prompt: "Process this message: {{ .workflow.input.message }}"
    final: true

outputs:
  result: "{{ .tasks.process-message.output }}"
```

## Complete Workflow Example

Here's a comprehensive workflow that demonstrates all major features:

<Tabs items={['workflow.yaml', 'agents/support-agent.yaml', 'tools/ticket-creator.ts']}>
  <Tab value="workflow.yaml">
```yaml
id: customer-support-workflow
version: "1.0.0"
description: "Automated customer support with ticket creation"

author:
  name: "Support Team"
  email: "support@example.com"

# Input validation schema
config:
  input:
    type: object
    properties:
      customer_email:
        type: string
        format: email
      issue_description:
        type: string
        minLength: 10
      priority:
        type: string
        enum: [low, medium, high, urgent]
        default: medium
    required: [customer_email, issue_description]

  # Environment variables
  env:
    SUPPORT_API_KEY: "{{ .env.SUPPORT_API_KEY }}"
    TICKET_SYSTEM_URL: "https://api.tickets.example.com"

# Reusable schemas
schemas:
  - id: ticket_response
    type: object
    properties:
      ticket_id:
        type: string
      status:
        type: string
        enum: [created, assigned, resolved]
      assigned_to:
        type: string
    required: [ticket_id, status]

# External tools
tools:
  - id: ticket-creator
    description: "Creates support tickets via API"
    input:
      type: object
      properties:
        email:
          type: string
          format: email
        description:
          type: string
        priority:
          type: string
          enum: [low, medium, high, urgent]
        category:
          type: string
      required: [email, description, priority]
    output:
      $ref: "local::schemas.#(id='ticket_response')"

# AI agents
agents:
  - id: support-agent
    config:
      provider: openai
      model: gpt-4
      temperature: 0.7
      max_tokens: 1000
    instructions: |
      You are a helpful customer support agent. Analyze customer issues,
      determine priority, and provide clear, empathetic responses.

      Always respond with:
      1. Issue category (technical, billing, feature_request, bug_report)
      2. Priority level (low, medium, high, urgent)
      3. Suggested resolution steps
      4. Whether human escalation is needed

    actions:
      - id: analyze_issue
        json_mode: true
        prompt: |
          Analyze this customer support request:

          Customer: {{ .workflow.input.customer_email }}
          Issue: {{ .workflow.input.issue_description }}

          Provide analysis in JSON format.
        output:
          type: object
          properties:
            category:
              type: string
              enum: [technical, billing, feature_request, bug_report]
            priority:
              type: string
              enum: [low, medium, high, urgent]
            resolution_steps:
              type: array
              items:
                type: string
            needs_human_escalation:
              type: boolean
            estimated_resolution_time:
              type: string
          required: [category, priority, resolution_steps, needs_human_escalation]

# MCP servers for extended capabilities
mcps:
  - id: knowledge-base
    transport: sse
    url: "http://localhost:3000/mcp"
    proto: "2025-03-26"
    env:
      KB_API_KEY: "{{ .env.KNOWLEDGE_BASE_API_KEY }}"

# Event triggers
triggers:
  - type: signal
    name: new-support-request
    schema:
      $ref: "local::config.input"

# Workflow tasks
tasks:
  - id: analyze-issue
    type: basic
    $use: agent(local::agents.#(id="support-agent"))
    with:
      action: analyze_issue
    on_success:
      next: check-escalation
    on_error:
      next: escalate-to-human

  - id: check-escalation
    type: router
    condition: '{{ .tasks.analyze-issue.output.needs_human_escalation }}'
    routes:
      "true":
        $ref: "local::tasks.#(id='escalate-to-human')"
      "false":
        $ref: "local::tasks.#(id='create-ticket')"

  - id: create-ticket
    type: basic
    $use: tool(local::tools.#(id="ticket-creator"))
    with:
      email: "{{ .workflow.input.customer_email }}"
      description: "{{ .workflow.input.issue_description }}"
      priority: "{{ .tasks.analyze-issue.output.priority }}"
      category: "{{ .tasks.analyze-issue.output.category }}"
    final: true

  - id: escalate-to-human
    type: basic
    $use: tool(local::tools.#(id="ticket-creator"))
    with:
      email: "{{ .workflow.input.customer_email }}"
      description: "ESCALATED: {{ .workflow.input.issue_description }}"
      priority: "urgent"
      category: "escalation"
      assign_to: "human-support-team"
    final: true

# Output mapping
outputs:
  ticket_id: "{{ .tasks.create-ticket.output.ticket_id || .tasks.escalate-to-human.output.ticket_id }}"
  status: "{{ .tasks.create-ticket.output.status || .tasks.escalate-to-human.output.status }}"
  category: "{{ .tasks.analyze-issue.output.category }}"
  priority: "{{ .tasks.analyze-issue.output.priority }}"
  resolution_steps: "{{ .tasks.analyze-issue.output.resolution_steps }}"
  escalated: "{{ .tasks.analyze-issue.output.needs_human_escalation }}"

# Automated schedule
schedule:
  cron: "0 */4 * * *"  # Every 4 hours
  timezone: "America/New_York"
  overlap_policy: buffer_one
  input:
    source: "scheduled_health_check"
    customer_email: "system@example.com"
    issue_description: "Automated system health check"
```
  </Tab>
  <Tab value="agents/support-agent.yaml">
```yaml
resource: agent
id: support-agent
description: "AI customer support agent"
version: "1.0.0"

config:
  provider: openai
  model: gpt-4
  temperature: 0.7
  max_tokens: 1000

instructions: |
  You are a helpful customer support agent with access to company knowledge base.

  Your role:
  - Analyze customer issues with empathy and professionalism
  - Categorize issues correctly (technical, billing, feature_request, bug_report)
  - Determine appropriate priority levels
  - Provide clear resolution steps
  - Escalate to humans when necessary

  Guidelines:
  - Always be polite and professional
  - Ask clarifying questions when needed
  - Reference company policies when relevant
  - Provide step-by-step solutions
  - Explain technical concepts in simple terms

tools:
  - $ref: "local::tools.#(id='knowledge-search')"

actions:
  - id: analyze_issue
    json_mode: true
    prompt: |
      Analyze this customer support request and provide structured analysis.

      Customer: {{ .workflow.input.customer_email }}
      Issue: {{ .workflow.input.issue_description }}

      Consider:
      1. Issue urgency and impact
      2. Available resolution options
      3. Required expertise level
      4. Estimated resolution time

    output:
      type: object
      properties:
        category:
          type: string
          enum: [technical, billing, feature_request, bug_report]
        priority:
          type: string
          enum: [low, medium, high, urgent]
        resolution_steps:
          type: array
          items:
            type: string
        needs_human_escalation:
          type: boolean
        estimated_resolution_time:
          type: string
        confidence_score:
          type: number
          minimum: 0
          maximum: 1
      required: [category, priority, resolution_steps, needs_human_escalation]
```
  </Tab>
  <Tab value="tools/ticket-creator.ts">
```typescript
interface TicketInput {
  email: string;
  description: string;
  priority: 'low' | 'medium' | 'high' | 'urgent';
  category: string;
  assign_to?: string;
}

interface TicketOutput {
  ticket_id: string;
  status: 'created' | 'assigned' | 'resolved';
  assigned_to?: string;
  created_at: string;
  url: string;
}

const TICKET_API_URL = process.env.TICKET_SYSTEM_URL || 'https://api.tickets.example.com';
const API_KEY = process.env.SUPPORT_API_KEY;

export default async function createTicket(input: TicketInput): Promise<TicketOutput> {
  if (!API_KEY) {
    throw new Error('SUPPORT_API_KEY environment variable is required');
  }

  const response = await fetch(`${TICKET_API_URL}/tickets`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${API_KEY}`,
    },
    body: JSON.stringify({
      title: `Support Request from ${input.email}`,
      description: input.description,
      priority: input.priority,
      category: input.category,
      reporter_email: input.email,
      assigned_to: input.assign_to,
    }),
  });

  if (!response.ok) {
    throw new Error(`Failed to create ticket: ${response.status} ${response.statusText}`);
  }

  const ticket = await response.json();

  return {
    ticket_id: ticket.id,
    status: ticket.assigned_to ? 'assigned' : 'created',
    assigned_to: ticket.assigned_to,
    created_at: ticket.created_at,
    url: `${TICKET_API_URL.replace('/api', '')}/tickets/${ticket.id}`,
  };
}
```
  </Tab>
</Tabs>

## Configuration Fields

### Core Workflow Information

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `id` | string | ✅ | Unique workflow identifier |
| `version` | string | ❌ | Semantic version |
| `description` | string | ❌ | Human-readable description |
| `author` | object | ❌ | Author information |

### Input Configuration

Define and validate workflow inputs:

```yaml
config:
  input:
    type: object
    properties:
      user_id:
        type: string
        description: "User identifier"
      message:
        type: string
        minLength: 1
        maxLength: 1000
      priority:
        type: string
        enum: [low, medium, high]
        default: medium
    required: [user_id, message]

  env:
    API_KEY: "{{ .env.API_KEY }}"
    DEBUG_MODE: "{{ .env.DEBUG_MODE | default \"false\" }}"
```

### Task Types

Compozy supports several task types for different execution patterns:

#### Basic Task
Executes a single agent or tool:

```yaml
- id: process-data
  type: basic
  $use: tool(local::tools.#(id="data-processor"))
  with:
    input_data: "{{ .workflow.input.data }}"
  on_success:
    next: next-task
```

#### Parallel Task
Executes multiple tasks concurrently:

```yaml
- id: parallel-processing
  type: parallel
  strategy: wait_all  # or race
  tasks:
    - id: task-a
      type: basic
      $use: tool(local::tools.#(id="tool-a"))
    - id: task-b
      type: basic
      $use: tool(local::tools.#(id="tool-b"))
```

#### Collection Task
Processes arrays of data:

```yaml
- id: process-items
  type: collection
  mode: parallel  # or sequential
  items: "{{ .workflow.input.items }}"
  task:
    id: "process-{{ .index }}"
    type: basic
    $use: tool(local::tools.#(id="item-processor"))
    with:
      item: "{{ .item }}"
      index: "{{ .index }}"
```

#### Router Task
Conditional branching based on conditions:

```yaml
- id: route-request
  type: router
  condition: '{{ .workflow.input.priority == "high" }}'
  routes:
    "true":
      $ref: "local::tasks.#(id='urgent-handler')"
    "false":
      $ref: "local::tasks.#(id='normal-handler')"
```

#### Composite Task
Groups multiple tasks together:

```yaml
- id: data-pipeline
  type: composite
  strategy: fail_fast
  tasks:
    - id: validate-data
      type: basic
      $use: tool(local::tools.#(id="validator"))
    - id: transform-data
      type: basic
      $use: tool(local::tools.#(id="transformer"))
    - id: save-data
      type: basic
      $use: tool(local::tools.#(id="saver"))
```

### Triggers and Scheduling

#### Signal Triggers
Enable webhook-style triggering:

```yaml
triggers:
  - type: signal
    name: user-action
    schema:
      type: object
      properties:
        action:
          type: string
          enum: [create, update, delete]
        user_id:
          type: string
      required: [action, user_id]
```

#### Scheduled Execution
Run workflows on a schedule:

```yaml
schedule:
  cron: "0 9 * * MON-FRI"  # 9 AM on weekdays
  timezone: "America/New_York"
  enabled: true
  jitter: "5m"
  overlap_policy: skip
  input:
    source: "scheduled"
    priority: "normal"
```

**Overlap Policies:**
- `skip`: Skip if previous execution is running (default)
- `allow`: Allow concurrent executions
- `buffer_one`: Queue one execution
- `cancel_other`: Cancel running and start new

## Template Expressions

Use Go template syntax for dynamic data access:

### Common Template Patterns

```yaml
# Workflow input
"{{ .workflow.input.field }}"

# Task output
"{{ .tasks.task-id.output.field }}"

# Environment variables
"{{ .env.API_KEY }}"

# Conditional expressions
'{{ .workflow.input.priority == "high" | ternary "urgent" "normal" }}'

# Array operations
"{{ len .workflow.input.items }}"
"{{ index .workflow.input.items 0 }}"

# String operations
"{{ .workflow.input.message | upper }}"
"{{ .workflow.input.message | truncate 100 }}"

# Default values
"{{ .workflow.input.optional_field | default \"default_value\" }}"
```

### Template Functions

| Function | Description | Example |
|----------|-------------|---------|
| `default` | Provide default value | `{{ .field \| default "default" }}` |
| `empty` | Check if empty | `{{ .field \| empty }}` |
| `len` | Get length | `{{ len .array }}` |
| `upper` | Convert to uppercase | `{{ .text \| upper }}` |
| `lower` | Convert to lowercase | `{{ .text \| lower }}` |
| `truncate` | Truncate string | `{{ .text \| truncate 100 }}` |
| `ternary` | Conditional expression | `{{ condition \| ternary "true" "false" }}` |

## Best Practices

### Workflow Design

1. **Single Responsibility**: Each workflow should have a clear, single purpose
2. **Error Handling**: Always define error handling paths
3. **Validation**: Use input schemas to validate data
4. **Documentation**: Include comprehensive descriptions

### Performance

1. **Parallel Processing**: Use parallel tasks for independent operations
2. **Conditional Execution**: Use router tasks to avoid unnecessary processing
3. **Resource Management**: Set appropriate timeouts and limits
4. **Caching**: Cache expensive operations when possible

### Security

1. **Environment Variables**: Use environment variables for sensitive data
2. **Input Validation**: Always validate external inputs
3. **Permission Restrictions**: Grant minimal required permissions
4. **Monitoring**: Log security-relevant events

### Debugging

1. **Structured Outputs**: Use structured output schemas
2. **Logging**: Include relevant context in logs
3. **Testing**: Test workflows with various input scenarios
4. **Monitoring**: Track execution metrics and errors

## Common Patterns

### Data Processing Pipeline

```yaml
tasks:
  - id: validate-input
    type: basic
    $use: tool(local::tools.#(id="validator"))

  - id: process-data
    type: collection
    items: "{{ .workflow.input.items }}"
    task:
      type: basic
      $use: tool(local::tools.#(id="processor"))

  - id: aggregate-results
    type: basic
    $use: tool(local::tools.#(id="aggregator"))
    with:
      results: "{{ .tasks.process-data.output }}"
```

### Error Handling with Fallbacks

```yaml
- id: primary-service
  type: basic
  $use: tool(local::tools.#(id="primary-api"))
  on_error:
    next: fallback-service

- id: fallback-service
  type: basic
  $use: tool(local::tools.#(id="fallback-api"))
  on_error:
    next: manual-intervention
```

### Multi-Agent Collaboration

```yaml
- id: researcher
  type: basic
  $use: agent(local::agents.#(id="research-agent"))
  with:
    topic: "{{ .workflow.input.topic }}"

- id: writer
  type: basic
  $use: agent(local::agents.#(id="writing-agent"))
  with:
    research_data: "{{ .tasks.researcher.output }}"
    style: "{{ .workflow.input.writing_style }}"

- id: reviewer
  type: basic
  $use: agent(local::agents.#(id="review-agent"))
  with:
    content: "{{ .tasks.writer.output }}"
    criteria: "{{ .workflow.input.review_criteria }}"
```

## Next Steps

- Learn about [Runtime Configuration](/docs/core/configuration/runtime-config)
- Configure [LLM Providers](/docs/core/configuration/providers)
- Set up [AutoLoad](/docs/core/configuration/autoload)
- Explore [Agent Configuration](/docs/core/agents/overview)
