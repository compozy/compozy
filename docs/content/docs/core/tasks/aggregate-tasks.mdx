---
title: Aggregate Tasks
description: Aggregate tasks collect and combine results from multiple predecessor tasks, enabling sophisticated data transformation and result synthesis. They serve as collection points in workflows where outputs from different task branches need to be merged, calculated, or restructured.
---

## Overview

Aggregate tasks provide powerful result combination capabilities:

<List>
  <ListItem title="Result Consolidation" icon="Layers">
    Merge outputs from multiple tasks into unified structures
  </ListItem>
  <ListItem title="Data Transformation" icon="Shuffle">
    Apply complex transformations and calculations
  </ListItem>
  <ListItem title="Conditional Logic" icon="GitBranch">
    Use dynamic conditions to shape output based on task results
  </ListItem>
  <ListItem title="Template Expressions" icon="Code">
    Leverage full template power for result manipulation
  </ListItem>
  <ListItem title="Hierarchical Results" icon="FolderTree">
    Access outputs from nested task structures
  </ListItem>
  <ListItem title="Performance Optimization" icon="Zap">
    Efficient result processing without additional execution overhead
  </ListItem>
</List>

<Callout type="info" className="mt-8">
Aggregate tasks are execution-free - they only transform and combine existing results without calling agents or tools, making them extremely efficient for result processing.
</Callout>

## Task Structure

### Basic Aggregate Task

```yaml
id: combine-results
type: aggregate

outputs:
  # Simple field mapping
  total_count: "{{ add .tasks.task1.output.count .tasks.task2.output.count }}"

  # Complex object construction
  summary:
    user_data: "{{ .tasks.user_analysis.output }}"
    preferences: "{{ .tasks.preference_analysis.output }}"
    recommendations: "{{ .tasks.generate_recommendations.output }}"

  # Conditional outputs
  status: "{{ if gt .tasks.validation.output.errors 0 }}needs_review{{ else }}approved{{ end }}"

  # Array operations
  all_results: "{{ concat .tasks.task1.output.items .tasks.task2.output.items }}"

on_success:
  next: final-processing
```

### Key Features

<Tabs items={["Data Merging", "Calculations", "Conditional Logic", "Array Operations"]}>
<Tab value="Data Merging">

Combine results from multiple tasks:

```yaml
id: merge-user-data
type: aggregate

outputs:
  # Merge user profile information
  complete_profile:
    # Basic information
    id: "{{ .tasks.fetch_user.output.id }}"
    name: "{{ .tasks.fetch_user.output.name }}"
    email: "{{ .tasks.fetch_user.output.email }}"

    # Enhanced data from different sources
    preferences: "{{ .tasks.get_preferences.output }}"
    activity_history: "{{ .tasks.get_activity.output }}"
    recommendations: "{{ .tasks.generate_recommendations.output }}"

    # Computed fields
    profile_completeness: "{{ .tasks.analyze_profile.output.completeness_score }}"
    last_updated: "{{ now }}"

  # Merge with conflict resolution
  contact_info:
    primary_email: "{{ .tasks.fetch_user.output.email }}"
    secondary_email: "{{ .tasks.get_preferences.output.backup_email | default .tasks.fetch_user.output.email }}"
    phone: "{{ .tasks.fetch_user.output.phone | default .tasks.get_preferences.output.phone }}"

    # Validation status
    email_verified: "{{ and .tasks.fetch_user.output.email_verified .tasks.validate_email.output.valid }}"
    phone_verified: "{{ .tasks.validate_phone.output.valid | default false }}"

  # Metadata about the aggregation
  aggregation_metadata:
    sources_used: ["fetch_user", "get_preferences", "get_activity", "generate_recommendations"]
    aggregation_time: "{{ now }}"
    data_freshness:
      user_data: "{{ .tasks.fetch_user.output.last_updated }}"
      preferences: "{{ .tasks.get_preferences.output.last_updated }}"
      activity: "{{ .tasks.get_activity.output.last_updated }}"
```

</Tab>
<Tab value="Calculations">

Perform calculations on task results:

```yaml
id: calculate-metrics
type: aggregate

outputs:
  # Basic arithmetic
  total_revenue: "{{ add .tasks.sales_q1.output.revenue .tasks.sales_q2.output.revenue .tasks.sales_q3.output.revenue .tasks.sales_q4.output.revenue }}"

  # Average calculations
  average_response_time: "{{ div (add .tasks.api_test1.output.response_time .tasks.api_test2.output.response_time .tasks.api_test3.output.response_time) 3 }}"

  # Percentage calculations
  success_rate: "{{ div (mul .tasks.test_results.output.passed_tests 100) .tasks.test_results.output.total_tests }}"

  # Complex mathematical operations
  growth_rate: "{{ div (sub .tasks.current_metrics.output.value .tasks.previous_metrics.output.value) .tasks.previous_metrics.output.value }}"

  # Statistical calculations
  performance_metrics:
    min_response_time: "{{ min .tasks.load_test.output.response_times }}"
    max_response_time: "{{ max .tasks.load_test.output.response_times }}"
    average_response_time: "{{ div (sum .tasks.load_test.output.response_times) (len .tasks.load_test.output.response_times) }}"

    # Standard deviation approximation
    variance: "{{ variance .tasks.load_test.output.response_times }}"

  # Financial calculations
  financial_summary:
    gross_profit: "{{ sub .tasks.revenue.output.total .tasks.costs.output.total }}"
    profit_margin: "{{ div (sub .tasks.revenue.output.total .tasks.costs.output.total) .tasks.revenue.output.total }}"
    roi: "{{ div (sub .tasks.revenue.output.total .tasks.investment.output.total) .tasks.investment.output.total }}"
```

</Tab>
<Tab value="Conditional Logic">

Use conditions to create dynamic outputs:

```yaml
id: conditional-aggregation
type: aggregate

outputs:
  # Simple conditional
  processing_status: "{{ if .tasks.validation.output.errors }}failed{{ else }}success{{ end }}"

  # Complex conditional logic
  recommendation_level: |
    {{
      if (gt .tasks.risk_analysis.output.risk_score 0.8)
        "high_risk"
      else if (gt .tasks.risk_analysis.output.risk_score 0.5)
        "medium_risk"
      else
        "low_risk"
    }}

  # Conditional object creation
  notification_config:
    should_notify: "{{ gt .tasks.anomaly_detection.output.anomalies 0 }}"
    urgency: |
      {{
        if (gt .tasks.anomaly_detection.output.critical_anomalies 0)
          "critical"
        else if (gt .tasks.anomaly_detection.output.warning_anomalies 0)
          "warning"
        else
          "info"
      }}
    channels: |
      {{
        if (gt .tasks.anomaly_detection.output.critical_anomalies 0)
          ["email", "sms", "slack"]
        else if (gt .tasks.anomaly_detection.output.warning_anomalies 0)
          ["email", "slack"]
        else
          ["email"]
      }}

  # Conditional array building
  action_items: |
    {{
      $items := list
      if (gt .tasks.security_scan.output.vulnerabilities 0)
        $items = append $items (dict "type" "security" "priority" "high" "description" "Address security vulnerabilities")
      end
      if (lt .tasks.performance_test.output.score 0.7)
        $items = append $items (dict "type" "performance" "priority" "medium" "description" "Optimize performance")
      end
      if (gt .tasks.quality_check.output.code_smells 5)
        $items = append $items (dict "type" "quality" "priority" "low" "description" "Refactor code quality issues")
      end
      $items
    }}
```

</Tab>
<Tab value="Array Operations">

Manipulate arrays and collections:

```yaml
id: array-operations
type: aggregate

outputs:
  # Array concatenation
  all_items: "{{ concat .tasks.fetch_set1.output.items .tasks.fetch_set2.output.items .tasks.fetch_set3.output.items }}"

  # Array filtering
  active_users: "{{ filter .tasks.get_users.output.users 'status' 'eq' 'active' }}"
  high_priority_tasks: "{{ filter .tasks.get_tasks.output.tasks 'priority' 'eq' 'high' }}"

  # Array transformation
  user_emails: "{{ map .tasks.get_users.output.users 'email' }}"
  task_ids: "{{ map .tasks.get_tasks.output.tasks 'id' }}"

  # Array aggregation
  total_items: "{{ len (concat .tasks.fetch_set1.output.items .tasks.fetch_set2.output.items) }}"
  unique_categories: "{{ unique (map .tasks.get_products.output.products 'category') }}"

  # Array sorting
  sorted_by_priority: "{{ sort .tasks.get_tasks.output.tasks 'priority' 'desc' }}"
  sorted_by_date: "{{ sort .tasks.get_events.output.events 'date' 'asc' }}"

  # Array grouping
  users_by_role: "{{ group .tasks.get_users.output.users 'role' }}"
  tasks_by_status: "{{ group .tasks.get_tasks.output.tasks 'status' }}"

  # Array slicing
  top_10_results: "{{ take 10 .tasks.search_results.output.results }}"
  recent_activities: "{{ take 20 (sort .tasks.get_activities.output.activities 'timestamp' 'desc') }}"

  # Complex array operations
  user_statistics: |
    {{
      $users := .tasks.get_users.output.users
      dict
        "total_users" (len $users)
        "active_users" (len (filter $users 'status' 'eq' 'active'))
        "premium_users" (len (filter $users 'subscription' 'eq' 'premium'))
        "new_users_this_month" (len (filter $users 'created_at' 'gt' (dateAdd "2024-01-01" "720h")))
        "roles_distribution" (group $users 'role')
    }}
```

</Tab>
</Tabs>

## Access Patterns

### Task Output Access

Access results from different task types:

```yaml
id: access-patterns
type: aggregate

outputs:
  # Basic task outputs
  basic_result: "{{ .tasks.basic_task.output }}"

  # Parallel task outputs
  parallel_results:
    task1: "{{ .tasks.parallel_task.output.task1 }}"
    task2: "{{ .tasks.parallel_task.output.task2 }}"
    all_parallel: "{{ .tasks.parallel_task.output }}"

  # Collection task outputs
  collection_summary:
    processed_items: "{{ .tasks.collection_task.output }}"
    item_count: "{{ len .tasks.collection_task.output }}"
    successful_items: "{{ filter .tasks.collection_task.output 'status' 'eq' 'success' }}"

  # Composite task outputs
  composite_results:
    subtask1: "{{ .tasks.composite_task.output.subtask1 }}"
    subtask2: "{{ .tasks.composite_task.output.subtask2 }}"
    all_subtasks: "{{ .tasks.composite_task.output }}"

  # Nested task access
  nested_data: "{{ .tasks.parent_task.children.child_task.output }}"
```

### Complex Data Structures

Handle complex nested structures:

```yaml
id: complex-structures
type: aggregate

outputs:
  # Nested object construction
  comprehensive_report:
    executive_summary:
      total_revenue: "{{ .tasks.financial_analysis.output.revenue }}"
      growth_rate: "{{ .tasks.growth_analysis.output.rate }}"
      key_metrics: "{{ .tasks.kpi_analysis.output.metrics }}"

    detailed_analysis:
      financial_breakdown: "{{ .tasks.financial_analysis.output }}"
      market_analysis: "{{ .tasks.market_analysis.output }}"
      competitor_analysis: "{{ .tasks.competitor_analysis.output }}"

    recommendations:
      short_term: "{{ .tasks.recommendations.output.short_term }}"
      long_term: "{{ .tasks.recommendations.output.long_term }}"
      risk_mitigation: "{{ .tasks.risk_analysis.output.mitigation_strategies }}"

    appendices:
      raw_data: "{{ .tasks.data_collection.output }}"
      methodology: "{{ .tasks.analysis_metadata.output.methodology }}"
      assumptions: "{{ .tasks.analysis_metadata.output.assumptions }}"

  # Dynamic structure based on available data
  flexible_output: |
    {{
      $output := dict
      if .tasks.user_data.output
        $output = set $output "user_info" .tasks.user_data.output
      end
      if .tasks.preferences.output
        $output = set $output "preferences" .tasks.preferences.output
      end
      if .tasks.activity.output
        $output = set $output "activity" .tasks.activity.output
      end
      $output
    }}
```

## Best Practices

<List>
  <ListItem title="Access Task Results Efficiently" icon="Target">
    Use dot notation for simple access, complex expressions for transformations
  </ListItem>
  <ListItem title="Handle Missing Data" icon="ShieldCheck">
    Always check for null/undefined values before processing
  </ListItem>
  <ListItem title="Use Conditional Logic" icon="Split">
    Implement fallbacks and default values for robust operation
  </ListItem>
  <ListItem title="Optimize Complex Operations" icon="Gauge">
    Cache frequently accessed values
  </ListItem>
  <ListItem title="Structure Output Logically" icon="Layout">
    Organize outputs in a way that's easy for downstream tasks to consume
  </ListItem>
  <ListItem title="Document Complex Logic" icon="FileText">
    Use comments in template expressions for complex calculations
  </ListItem>
</List>

## References

<ReferenceCardList>
  <ReferenceCard
    title="Basic Tasks"
    description="Master the fundamental building blocks that feed into aggregate tasks"
    href="/docs/core/tasks/basic-tasks"
    icon="Cog"
  />
  <ReferenceCard
    title="Collection Tasks"
    description="Learn to process arrays and collections that aggregate tasks can combine"
    href="/docs/core/tasks/collection-tasks"
    icon="Grid"
  />
  <ReferenceCard
    title="Parallel Processing"
    description="Execute multiple tasks simultaneously for aggregate processing"
    href="/docs/core/tasks/parallel-processing"
    icon="Zap"
  />
  <ReferenceCard
    title="Template Expressions"
    description="Master template expressions for complex data transformations"
    href="/docs/core/yaml-templates/context-variables"
    icon="Code"
  />
</ReferenceCardList>

Aggregate tasks provide powerful capabilities for combining and transforming results from multiple tasks, enabling sophisticated data processing patterns in your Compozy workflows.
