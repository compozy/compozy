---
title: Router Tasks
description: Implement conditional branching and intelligent workflow routing with router tasks in Compozy workflows
---

Router tasks are the **decision engine** of Compozy workflows, enabling dynamic routing based on runtime conditions. They evaluate template expressions and direct workflow execution down different paths, making workflows intelligent and adaptive to varying data conditions. When combined with [basic tasks](/docs/core/tasks/basic-tasks) and [parallel processing](/docs/core/tasks/parallel-processing), router tasks create sophisticated automation that can handle complex business logic automatically.

## Key Benefits

<FeatureCardList cols={2} size="default">
  <FeatureCard
    title="Intelligent Decision Making"
    description="Evaluate complex conditions using template expressions to automatically route workflows based on data, user context, or business rules"
    icon="GitBranch"
  />
  <FeatureCard
    title="Flexible Route Definitions"
    description="Define routes as simple task references or complex inline configurations with full task orchestration capabilities"
    icon="Network"
  />
  <FeatureCard
    title="Robust Fallback Handling"
    description="Built-in default routes and comprehensive error handling ensure workflows gracefully handle unexpected conditions"
    icon="Shield"
  />
  <FeatureCard
    title="Business Logic Integration"
    description="Implement approval workflows, feature flags, content moderation, and complex business rules declaratively"
    icon="Settings"
  />
</FeatureCardList>

## How Router Tasks Work

<List className="mt-6">
  <ListItem title="Condition Evaluation" icon="Calculator">
    Router tasks evaluate template expressions against workflow context, task outputs, and input data to determine the routing path
  </ListItem>
  <ListItem title="Route Resolution" icon="Map">
    The condition result becomes a key to look up the target route, which can reference existing tasks or define inline configurations
  </ListItem>
  <ListItem title="Dynamic Execution" icon="Zap">
    Based on the route selection, the workflow executes different task paths, enabling completely different business logic flows
  </ListItem>
  <ListItem title="State Management" icon="Database">
    Router execution state and route decisions are tracked by deployment options for durability and debugging
  </ListItem>
</List>

<Callout type="info" className="mt-8">
  Router tasks leverage the same [template engine](/docs/core/yaml-templates/overview) used throughout Compozy, providing access to workflow input, task outputs, environment variables, and utility functions for comprehensive decision-making capabilities.
</Callout>

## Task Structure

Understanding router task configuration is essential for building effective conditional workflows. Router tasks must define a condition expression and route mappings, with optional default and error handling strategies.

<Callout type="warning">
Before implementing router tasks, ensure you understand [basic task configuration](/docs/core/tasks/basic-tasks) and template expressions. Router tasks build on these foundational concepts.
</Callout>

### Core Configuration

Every router task follows this fundamental structure:

```yaml
id: router-name
type: router
condition: "{{ .tasks.previous_task.output.result }}"

routes:
  route_key_1: target-task-id
  route_key_2:
    type: basic
    agent: handler
    with:
      data: "{{ .workflow.input.data }}"
  route_key_3: another-task-id

# Optional fallback route
default: default-handler

# Error handling
on_error:
  next: error-handler
```

<List className="mt-4">
  <ListItem title="condition" icon="Code">
    Template expression that evaluates to determine routing. Can access workflow input, task outputs, and environment variables
  </ListItem>
  <ListItem title="routes" icon="GitBranch">
    Map of condition results to target tasks. Values can be task IDs (string) or inline task configurations (object)
  </ListItem>
  <ListItem title="default" icon="ArrowDown">
    Fallback route when condition result doesn't match any route key. Essential for robust error handling
  </ListItem>
  <ListItem title="on_error" icon="AlertTriangle">
    Error handling configuration when condition evaluation fails. Links to [error handling patterns](/docs/core/tasks/basic-tasks#error-handling)
  </ListItem>
</List>

### Key Components

Router tasks support multiple configuration patterns, from simple routing to complex business logic. Understanding these patterns helps you choose the right approach for your use case.

<AccordionGroup>
<Accordion title="Basic Routing" description="Simple condition-based routing with task references for straightforward decision making">

The simplest router pattern uses string conditions and task ID references. This approach works well for straightforward routing decisions and integrates seamlessly with workflow task definitions:

```yaml
id: document-classifier
type: router
condition: "{{ .tasks.analyze.output.type }}"

routes:
  invoice: process-invoice
  contract: process-contract
  receipt: process-receipt
  unknown: manual-review

with:
  document: "{{ .workflow.input.document }}"
  confidence_threshold: 0.8

on_error:
  next: retry-classification
```

<List className="mt-4">
  <ListItem title="Simple Conditions" icon="Hash">
    Use direct template expressions that evaluate to string values matching route keys
  </ListItem>
  <ListItem title="Task References" icon="Link">
    Route values are task IDs that reference other tasks defined in the same workflow or shared task libraries
  </ListItem>
  <ListItem title="Minimal Configuration" icon="Minimize2">
    Clean, readable configuration ideal for simple business logic and getting started with router tasks
  </ListItem>
</List>

</Accordion>

<Accordion title="Complex Conditions" description="Advanced conditional logic with multi-factor decision making and business rules">

For sophisticated routing logic, use multi-line template expressions with variables and conditional operators. This pattern excels at implementing complex workflow examples:

```yaml
id: approval-router
type: router
condition: |
  {{
    $amount := .tasks.calculate_total.output.amount
    $user := .workflow.input.user
    $category := .workflow.input.category

    if (and (gt $amount 10000) (eq $category "restricted"))
      "executive"
    else if (gt $amount 5000)
      "manager"
    else if (eq $category "compliance")
      "compliance_review"
    else if (lt $amount 100)
      "auto_approve"
    else
      "standard_review"
  }}

routes:
  executive:
    type: signal
    signal:
      id: executive-approval-required
      payload:
        amount: "{{ .tasks.calculate_total.output.amount }}"
        user: "{{ .workflow.input.user }}"
        urgency: high

  manager:
    type: basic
    agent: manager-approver
    with:
      request: "{{ .workflow.input }}"
      amount: "{{ .tasks.calculate_total.output.amount }}"

  compliance_review: compliance-workflow
  auto_approve: auto-approve-task
  standard_review: standard-approval-task

default: escalation-handler
```

<List className="mt-4">
  <ListItem title="Multi-Line Expressions" icon="FileText">
    Use YAML literal block syntax (`|`) for complex conditional logic with variables and functions
  </ListItem>
  <ListItem title="Variable Assignment" icon="Variable">
    Assign intermediate values for cleaner logic using template template expressions
  </ListItem>
  <ListItem title="Business Rules" icon="Shield">
    Implement approval thresholds, compliance checks, and multi-factor decision making declaratively
  </ListItem>
</List>

</Accordion>

<Accordion title="Inline Tasks" description="Define complete task configurations directly within routes for specialized processing">

Inline task definitions provide maximum flexibility by embedding complete task configurations within routes. This pattern works excellently with [collection tasks](/docs/core/tasks/collection-tasks) and [parallel processing](/docs/core/tasks/parallel-processing):

```yaml
id: content-router
type: router
condition: "{{ .tasks.analyze_content.output.content_type }}"

routes:
  text:
    type: basic
    agent: text-processor
    action: process_text
    with:
      content: "{{ .workflow.input.content }}"
      format: "{{ .workflow.input.format }}"

  image:
    type: basic
    tool: image-processor
    with:
      image_data: "{{ .workflow.input.content }}"
      operations:
        - resize: "800x600"
        - format: "webp"

  video:
    type: collection
    items: "{{ .workflow.input.video_segments }}"
    task:
      type: basic
      tool: video-processor
      with:
        segment: "{{ .item }}"
        quality: "{{ .workflow.input.quality }}"

default:
    type: basic
    agent: generic-processor
    action: process_unknown
    with:
      content: "{{ .workflow.input.content }}"
      type: "{{ .tasks.analyze_content.output.content_type }}"
```

<List className="mt-4">
  <ListItem title="Full Task Configurations" icon="Settings">
    Embed complete task definitions including agents, tools, and specialized configurations
  </ListItem>
  <ListItem title="Context-Specific Logic" icon="Target">
    Tailor task behavior precisely to the routing condition without creating separate task definitions
  </ListItem>
  <ListItem title="Nested Task Types" icon="Layers">
    Use any task type including [collection](/docs/core/tasks/collection-tasks) and [parallel](/docs/core/tasks/parallel-processing) within routes
  </ListItem>
</List>

</Accordion>

<Accordion title="Error Handling" description="Comprehensive error handling and fallback strategies for production-ready workflows">

Robust error handling is essential for production workflows. Router tasks support multiple error handling strategies at both the router and individual route levels:

```yaml
id: resilient-router
type: router
condition: "{{ .tasks.classify_request.output.category }}"

routes:
  urgent:
    type: basic
    agent: urgent-handler
    with:
      request: "{{ .workflow.input.request }}"
      priority: high

    # Task-level error handling
    on_error:
      next: urgent-escalation
      with:
        original_request: "{{ .workflow.input.request }}"
        error_details: "{{ .task.error }}"

  standard: standard-processor

  bulk:
    type: collection
    items: "{{ .workflow.input.batch_items }}"
    strategy: best_effort
    task:
      type: basic
      tool: batch-processor
      with:
        item: "{{ .item }}"

# Router-level error handling
on_error:
  next: router-error-handler
  with:
    condition_result: "{{ .task.condition_result }}"
    available_routes: "{{ .task.available_routes }}"
    error_type: "{{ .task.error.type }}"

# Default route when no condition matches
default:
  type: basic
  agent: default-handler
  action: handle_unknown
  with:
    request: "{{ .workflow.input.request }}"
    classification: "{{ .tasks.classify_request.output }}"

# Global timeout settings
timeout: 5m
retry_policy:
  maximum_attempts: 2
  initial_interval: 1s
  maximum_interval: 10s
```

<List className="mt-4">
  <ListItem title="Multi-Level Error Handling" icon="AlertTriangle">
    Configure error handling at router, route, and task levels using [standard error handling patterns](/docs/core/tasks/basic-tasks#error-handling)
  </ListItem>
  <ListItem title="Default Routes" icon="ArrowDown">
    Always provide default routes to handle unexpected condition results gracefully
  </ListItem>
  <ListItem title="Timeout & Retries" icon="RotateCcw">
    Use timeout and retry policies compatible with deployment options
  </ListItem>
</List>

</Accordion>
</AccordionGroup>

## Behind the Scenes

Understanding how router tasks execute helps optimize performance and debug issues. When a router task runs, it follows a sophisticated evaluation and execution pipeline that integrates with Compozy's template engine and task orchestration system.

<Mermaid chart={`sequenceDiagram
    participant WE as Workflow Engine
    participant RT as Router Task
    participant TE as Template Engine
    participant TM as Task Manager
    participant Agent as AI Agent/Tool
    participant DB as State Store

    WE->>RT: Execute Router Task
    Note over RT: Gather execution context
    RT->>RT: Collect workflow input, task outputs, env vars

    RT->>TE: Evaluate condition expression
    TE->>TE: Process template with context
    TE-->>RT: Return condition result (e.g., "approved")

    RT->>RT: Look up route for "approved"
    alt Route is Task ID
        RT->>TM: Execute referenced task
        TM->>Agent: Run task
        Agent-->>TM: Return result
        TM-->>RT: Task completed
    else Route is Inline Config
        RT->>RT: Build task configuration
        RT->>TM: Execute inline task
        TM->>Agent: Run inline task
        Agent-->>TM: Return result
        TM-->>RT: Task completed
    else No Route Match
        RT->>TM: Execute default route
        TM->>Agent: Run default task
        Agent-->>TM: Return result
        TM-->>RT: Task completed
    end

    RT->>DB: Store routing decision & result
    RT-->>WE: Return router result

    Note over DB: Routing decisions logged for debugging`} />

<List className="mt-6">
  <ListItem title="Context Collection" icon="Database">
    Router tasks gather workflow input, previous task outputs, and environment variables to provide complete context for condition evaluation
  </ListItem>
  <ListItem title="Template Processing" icon="Code">
    The [template engine](/docs/core/yaml-templates/overview) evaluates conditions with access to all workflow state and utility functions
  </ListItem>
  <ListItem title="Route Resolution" icon="Map">
    Route lookup supports both task ID references and inline task configurations, enabling flexible workflow design patterns
  </ListItem>
  <ListItem title="Task Execution" icon="Play">
    Selected routes execute using the same [task execution pipeline](/docs/core/tasks/basic-tasks) as regular workflow tasks
  </ListItem>
  <ListItem title="State Persistence" icon="Save">
    Routing decisions and execution results are persisted by deployment options for durability and observability
  </ListItem>
</List>

## Conditional Routing Patterns

Router tasks excel at implementing complex business logic through template expressions. These patterns demonstrate common approaches for different types of conditional logic.

### Template Expression Routing

The most common pattern uses template expressions to evaluate data and determine routing paths. This approach leverages Compozy's template expressions for powerful data processing:

```yaml
id: weather-activity-router
type: router
condition: |
  {{
    $weather := .tasks.get_weather.output
    $temperature := $weather.temperature
    $conditions := $weather.conditions

    if (lt $temperature 32)
      "cold"
    else if (and (gt $temperature 75) (eq $conditions "sunny"))
      "hot_sunny"
    else if (contains $conditions "rain")
      "rainy"
    else
      "moderate"
  }}

routes:
  cold:
    type: basic
    agent: activity-suggester
    with:
      weather_type: "cold"
      suggestions: ["indoor activities", "warm clothing", "hot drinks"]

  hot_sunny:
    type: basic
    agent: activity-suggester
    with:
      weather_type: "hot"
      suggestions: ["swimming", "beach", "air conditioning"]

  rainy:
    type: basic
    agent: activity-suggester
    with:
      weather_type: "rainy"
      suggestions: ["indoor activities", "umbrella", "movies"]

  moderate: moderate-weather-activities
```

This pattern demonstrates how router tasks can implement intelligent decision-making by analyzing task outputs and applying business rules to determine appropriate actions.

### Multi-Factor Routing

Route based on multiple conditions:

```yaml
id: user-onboarding-router
type: router
condition: |
  {{
    $user := .tasks.get_user.output
    if (eq $user.account_type "premium")
      "premium_user"
    else if (eq $user.verification_status "pending")
      "pending_verification"
    else
      "standard_user"
  }}

routes:
  premium_user:
    type: basic
    agent: premium-onboarding
    with:
      user_data: "{{ .tasks.get_user.output }}"

  pending_verification: verification-workflow
  standard_user: standard-onboarding-workflow

default: error-handling-flow
```

### Status-Based Routing

Route based on task completion status and results:

```yaml
id: processing-status-router
type: router
condition: |
  {{
    $result := .tasks.process_data.output
    $status := $result.status
    $errors := $result.errors

    if (eq $status "success")
      "success"
    else if (and (eq $status "partial") (lt (len $errors) 5))
      "partial_success"
    else if (eq $status "failed")
      "failed"
    else
      "unknown"
  }}

routes:
  success:
    type: aggregate
    outputs:
      result: "{{ .tasks.process_data.output.data }}"
      status: "completed"
      processed_at: "{{ now }}"

  partial_success:
    type: basic
    agent: error-analyzer
    with:
      data: "{{ .tasks.process_data.output.data }}"
      errors: "{{ .tasks.process_data.output.errors }}"
      action: "analyze_and_fix"

  failed:
    type: basic
    tool: error-handler
    with:
      original_input: "{{ .workflow.input }}"
      error_details: "{{ .tasks.process_data.output.errors }}"
      retry_count: "{{ .tasks.process_data.retry_count }}"

default: escalation-handler
```

## References

<ReferenceCardList>
  <ReferenceCard
    title="Composite Tasks"
    description="Master sequential task execution and orchestration patterns"
    href="/docs/core/tasks/composite-tasks"
    icon="GitBranch"
  />
  <ReferenceCard
    title="Context Variables"
    description="Learn template expressions for complex routing conditions"
    href="/docs/core/yaml-templates/context-variables"
    icon="Code"
  />
  <ReferenceCard
    title="Signal Tasks"
    description="Coordinate router decisions with signal-based communication patterns"
    href="/docs/core/signals/overview"
    icon="Radio"
  />
  <ReferenceCard
    title="Error Handling"
    description="Implement robust error handling in routing scenarios"
    href="/docs/core/tasks/basic-tasks#error-handling"
    icon="AlertCircle"
  />
  <ReferenceCard
    title="Parallel Processing"
    description="Execute multiple tasks concurrently for advanced orchestration"
    href="/docs/core/tasks/parallel-processing"
    icon="Layers"
  />
  <ReferenceCard
    title="Workflow Design"
    description="Design complete workflows with intelligent routing and decision points"
    href="/docs/core/configuration/workflows"
    icon="Workflow"
  />
</ReferenceCardList>
