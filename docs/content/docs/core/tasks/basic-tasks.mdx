---
title: Basic Tasks
description: Master the fundamental building blocks of Compozy workflows. Basic tasks execute single operations using AI agents or TypeScript tools, forming the foundation for all complex workflow patterns.
---

## Overview

Basic tasks serve as the **atomic units of execution** in Compozy workflows. Whether you're building a simple AI chat bot or a complex multi-agent system, understanding basic tasks is essential since they form the foundation for all other task types. [New to Compozy? Start with our Quick Start guide ‚Üí](/docs/core/getting-started/quick-start)

Each basic task performs a single, well-defined operation using either:
- **[AI Agents](/docs/core/agents/overview)** for natural language processing, reasoning, and creative tasks that require understanding and context
- **[TypeScript Tools](/docs/core/tools/overview)** for deterministic operations, API calls, and data processing with predictable results

**Why Basic Tasks Matter:**
- **Foundation Layer**: All complex task types ([parallel](/docs/core/tasks/parallel-processing), [collection](/docs/core/tasks/collection-tasks), [router](/docs/core/tasks/router-tasks)) ultimately decompose into basic tasks
- **Execution Flexibility**: Choose the optimal execution strategy for each operation based on complexity and requirements
- **Production Ready**: Built-in error handling, retry policies, and monitoring integration

<Callout type="info">
**Architecture Context**: Basic tasks integrate seamlessly with Compozy's [declarative YAML configuration](/docs/core/yaml-templates/overview), distributed execution engine, and comprehensive monitoring system. New to workflow orchestration? Start with [Core Concepts](/docs/core/getting-started/core-concepts) to understand the full picture.
</Callout>

## Task Execution Types

Compozy provides **9 specialized task types** that handle different execution patterns. Basic tasks are the foundation, while other types orchestrate multiple operations:

<FeatureCardList>
  <FeatureCard
    title="Basic"
    description="Single agent or tool execution for atomic operations"
    icon="Zap"
  >
    **Primary use**: Text analysis, API calls, data transformation

    **Best for**: Simple, single-purpose operations that need reliable execution
  </FeatureCard>

  <FeatureCard
    title="Router"
    description="Conditional task routing based on data or business logic"
    icon="GitBranch"
  >
    **Primary use**: Decision points, workflow branching, conditional logic

    **Best for**: Dynamic workflow paths based on runtime conditions
  </FeatureCard>

  <FeatureCard
    title="Parallel"
    description="Concurrent execution of independent tasks"
    icon="Layers"
  >
    **Primary use**: Independent operations that can run simultaneously

    **Best for**: Performance optimization and parallel data processing
  </FeatureCard>

  <FeatureCard
    title="Collection"
    description="Process arrays and lists with configurable strategies"
    icon="List"
  >
    **Primary use**: Batch data processing, bulk operations

    **Best for**: Processing multiple items with consistent logic
  </FeatureCard>

  <FeatureCard
    title="Composite"
    description="Sequential task groups with shared error handling"
    icon="Package"
  >
    **Primary use**: Multi-step workflows with coordinated execution

    **Best for**: Complex processes requiring step-by-step coordination
  </FeatureCard>

  <FeatureCard
    title="Aggregate"
    description="Combine and merge results from multiple sources"
    icon="Merge"
  >
    **Primary use**: Data consolidation, report generation, result merging

    **Best for**: Synthesizing outputs from parallel or collection tasks
  </FeatureCard>

  <FeatureCard
    title="Wait"
    description="Conditional delays and external signal waiting"
    icon="Clock"
  >
    **Primary use**: Resource availability, timing coordination, external triggers

    **Best for**: Synchronizing with external systems or time-based events
  </FeatureCard>

  <FeatureCard
    title="Signal"
    description="Event communication and workflow coordination"
    icon="Radio"
  >
    **Primary use**: Cross-workflow communication, event publishing

    **Best for**: Decoupled architectures and event-driven patterns
  </FeatureCard>

  <FeatureCard
    title="Memory"
    description="Persistent state management and context storage"
    icon="Database"
  >
    **Primary use**: Long-running processes, conversation history, state persistence

    **Best for**: Stateful workflows requiring persistent context
  </FeatureCard>
</FeatureCardList>

## Core Principles

Basic tasks in Compozy follow several key principles that make them reliable and maintainable building blocks for complex workflows:

<List>
  <ListItem title="Single Responsibility" icon="Target">
    Each basic task performs exactly one specific operation, making workflows easier to debug and maintain
  </ListItem>
  <ListItem title="Execution Flexibility" icon="Settings">
    Choose between AI agents for intelligent processing or TypeScript tools for deterministic operations
  </ListItem>
  <ListItem title="Template Integration" icon="Code">
    Full support for [dynamic parameters and outputs](/docs/core/yaml-templates/context-variables) using Sprig template expressions
  </ListItem>
  <ListItem title="Flow Control" icon="GitBranch">
    Built-in conditional routing and sophisticated error handling patterns
  </ListItem>
  <ListItem title="Schema Validation" icon="CheckCircle">
    Input/output validation with JSON Schema ensures type safety and reliable data flow
  </ListItem>
  <ListItem title="State Management" icon="Database">
    Automatic output capture and seamless data passing between tasks using [context variables](/docs/core/yaml-templates/context-variables)
  </ListItem>
</List>

<Callout type="info">
**Foundation Layer**: Basic tasks serve as the foundation for all other task patterns in Compozy. Understanding them is essential before exploring [parallel processing](/docs/core/tasks/parallel-processing), [collection tasks](/docs/core/tasks/collection-tasks), or advanced flow control.
</Callout>

## Task Structure

Basic tasks use a **declarative YAML structure** that makes them easy to read, write, and maintain. The structure is designed to be self-documenting while providing powerful capabilities for dynamic configuration.

### Anatomy of a Basic Task

<Steps>
  <Step
    title="Task Identification"
    description="Every task needs a unique identifier and execution target"
  >
    ```yaml title="Task Identity"
    id: analyze-sentiment
    $use: agent(local::agents.#(id=="sentiment-analyzer"))
    action: analyze_text  # Required for agents
    ```

    **Key components:**
    - `id`: Unique identifier for referencing in templates and flow control
    - `$use`: Reference to agent or tool using query syntax
    - `action`: Specific action for agents (not needed for tools)
  </Step>

  <Step
    title="Input Configuration"
    description="Define dynamic parameters using template expressions"
  >
    ```yaml title="Input Parameters"
    with:
      text: "{{ .workflow.input.message }}"
      context: "{{ .tasks.previous_step.output.metadata }}"
      options:
        language: "{{ .workflow.input.language | default 'en' }}"
        confidence_threshold: 0.8
    ```

    **Template capabilities:**
    - Access workflow inputs with `.workflow.input.*`
    - Reference previous task outputs with `.tasks.taskname.output.*`
    - Use [Sprig functions](/docs/core/yaml-templates/sprig-functions) for data transformation
    - Set default values and conditional logic
  </Step>

  <Step
    title="Output Management"
    description="Capture and transform task results for downstream use"
  >
    ```yaml title="Output Configuration"
    outputs:
      sentiment: "{{ .output.classification }}"
      confidence: "{{ .output.score }}"
      summary: "Analysis completed for {{ len .with.text }} characters"
      metadata:
        task_duration: "{{ .task.duration }}"
        processed_at: "{{ now }}"
    ```

    **Output features:**
    - Transform raw outputs into structured data
    - Combine multiple output fields into complex objects
    - Add computed metadata like timestamps and durations
    - Create summary information for downstream tasks
  </Step>

  <Step
    title="Flow Control"
    description="Handle success and error scenarios with conditional routing"
  >
    ```yaml title="Flow Control"
    on_success:
      next: validate-results
      with:
        analysis: "{{ .task.outputs }}"

    on_error:
      next: handle-error
      with:
        error_context: "{{ .task.error }}"
        retry_count: "{{ .task.retry_count }}"
    ```

    **Flow options:**
    - Route to different tasks based on execution outcome
    - Pass contextual data to next tasks
    - Implement sophisticated error handling strategies
  </Step>
</Steps>

<Callout type="info">
**Type Inference**: Task types are automatically determined by their structure. Basic tasks are identified when using a single agent or tool execution without complex orchestration patterns like parallel or collection processing.
</Callout>

### Key Components

<Tabs items={["Agent Tasks", "Tool Tasks", "Configuration", "Flow Control"]}>
<Tab value="Agent Tasks">

Agent tasks execute AI models with specific instructions:

```yaml
id: analyze-text
$use: agent(local::agents.#(id=="text-analyzer"))
action: analyze_sentiment

# Agent configuration (can be inline or referenced)
agent:
  id: text-analyzer
  config:
    provider: anthropic
    model: claude-3-haiku-20240307
  instructions: |
    Analyze the sentiment of the provided text.
    Return a score between -1 (negative) and 1 (positive).

with:
  text: "{{ .workflow.input.content }}"
  context: "{{ .workflow.input.metadata }}"

outputs:
  sentiment_score: "{{ .output.score }}"
  confidence: "{{ .output.confidence }}"
  explanation: "{{ .output.reasoning }}"
```

</Tab>
<Tab value="Tool Tasks">

Tool tasks execute TypeScript functions in secure Bun runtime:

```yaml
id: format-code
$use: tool(local::tools.#(id=="formatter"))

# Tool configuration (can be inline or referenced)
tool:
  id: formatter
  description: Code formatter tool

with:
  code: "{{ .workflow.input.source_code }}"
  language: "{{ .workflow.input.lang }}"
  options:
    indent_size: 2
    use_tabs: false

outputs:
  formatted_code: "{{ .output.result }}"
  changes_made: "{{ .output.modified }}"
```

</Tab>
<Tab value="Configuration">

Comprehensive task configuration options:

```yaml
id: complete-task-example
$use: agent(local::agents.#(id=="processor"))
action: process_data

# Input validation schema
input:
  type: object
  properties:
    data:
      type: string
      minLength: 1
    priority:
      type: string
      enum: ["low", "medium", "high"]
      default: "medium"
  required: [data]

# Output validation schema
output:
  type: object
  properties:
    result:
      type: string
    confidence:
      type: number
      minimum: 0
      maximum: 1
  required: [result, confidence]

# Environment variables
env:
  LOG_LEVEL: debug
  API_KEY: "{{ .env.SECRET_KEY }}"

# Runtime options
timeout: 30s
heartbeat_timeout: 10s

# Retry configuration
retry_policy:
  maximum_attempts: 3
  initial_interval: 1s
  maximum_interval: 30s
  backoff_coefficient: 2.0
```

</Tab>
<Tab value="Flow Control">

Advanced flow control and error handling:

```yaml
id: resilient-task
$use: agent(local::agents.#(id=="processor"))
action: process

with:
  data: "{{ .workflow.input.payload }}"

# Success routing
on_success:
  next: validate-result
  with:
    processed_data: "{{ .task.outputs.result }}"
    metadata:
      processing_time: "{{ .task.duration }}"
      confidence: "{{ .task.outputs.confidence }}"

# Error handling
on_error:
  next: error-recovery
  with:
    error_type: "{{ .task.error.type }}"
    error_message: "{{ .task.error.message }}"
    original_input: "{{ .task.with }}"
    retry_count: "{{ .task.retry_count }}"

# Global timeout and retry settings
schedule_to_close_timeout: 5m
start_to_close_timeout: 3m
```

</Tab>
</Tabs>

## Agent vs Tool Decision Guide

Choosing between agents and tools is crucial for optimal performance and reliability. This decision impacts execution speed, cost, and the type of processing your task can perform.

### When to Use AI Agents

Agents excel at **cognitive tasks** that require understanding, reasoning, and interpretation. They're powered by large language models and can handle complex, unstructured inputs.

<List>
  <ListItem title="Natural Language Processing" icon="MessageSquare">
    Text analysis, sentiment detection, content generation, and language translation
  </ListItem>
  <ListItem title="Complex Reasoning" icon="Brain">
    Decision making, problem solving, strategic planning, and logical inference
  </ListItem>
  <ListItem title="Unstructured Data Analysis" icon="FileSearch">
    Processing varied inputs like emails, documents, images, or free-form text that require interpretation
  </ListItem>
  <ListItem title="Creative & Generative Tasks" icon="Sparkles">
    Content creation, ideation, creative writing, and artistic tasks requiring imagination
  </ListItem>
  <ListItem title="Context-Aware Processing" icon="BrainCircuit">
    Tasks requiring understanding of context, nuance, and implicit meaning
  </ListItem>
</List>

**Agent advantages:**
- Handle ambiguous or varied inputs gracefully
- Provide reasoning and explanations for their outputs
- Can adapt to new scenarios without code changes
- Support [structured outputs](/docs/core/agents/structured-outputs) for reliable data extraction

```yaml
# Example: Content analysis agent
id: analyze-content
$use: agent(local::agents.#(id=="content-analyst"))
action: analyze_content

agent:
  id: content-analyst
  config:
    provider: anthropic
    model: claude-3-haiku-20240307
  instructions: |
    Analyze the provided content for:
    1. Key themes and topics
    2. Sentiment and tone
    3. Target audience
    4. Content quality score (1-10)

    Return structured JSON with your analysis.
  actions:
    - id: analyze_content
      json_mode: true
      output:
        type: object
        properties:
          themes: { type: array, items: { type: string } }
          sentiment: { type: string, enum: ["positive", "negative", "neutral"] }
          tone: { type: string }
          audience: { type: string }
          quality_score: { type: number, minimum: 1, maximum: 10 }
        required: [themes, sentiment, tone, audience, quality_score]

with:
  content: "{{ .workflow.input.text }}"
  metadata: "{{ .workflow.input.context }}"
```

### When to Use TypeScript Tools

Tools are perfect for **deterministic operations** that require precise, predictable results. They execute in a secure Bun runtime with configurable permissions and offer superior performance for computational tasks.

<List>
  <ListItem title="Deterministic Operations" icon="Calculator">
    File I/O, data transformation, mathematical calculations, and formatting operations
  </ListItem>
  <ListItem title="External API Integration" icon="Globe">
    HTTP requests, database operations, third-party service integration, and webhooks
  </ListItem>
  <ListItem title="System Operations" icon="Server">
    File system access, process management, environment interactions, and system utilities
  </ListItem>
  <ListItem title="Performance-Critical Tasks" icon="Zap">
    High-speed data processing, bulk operations, and computationally intensive tasks
  </ListItem>
  <ListItem title="Structured Data Processing" icon="Database">
    JSON/XML parsing, data validation, format conversion, and structured transformations
  </ListItem>
</List>

**Tool advantages:**
- Faster execution and lower latency than agents
- Deterministic, repeatable results every time
- Cost-effective for computational tasks
- Fine-grained control over [runtime permissions](/docs/core/tools/runtime-environment)

### Comparison at a Glance

<Tabs items={["Use Cases", "Performance", "Development"]}>
<Tab value="Use Cases">
| Aspect | AI Agents | TypeScript Tools |
|--------|-----------|------------------|
| **Best for** | Cognitive tasks, NLP, reasoning | Computational tasks, APIs, I/O |
| **Input handling** | Unstructured, ambiguous data | Structured, well-defined data |
| **Output predictability** | Variable, context-dependent | Deterministic, repeatable |
| **Adaptation** | Learns from context | Explicit programming required |
| **Error handling** | Graceful degradation | Precise error codes |
</Tab>

<Tab value="Performance">
| Metric | AI Agents | TypeScript Tools |
|--------|-----------|------------------|
| **Execution speed** | 2-10 seconds typical | 10-500ms typical |
| **Cost** | LLM API costs apply | Compute costs only |
| **Scalability** | Rate limited by providers | Limited by system resources |
| **Memory usage** | Handled by provider | Controlled by runtime config |
| **Concurrency** | Provider-dependent | High with proper resource management |
</Tab>

<Tab value="Development">
| Aspect | AI Agents | TypeScript Tools |
|--------|-----------|------------------|
| **Development complexity** | [YAML configuration](/docs/core/agents/instructions-actions) | TypeScript programming |
| **Testing approach** | Output validation, prompting | Unit tests, integration tests |
| **Debugging** | LLM observability tools | Standard debugging tools |
| **Maintenance** | Prompt engineering | Code maintenance |
| **Version control** | Configuration changes | Source code changes |
</Tab>
</Tabs>

```yaml
# Example: Data processing tool
id: process-csv
$use: tool(local::tools.#(id=="csv-processor"))

tool:
  id: csv-processor
  description: Process CSV data with filtering and transformation
  input:
    type: object
    properties:
      csv_data: { type: string }
      filters: { type: object }
      transformations: { type: array }
    required: [csv_data]

with:
  csv_data: "{{ .workflow.input.raw_data }}"
  filters:
    status: "active"
    date_range: "{{ .workflow.input.date_filter }}"
  transformations:
    - type: "normalize_names"
    - type: "calculate_totals"

outputs:
  processed_data: "{{ .output.data }}"
  row_count: "{{ .output.count }}"
  processing_time: "{{ .output.duration }}"
```

## Template Expressions & Dynamic Configuration

Basic tasks leverage Compozy's [powerful template engine](/docs/core/yaml-templates/overview) to create dynamic, data-driven workflows. Template expressions use the **[Sprig template engine](https://github.com/Masterminds/sprig)** with custom functions for accessing workflow context.

<Callout type="info">
**Template Mastery Path**: New to templates? Follow this progression:
1. **Start**: [Template Overview](/docs/core/yaml-templates/overview) for basic syntax
2. **Learn**: [Context Variables](/docs/core/yaml-templates/context-variables) for data access patterns
3. **Master**: [Sprig Functions](/docs/core/yaml-templates/sprig-functions) for data transformation
4. **Apply**: Conditional Logic for advanced workflows
</Callout>

### Input Template Patterns

```yaml
with:
  # Simple value substitution
  user_id: "{{ .workflow.input.user_id }}"

  # Complex expressions with functions
  timestamp: "{{ now | date '2006-01-02 15:04:05' }}"

  # Conditional values
  priority: "{{ .workflow.input.priority | default 'medium' }}"

  # Nested object construction
  metadata:
    source: "{{ .workflow.id }}"
    user: "{{ .workflow.input.user_id }}"
    environment: "{{ .env.ENVIRONMENT }}"
    created_at: "{{ now }}"

  # Array manipulation
  tags: "{{ .workflow.input.tags | append 'processed' }}"

  # Mathematical operations
  score: "{{ mul .workflow.input.base_score 1.2 }}"
```

### Output Templates

```yaml
outputs:
  # Direct field mapping
  result: "{{ .output.data }}"

  # Computed values
  summary: "Processed {{ .output.count }} items in {{ .task.duration }}"

  # Complex object creation
  metadata:
    task_id: "{{ .task.id }}"
    execution_time: "{{ .task.duration }}"
    input_size: "{{ len .with.data }}"
    success: "{{ not .task.error }}"

  # Conditional outputs
  status: "{{ if .output.errors }}failed{{ else }}success{{ end }}"

  # Type conversions
  count_string: "{{ .output.count | toString }}"
  score_number: "{{ .output.score | toNumber }}"
```

### Task Design

1. **Single Responsibility**: Each task should have one clear purpose
2. **Idempotency**: Tasks should produce the same result when run multiple times
3. **Error Handling**: Always define error handling strategies
4. **Input Validation**: Use JSON Schema for input validation
5. **Output Structure**: Design consistent output formats

### Performance Optimization

```yaml
# Efficient task configuration
id: optimized-task
$use: tool(local::tools.#(id=="processor"))

# Set appropriate timeouts
timeout: 2m
heartbeat_timeout: 30s

# Optimize retry strategy
retry_policy:
  maximum_attempts: 2
  initial_interval: 1s
  maximum_interval: 10s

# Minimal input/output
with:
  # Only pass necessary data
  id: "{{ .workflow.input.item_id }}"
  action: "process"

outputs:
  # Only extract needed fields
  result: "{{ .output.status }}"
  id: "{{ .output.id }}"
```

### Error Resilience

```yaml
id: resilient-task
$use: agent(local::agents.#(id=="processor"))
action: process

# Comprehensive error handling
retry_policy:
  maximum_attempts: 3
  initial_interval: 1s
  maximum_interval: 1m
  backoff_coefficient: 2.0
  non_retryable_error_types:
    - "ValidationError"
    - "AuthenticationError"

on_error:
  next: error-recovery
  with:
    error_context:
      original_input: "{{ .task.with }}"
      error_type: "{{ .task.error.type }}"
      error_message: "{{ .task.error.message }}"
      retry_count: "{{ .task.retry_count }}"
      task_id: "{{ .task.id }}"

# Timeout protection
schedule_to_close_timeout: 10m
start_to_close_timeout: 5m
```

## Common Patterns & Best Practices

Master these essential patterns to build robust, maintainable workflows with basic tasks.

### Task Design Principles

<Steps numbered>
  <Step title="Single Responsibility" description="Design each task with one clear purpose">

    ```yaml title="Good: Focused Task"
    id: validate-email
    $use: tool(local::tools.#(id=="email-validator"))
    with:
      email: "{{ .workflow.input.email }}"
    ```

    **Why**: Single-responsibility tasks are easier to debug, test, and reuse across workflows.
  </Step>

  <Step title="Idempotent Execution" description="Tasks should produce consistent results when re-run">

    ```yaml title="Idempotent Design"
    id: generate-report
    $use: agent(local::agents.#(id=="reporter"))
    action: create_report
    with:
      data: "{{ .workflow.input.data }}"
      timestamp: "{{ .workflow.input.report_date }}" # Fixed timestamp, not 'now'
    ```

    **Why**: Enables safe retries and workflow replay without side effects.
  </Step>

  <Step title="Comprehensive Error Handling" description="Define clear error scenarios and recovery paths">

    ```yaml title="Robust Error Handling"
    id: api-call
    $use: tool(local::tools.#(id=="http-client"))

    retry_policy:
      maximum_attempts: 3
      initial_interval: 1s
      maximum_interval: 30s
      backoff_coefficient: 2.0
      non_retryable_error_types:
        - "AuthenticationError"
        - "ValidationError"

    on_error:
      next: handle-failure
      with:
        error_context: "{{ .task.error }}"
    ```

    **Learn more**: Error Handling Strategies in the task documentation
  </Step>

  <Step title="Input Validation" description="Use JSON Schema to validate inputs early">

    ```yaml title="Schema Validation"
    id: process-user-data

    input:
      type: object
      properties:
        email: { type: string, format: email }
        age: { type: integer, minimum: 0, maximum: 150 }
        preferences:
          type: object
          properties:
            notifications: { type: boolean }
            theme: { type: string, enum: ["light", "dark"] }
      required: [email, age]
    ```

    **Why**: Early validation prevents downstream errors and improves debugging.
  </Step>
</Steps>

### Essential Patterns

<Tabs items={["Conditional Logic", "Data Transformation", "Error Recovery", "State Management"]}>
<Tab value="Conditional Logic">

**Pattern**: Execute tasks based on runtime conditions

```yaml title="Conditional Execution"
id: conditional-processing
$use: agent(local::agents.#(id=="processor"))
action: process_data

# Conditional input preparation
with:
  data: >-
    {{ if .workflow.input.process_required }}
      {{ .workflow.input.data }}
    {{ else }}
      null
    {{ end }}

# Skip execution if no data to process
condition: "{{ ne .with.data null }}"

on_success:
  next: "{{ if .workflow.input.save_results }}save-results{{ else }}notify-completion{{ end }}"
```

**Use cases**: Feature flags, A/B testing, environment-specific logic
</Tab>

<Tab value="Data Transformation">

**Pattern**: Transform and validate data between tasks

```yaml title="Data Pipeline"
id: transform-data
$use: tool(local::tools.#(id=="transformer"))

with:
  raw_data: "{{ .tasks.fetch_data.output.results }}"
  transformation_rules:
    - type: "normalize_dates"
      format: "ISO8601"
    - type: "validate_emails"
    - type: "deduplicate"
      key: "user_id"

outputs:
  processed_data: "{{ .output.data }}"
  transformation_log: "{{ .output.log }}"
  errors: "{{ .output.errors }}"

on_success:
  condition: "{{ eq (len .task.outputs.errors) 0 }}"
  next: save-clean-data
on_error:
  next: handle-transformation-errors
```

**Use cases**: Data pipelines, ETL workflows, format conversion
</Tab>

<Tab value="Error Recovery">

**Pattern**: Graceful degradation and recovery strategies

```yaml title="Fallback Strategy"
id: primary-service-call
$use: tool(local::tools.#(id=="primary-api"))

retry_policy:
  maximum_attempts: 2
  initial_interval: 500ms

on_error:
  next: fallback-service
  with:
    original_request: "{{ .task.with }}"
    primary_error: "{{ .task.error }}"

---
id: fallback-service
$use: tool(local::tools.#(id=="backup-api"))

with:
  request: "{{ .workflow.tasks.primary-service-call.with.original_request }}"
  fallback_mode: true

outputs:
  result: "{{ .output.data }}"
  source: "fallback"
```

**Learn more**: Resilient Workflow Patterns ‚Üí
</Tab>

<Tab value="State Management">

**Pattern**: Accumulate and pass state between tasks

```yaml title="State Accumulation"
id: process-batch
$use: agent(local::agents.#(id=="batch-processor"))
action: process_items

with:
  items: "{{ .workflow.input.batch }}"
  previous_results: "{{ .tasks.previous_batch.output.results | default list }}"
  batch_number: "{{ add (.workflow.context.current_batch | default 0) 1 }}"

outputs:
  # Accumulate results across batches
  all_results: >-
    {{ concat
        (.with.previous_results | default list)
        (.output.processed_items | default list)
    }}

  # Update workflow context
  batch_metadata:
    current_batch: "{{ .with.batch_number }}"
    total_processed: "{{ len .task.outputs.all_results }}"
    last_processed_at: "{{ now }}"

on_success:
  next: "{{ if .workflow.input.has_more_batches }}process-next-batch{{ else }}finalize-results{{ end }}"
```

**Use cases**: Batch processing, accumulating results, maintaining workflow state
</Tab>
</Tabs>

### Production Considerations

<List>
  <ListItem title="Performance Optimization" icon="Zap">
    **Timeouts**: 2-30s for most tasks | **Retries**: Efficient backoff strategies | **Data**: Minimize I/O payload size | **Resources**: Monitor execution metrics
  </ListItem>
  <ListItem title="Security Best Practices" icon="Shield">
    **Input Validation**: JSON Schema enforcement | **Secrets**: Environment variables only | **Permissions**: Minimal runtime access | **Audit**: Security logging
  </ListItem>
  <ListItem title="Monitoring & Observability" icon="Eye">
    **Task IDs**: Meaningful, traceable identifiers | **Metadata**: Execution context in outputs | **Health**: Dependency monitoring | **Alerts**: Error rate thresholds
  </ListItem>
  <ListItem title="Testing & Validation" icon="TestTube">
    **Isolation**: Unit test individual tasks | **Templates**: Validate expression syntax | **Fixtures**: Consistent test data | **Integration**: End-to-end workflows
  </ListItem>
</List>

Basic tasks form the **foundation of all Compozy workflows**, providing flexible, reliable execution of both AI agents and tools. Master these patterns to build scalable, maintainable automation that grows with your needs.

## Next Steps & Learning Paths

Choose your learning path based on your goals and experience level:

### üöÄ Getting Started

<ReferenceCardList>
  <ReferenceCard
    title="Quick Start Guide"
    description="Build your first basic task in 10 minutes with step-by-step tutorial and working examples"
    href="/docs/core/getting-started/quick-start"
    icon="Rocket"
  />
  <ReferenceCard
    title="First Workflow Tutorial"
    description="Create an end-to-end workflow combining multiple basic tasks with error handling"
    href="/docs/core/getting-started/first-workflow"
    icon="PlayCircle"
  />
  <ReferenceCard
    title="Core Concepts Deep Dive"
    description="Master the foundational architecture and understand task relationships in complex systems"
    href="/docs/core/getting-started/core-concepts"
    icon="BookOpen"
  />
  <ReferenceCard
    title="Template Expression Mastery"
    description="Advanced dynamic configuration with context variables, conditionals, and Sprig functions"
    href="/docs/core/yaml-templates/context-variables"
    icon="Code"
  />
</ReferenceCardList>

### ü§ñ AI Agent Development

<ReferenceCardList>
  <ReferenceCard
    title="Agent Architecture & Integration"
    description="Design AI agents with structured outputs, tool integration, and persistent memory for complex reasoning"
    href="/docs/core/agents/overview"
    icon="BrainCircuit"
  />
  <ReferenceCard
    title="Instructions & Action Design"
    description="Craft effective prompts, define reusable actions, and implement reliable structured response patterns"
    href="/docs/core/agents/instructions-actions"
    icon="MessageSquare"
  />
  <ReferenceCard
    title="Structured Output Mastery"
    description="Guarantee reliable data extraction with JSON schemas, type validation, and error handling strategies"
    href="/docs/core/agents/structured-outputs"
    icon="Target"
  />
</ReferenceCardList>

### üõ†Ô∏è Tool Development

<ReferenceCardList>
  <ReferenceCard
    title="Tool Development Guide"
    description="Create custom TypeScript tools for specialized operations and integrations"
    href="/docs/core/tools/overview"
    icon="Wrench"
  />
  <ReferenceCard
    title="Runtime Environment"
    description="Configure secure Bun runtime with permissions and environment variables"
    href="/docs/core/tools/runtime-environment"
    icon="Server"
  />
  <ReferenceCard
    title="Testing & Debugging"
    description="Test tools in isolation and debug execution issues effectively"
    href="/docs/core/tools/typescript-development"
    icon="Bug"
  />
  <ReferenceCard
    title="External MCP Tools"
    description="Integrate external tools and services using Model Context Protocol"
    href="/docs/core/mcp/overview"
    icon="Plug"
  />
</ReferenceCardList>

### üìä Advanced Task Patterns

<ReferenceCardList>
  <ReferenceCard
    title="Parallel Processing"
    description="Execute multiple tasks concurrently for performance and scalability"
    href="/docs/core/tasks/parallel-processing"
    icon="Layers"
  />
  <ReferenceCard
    title="Collection Tasks"
    description="Process arrays and lists with parallel, sequential, or custom strategies"
    href="/docs/core/tasks/collection-tasks"
    icon="List"
  />
  <ReferenceCard
    title="Router Tasks"
    description="Implement conditional logic and dynamic workflow routing"
    href="/docs/core/tasks/router-tasks"
    icon="GitBranch"
  />
  <ReferenceCard
    title="Flow Control Patterns"
    description="Master error handling, retries, and complex orchestration"
    href="/docs/core/tasks/composite-tasks"
    icon="Workflow"
  />
</ReferenceCardList>

### üéØ Production & Operations

<ReferenceCardList>
  <ReferenceCard
    title="Memory & State"
    description="Add persistent memory and state management to your workflows"
    href="/docs/core/memory/overview"
    icon="Database"
  />
  <ReferenceCard
    title="CLI Commands"
    description="Execute, monitor, and debug basic tasks using the Compozy CLI"
    href="/docs/cli/workflow-commands"
    icon="Terminal"
  />
</ReferenceCardList>
