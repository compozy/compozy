---
title: Memory Tasks
description: Manage persistent memory storage with read, write, append, and memory management operations
---

## Overview

Memory tasks provide persistent storage capabilities for workflows, enabling data persistence, session management, and context preservation across workflow executions. They integrate seamlessly with [Compozy's memory management system](/docs/core/memory/overview) to provide scalable, efficient storage for AI-powered applications.

Unlike [basic tasks](/docs/core/tasks/basic-tasks) that operate in isolation, memory tasks create persistent state that survives workflow executions, enabling [agent-driven applications](/docs/core/agents/overview) with conversation history, complex workflow orchestration with shared context, and intelligent caching systems for improved performance.

<FeatureCardList cols={2} size="default">
  <FeatureCard
    title="8 Memory Operations"
    description="Complete CRUD operations plus advanced management: read, write, append, delete, flush, health, clear, and stats"
    icon="Database"
  />
  <FeatureCard
    title="Intelligent Session Management"
    description="Maintain user sessions and conversation history with automatic token optimization and memory summarization"
    icon="Users"
  />
  <FeatureCard
    title="Context Preservation"
    description="Store and retrieve workflow context across executions, enabling stateful AI agents and persistent workflows"
    icon="Save"
  />
  <FeatureCard
    title="Scalable Storage Backends"
    description="Support for Redis, in-memory, and custom storage backends with automatic scaling and performance optimization"
    icon="Layers"
  />
  <FeatureCard
    title="Memory Health Monitoring"
    description="Real-time memory usage monitoring, performance metrics, and automated cleanup with configurable strategies"
    icon="Activity"
  />
  <FeatureCard
    title="Multi-Tenant Architecture"
    description="Secure memory isolation with hierarchical key patterns supporting complex organizational structures"
    icon="Shield"
  />
</FeatureCardList>

## Memory Task Flow

Memory tasks follow a structured execution pattern that integrates with Compozy's memory management system:

<Mermaid chart={`sequenceDiagram
    participant WT as Workflow Task
    participant ME as Memory Engine
    participant MS as Memory Storage
    participant KB as Key Builder

    WT->>KB: Resolve key_template with context
    KB-->>WT: Resolved memory key
    WT->>ME: Execute operation (read/write/append/etc.)
    ME->>MS: Access memory storage backend

    alt Write/Append Operation
        ME->>MS: Store payload with metadata
        MS-->>ME: Success confirmation
    else Read Operation
        MS-->>ME: Retrieved data
        ME->>ME: Format response
    else Management Operation
        ME->>MS: Execute flush/clear/stats/health
        MS-->>ME: Operation results
    end

    ME-->>WT: Operation output
    WT->>WT: Process outputs and continue workflow`} />

## Task Structure

Here's the essential structure for a memory task, following task configuration patterns. This example demonstrates user profile storage with template expressions for flexible data handling:

```yaml title="Memory Task Structure"
id: store-user-data
type: memory # [!code highlight]
operation: write # [!code highlight]
memory_ref: user_session # [!code highlight]
key_template: "user:{{ .workflow.input.user_id }}:profile" # [!code highlight]

payload:
  role: "system"
  content: |
    User Profile:
    Name: {{ .workflow.input.name }}
    Email: {{ .workflow.input.email }}
    Preferences: {{ .workflow.input.preferences | toJson }}
    Created: {{ now | date "2006-01-02 15:04:05" }}

on_success:
  next: process-user-data
```

## Memory Operations Reference

Memory tasks support 8 distinct operations, each optimized for specific use cases. These operations integrate with workflow context and support [template expressions](/docs/core/yaml-templates/overview) for dynamic behavior.

<Tabs items={["Write", "Read", "Append", "Clear", "Delete", "Flush"]}>
<Tab value="Write">

```yaml title="Write Operation"
id: write-memory
type: memory # [!code highlight]
operation: write # [!code highlight]
memory_ref: conversation_memory # [!code highlight]
key_template: "conversation:{{ .workflow.input.session_id }}:{{ .workflow.input.message_id }}"

payload:
  role: "user"
  content: "{{ .workflow.input.message }}"
  timestamp: "{{ now }}"
  metadata:
    user_id: "{{ .workflow.input.user_id }}"
    session_id: "{{ .workflow.input.session_id }}"

on_success:
  next: read-conversation-history
```

</Tab>

<Tab value="Read">

```yaml title="Read Operation"
id: read-conversation-history
type: memory # [!code highlight]
operation: read # [!code highlight]
memory_ref: conversation_memory # [!code highlight]
key_template: "conversation:{{ .workflow.input.session_id }}:*"

# Optional read configuration
read_config:
  limit: 50
  pattern: "conversation:*"
  include_metadata: true

outputs:
  conversation_history: "{{ .output.messages }}"
  message_count: "{{ len .output.messages }}"

on_success:
  next: process-conversation
```

</Tab>

<Tab value="Append">

```yaml title="Append Operation"
id: append-message
type: memory # [!code highlight]
operation: append # [!code highlight]
memory_ref: conversation_memory # [!code highlight]
key_template: "conversation:{{ .workflow.input.session_id }}:history"

payload:
  role: "assistant"
  content: "{{ .tasks.generate_response.output.response }}"
  timestamp: "{{ now }}"
  metadata:
    model: "{{ .tasks.generate_response.output.model }}"
    tokens_used: "{{ .tasks.generate_response.output.tokens }}"
    confidence: "{{ .tasks.generate_response.output.confidence }}"

on_success:
  next: update-session-stats
```

</Tab>

<Tab value="Clear">

```yaml title="Clear Memory"
id: clear-user-session
type: memory # [!code highlight]
operation: clear # [!code highlight]
memory_ref: user_session # [!code highlight]
key_template: "user:{{ .workflow.input.user_id }}:*"

clear_config:
  confirm: true
  backup: true
  pattern: "user:*:session"

on_success:
  next: session-cleared-notification
```

</Tab>

<Tab value="Delete">

```yaml title="Delete Operation"
id: delete-expired-data
type: memory # [!code highlight]
operation: delete # [!code highlight]
memory_ref: temp_storage # [!code highlight]
key_template: "temp:{{ .workflow.input.temp_id }}"

on_success:
  next: cleanup-complete
```

</Tab>

<Tab value="Flush">

```yaml title="Flush Operation"
id: flush-memory
type: memory # [!code highlight]
operation: flush # [!code highlight]
memory_ref: user_memory # [!code highlight]
key_template: "user:{{ .workflow.input.user_id }}:*"

flush_config:
  strategy: "lru"  # or "fifo", "priority"
  threshold: 0.8
  max_keys: 100
  dry_run: false
  force: false

outputs:
  flushed_keys: "{{ .output.flushed_keys }}"
  remaining_keys: "{{ .output.remaining_keys }}"
  memory_freed: "{{ .output.memory_freed }}"

on_success:
  next: memory-optimization-complete
```

</Tab>
</Tabs>

## Memory Key Patterns

Memory keys provide hierarchical organization and enable powerful querying patterns. They work with template expressions and [configuration templates](/docs/core/configuration/workflows), memory keys enable sophisticated data organization patterns.

<Tabs items={["User Session Keys", "Hierarchical Keys", "Time-Based Keys"]}>
<Tab value="User Session Keys">

```yaml
id: user-session-keys
type: memory
operation: write
memory_ref: user_sessions
key_template: "session:{{ .workflow.input.user_id }}:{{ .workflow.input.session_id }}:{{ now | date '2006-01-02' }}" # [!code highlight]

payload:
  role: "system"
  content: "Session started"
```

</Tab>

<Tab value="Hierarchical Keys">

```yaml
id: hierarchical-keys
type: memory
operation: write
memory_ref: organization_data
key_template: "org:{{ .workflow.input.org_id }}:dept:{{ .workflow.input.dept_id }}:user:{{ .workflow.input.user_id }}" # [!code highlight]

payload:
  role: "user"
  content: "{{ .workflow.input.data }}"
```

</Tab>

<Tab value="Time-Based Keys">

```yaml
id: time-based-keys
type: memory
operation: write
memory_ref: analytics
key_template: "metrics:{{ .workflow.input.metric_type }}:{{ now | date '2006-01-02-15' }}" # [!code highlight]

payload:
  role: "system"
  content: |
    Metric: {{ .workflow.input.metric_type }}
    Value: {{ .workflow.input.value }}
    Timestamp: {{ now }}
```

</Tab>
</Tabs>

## Best Practices

<FeatureCardList cols={2} size="default">
  <FeatureCard
    title="Design Hierarchical Keys"
    description="Use consistent, searchable key patterns like 'domain:entity:attribute' for maintainable memory organization. See key patterns guide for detailed examples."
    icon="FolderTree"
    href="/docs/core/memory/operations"
  />
  <FeatureCard
    title="Implement Strategic TTL"
    description="Set appropriate time-to-live for temporary data and implement cleanup strategies. Learn about memory lifecycle management."
    icon="Clock"
    href="/docs/core/memory/configuration"
  />
  <FeatureCard
    title="Monitor Memory Health"
    description="Use regular health checks and statistics to maintain optimal performance. Explore memory monitoring for comprehensive tracking."
    icon="Activity"
    href="/docs/core/configuration/monitoring"
  />
  <FeatureCard
    title="Choose Optimal Operations"
    description="Select read/write/append/management operations based on your specific use case and access patterns."
    icon="Settings"
  />
  <FeatureCard
    title="Plan for Scale"
    description="Design memory patterns that scale with your application growth, using parallel processing for high-throughput scenarios."
    icon="TrendingUp"
    href="/docs/core/tasks/parallel-processing"
  />
  <FeatureCard
    title="Handle Failures Gracefully"
    description="Implement fallback strategies when memory is unavailable, using error handling patterns."
    icon="ShieldAlert"
    href="/docs/core/tasks/overview"
  />
</FeatureCardList>

## Summary

Memory tasks provide powerful persistent storage capabilities that enable stateful workflows, intelligent AI agents, and efficient data caching. They integrate seamlessly with [signal tasks](/docs/core/tasks/signal-tasks) for event coordination, [parallel processing](/docs/core/tasks/parallel-processing) for scale, [wait tasks](/docs/core/tasks/wait-tasks) for synchronization, and [aggregate tasks](/docs/core/tasks/aggregate-tasks) for data consolidation patterns.

For production deployments, consider memory system configuration, [security best practices](/docs/core/tools/runtime-environment), and performance monitoring to ensure optimal operation at scale.

## Next Steps

<Tabs items={["Build on Memory", "Integration Patterns", "Advanced Usage"]}>
<Tab>
<ReferenceCardList>
  <ReferenceCard
    title="Basic Tasks"
    description="Master the foundation tasks that work with memory storage for simple data operations"
    href="/docs/core/tasks/basic-tasks"
    icon="Package"
  />
  <ReferenceCard
    title="Aggregate Tasks"
    description="Combine memory data with aggregate operations for complex data processing"
    href="/docs/core/tasks/aggregate-tasks"
    icon="BarChart"
  />
  <ReferenceCard
    title="Memory System Concepts"
    description="Deep dive into memory architecture, backends, and configuration options"
    href="/docs/core/memory/overview"
    icon="Database"
  />
  <ReferenceCard
    title="Template Expressions"
    description="Master dynamic key generation and payload templating for flexible memory usage"
    href="/docs/core/yaml-templates/overview"
    icon="Code"
  />
</ReferenceCardList>
</Tab>

<Tab>
<ReferenceCardList>
  <ReferenceCard
    title="Wait Tasks"
    description="Coordinate memory state with wait task patterns for complex synchronization"
    href="/docs/core/tasks/wait-tasks"
    icon="Clock"
  />
  <ReferenceCard
    title="Signal Tasks"
    description="Combine memory storage with signal-based coordination for event-driven workflows"
    href="/docs/core/tasks/signal-tasks"
    icon="Radio"
  />
  <ReferenceCard
    title="Parallel Processing"
    description="Scale memory operations with parallel task execution for high-throughput scenarios"
    href="/docs/core/tasks/parallel-processing"
    icon="GitBranch"
  />
  <ReferenceCard
    title="Agent Integration"
    description="Build intelligent AI agents with persistent memory for conversational applications"
    href="/docs/core/agents/overview"
    icon="BrainCircuit"
  />
</ReferenceCardList>
</Tab>

<Tab>
<ReferenceCardList>
  <ReferenceCard
    title="Advanced Task Patterns"
    description="Explore sophisticated memory management patterns and optimization strategies"
    href="/docs/core/tasks/parallel-processing"
    icon="Layers"
  />
  <ReferenceCard
    title="Custom Task Types"
    description="Create specialized memory operations for domain-specific requirements"
    href="/docs/core/tasks/composite-tasks"
    icon="Wrench"
  />
  <ReferenceCard
    title="Production Deployment"
    description="Deploy and scale memory systems in production environments with monitoring"
    href="/docs/core/deployment/docker"
    icon="Cloud"
  />
  <ReferenceCard
    title="Performance Optimization"
    description="Optimize memory performance, costs, and scalability for production workloads"
    href="/docs/core/memory/configuration"
    icon="Zap"
  />
</ReferenceCardList>
</Tab>
</Tabs>
