---
title: Custom Task Types
description: Understand Compozy's built-in task types and patterns for creating complex workflows
---

Compozy provides **9 built-in task types** that cover all common workflow patterns. These task types are designed to be composable and flexible, allowing you to build complex workflows without needing custom implementations.



## Built-in Task Types

Compozy includes these task types for comprehensive workflow orchestration:

<FeatureCardList>
<FeatureCard title="Basic Tasks" description="Single-step operations using agents or tools" href="/docs/core/tasks/basic-tasks" />
<FeatureCard title="Router Tasks" description="Conditional branching and decision logic" href="/docs/core/tasks/router-tasks" />
<FeatureCard title="Parallel Tasks" description="Concurrent execution of multiple operations" href="/docs/core/tasks/parallel-processing" />
<FeatureCard title="Collection Tasks" description="Iteration over arrays and data sets" href="/docs/core/tasks/collection-tasks" />
<FeatureCard title="Aggregate Tasks" description="Combine outputs from multiple tasks" href="/docs/core/tasks/aggregate-tasks" />
<FeatureCard title="Composite Tasks" description="Group related tasks into reusable units" href="/docs/core/tasks/composite-tasks" />
<FeatureCard title="Signal Tasks" description="Send notifications and trigger events" href="/docs/core/tasks/signal-tasks" />
<FeatureCard title="Wait Tasks" description="Pause execution and wait for conditions" href="/docs/core/tasks/wait-tasks" />
<FeatureCard title="Memory Tasks" description="Store and retrieve workflow state" href="/docs/core/tasks/memory-tasks" />
</FeatureCardList>

<Callout type="info">
All task types are built into Compozy's core engine and use activity-based execution patterns. They're designed to be composable and cover the vast majority of workflow orchestration needs.
</Callout>

## Architecture

### Task Execution Model

Compozy uses an **activity-based execution model** where each task type has specialized handlers:

```go
// Actual execution pattern from Compozy's codebase
// 1. Create normalizer for the task type
normalizer, err := task2Factory.CreateNormalizer(taskType)
if err != nil {
    return fmt.Errorf("failed to create normalizer: %w", err)
}

// 2. Normalize the task configuration
err = normalizer.Normalize(config, context)
if err != nil {
    return fmt.Errorf("failed to normalize config: %w", err)
}

// 3. Create response handler for the task type
handler, err := task2Factory.CreateResponseHandler(ctx, taskType)
if err != nil {
    return fmt.Errorf("failed to create response handler: %w", err)
}

// 4. Handle the execution response
response, err := handler.HandleResponse(context, input)
```

This pattern provides:
- **Type Safety**: Each task type has dedicated normalizers and handlers
- **Consistent Execution**: All tasks follow the same normalize-execute-handle pattern
- **Extensibility**: New task types can be added by implementing the factory pattern
- **Error Handling**: Comprehensive error handling at each stage

### Task Type Registration

The 9 built-in task types are registered in the core engine:

```go
// From engine/task/config.go - actual task types
const (
    TaskTypeBasic      Type = "basic"      // Single operations
    TaskTypeRouter     Type = "router"     // Conditional routing
    TaskTypeParallel   Type = "parallel"   // Concurrent execution
    TaskTypeCollection Type = "collection" // Array iteration
    TaskTypeAggregate  Type = "aggregate"  // Result combination
    TaskTypeComposite  Type = "composite"  // Task grouping
    TaskTypeSignal     Type = "signal"     // Event signaling
    TaskTypeWait       Type = "wait"       // Conditional waiting
    TaskTypeMemory     Type = "memory"     // State management
)
```

**Why No Plugin System?**

Compozy's built-in task types are designed to be:
- **Composable**: Combine simple types into complex workflows
- **Template-driven**: Use YAML templates for dynamic behavior
- **Tool-integrated**: Execute custom logic through TypeScript tools
- **Agent-powered**: Leverage AI agents for intelligent processing

This approach eliminates the need for custom task type plugins while maintaining flexibility.

## Building Complex Workflows

### 1. Using Composite Tasks for Reusability

**Instead of custom task types, use composite tasks** to group related operations:

<Tabs items={['Email Campaign', 'Data Processing', 'API Integration']}>
  <Tab value="Email Campaign">
```yaml
# Email campaign using composite task pattern
- id: newsletter_campaign
  type: composite
  description: "Complete email campaign workflow"
  tasks:
    # Step 1: Validate recipients
    - id: validate_recipients
      type: basic
      $use: tool(local::tools.#(id=="email_validator"))
      with:
        recipient_list: "{{ .workflow.input.subscribers }}"
    
    # Step 2: Generate personalized content
    - id: generate_content
      type: collection
      mode: parallel
      items: "{{ .tasks.validate_recipients.output.valid_emails }}"
      task:
        id: "personalize_email_{{ .index }}"
        type: basic
        $use: agent(local::agents.#(id=="email_personalizer"))
        action: personalize_email
        with:
          recipient: "{{ .item }}"
          template: "{{ .workflow.input.template }}"
          campaign_data: "{{ .workflow.input.campaign_data }}"
    
    # Step 3: Send emails with rate limiting
    - id: send_emails
      type: parallel
      strategy: best_effort
      max_workers: 5
      tasks:
        - id: send_batch_1
          type: basic
          $use: tool(local::tools.#(id=="email_sender"))
          with:
            batch: "{{ slice .tasks.generate_content.output 0 50 }}"
        - id: send_batch_2
          type: basic
          $use: tool(local::tools.#(id=="email_sender"))
          with:
            batch: "{{ slice .tasks.generate_content.output 50 100 }}"
    
    # Step 4: Track results
    - id: track_campaign
      type: basic
      $use: tool(local::tools.#(id=="analytics_tracker"))
      with:
        campaign_id: "{{ .workflow.input.campaign_id }}"
        sent_count: "{{ len .tasks.send_emails.output }}"
        results: "{{ .tasks.send_emails.output }}"
```

This email campaign workflow demonstrates:
- **Input Validation**: Ensuring email addresses are valid before processing
- **Parallel Processing**: Generating personalized content concurrently
- **Rate Limiting**: Controlling email sending to avoid overwhelming services
- **Result Tracking**: Monitoring campaign performance and outcomes

</Tab>
  <Tab value="Data Processing">
```yaml
# Data processing pipeline using built-in types
- id: data_processing_pipeline
  type: composite
  description: "ETL pipeline for customer data"
  tasks:
    # Extract data from multiple sources
    - id: extract_data
      type: parallel
      tasks:
        - id: extract_customers
          type: basic
          $use: tool(local::tools.#(id=="database_extractor"))
          with:
            source: "customers"
            query: "SELECT * FROM customers WHERE updated_at > ?"
            params: ["{{ .workflow.input.last_sync }}"]
        
        - id: extract_orders
          type: basic
          $use: tool(local::tools.#(id=="database_extractor"))
          with:
            source: "orders"
            query: "SELECT * FROM orders WHERE created_at > ?"
            params: ["{{ .workflow.input.last_sync }}"]
    
    # Transform data
    - id: transform_data
      type: collection
      mode: parallel
      items: "{{ .tasks.extract_data.output.customers }}"
      task:
        id: "transform_customer_{{ .index }}"
        type: basic
        $use: agent(local::agents.#(id=="data_transformer"))
        action: transform_customer
        with:
          customer: "{{ .item }}"
          orders: "{{ .tasks.extract_data.output.orders }}"
    
    # Load transformed data
    - id: load_data
      type: basic
      $use: tool(local::tools.#(id=="data_loader"))
      with:
        transformed_data: "{{ .tasks.transform_data.output }}"
        target_table: "customer_analytics"
```

This data processing pipeline shows:

- **Concurrent Extraction**: Pulling data from multiple sources simultaneously
- **Intelligent Transformation**: Using AI agents to transform and enrich data
- **Scalable Processing**: Processing large datasets efficiently with parallel execution
- **Flexible Loading**: Configurable data loading with error handling

</Tab>
  <Tab value="API Integration">
```yaml
# API integration workflow
- id: api_integration_workflow
  type: composite
  description: "Sync data with external CRM system"
  tasks:
    # Authenticate with external API
    - id: authenticate
      type: basic
      $use: tool(local::tools.#(id=="oauth_client"))
      with:
        client_id: "{{ .env.CRM_CLIENT_ID }}"
        client_secret: "{{ .env.CRM_CLIENT_SECRET }}"
        scope: "contacts:read contacts:write"
    
    # Fetch updated contacts
    - id: fetch_contacts
      type: basic
      $use: tool(local::tools.#(id=="api_client"))
      with:
        url: "{{ .env.CRM_API_URL }}/contacts"
        method: "GET"
        headers:
          Authorization: "Bearer {{ .tasks.authenticate.output.access_token }}"
        params:
          updated_since: "{{ .workflow.input.last_sync }}"
          limit: 100
    
    # Process each contact
    - id: process_contacts
      type: collection
      mode: parallel
      max_workers: 10
      items: "{{ .tasks.fetch_contacts.output.contacts }}"
      task:
        id: "process_contact_{{ .index }}"
        type: router
        condition: "{{ .item.status }}"
        routes:
          active:
            type: basic
            $use: tool(local::tools.#(id=="contact_processor"))
            with:
              contact: "{{ .item }}"
              operation: "sync"
          inactive:
            type: basic
            $use: tool(local::tools.#(id=="contact_processor"))
            with:
              contact: "{{ .item }}"
              operation: "archive"
```

This API integration workflow demonstrates:

- **OAuth Authentication**: Secure API authentication with token management
- **Batch Processing**: Efficiently processing large datasets with rate limiting
- **Conditional Logic**: Different processing paths based on data conditions
- **Error Resilience**: Robust error handling for external service integration

</Tab>
</Tabs>

### 2. Custom Logic with TypeScript Tools

For domain-specific logic, create TypeScript tools instead of custom task types:

<Steps>
<Step title="Create a TypeScript Tool" description="Implement your business logic as a TypeScript function">

```typescript title="email_validator.ts"
interface EmailValidationInput {
  recipient_list: string[];
  domain_whitelist?: string[];
  check_deliverability?: boolean;
}

interface EmailValidationOutput {
  valid_emails: string[];
  invalid_emails: string[];
  validation_results: Array<{
    email: string;
    valid: boolean;
    reason?: string;
  }>;
}

export async function validateEmails({ 
  input 
}: { 
  input: EmailValidationInput 
}): Promise<EmailValidationOutput> {
  const { recipient_list, domain_whitelist, check_deliverability } = input;
  
  const valid_emails: string[] = [];
  const invalid_emails: string[] = [];
  const validation_results: Array<{ email: string; valid: boolean; reason?: string }> = [];
  
  for (const email of recipient_list) {
    const validation = await validateSingleEmail(email, {
      domain_whitelist,
      check_deliverability
    });
    
    validation_results.push(validation);
    
    if (validation.valid) {
      valid_emails.push(email);
    } else {
      invalid_emails.push(email);
    }
  }
  
  return {
    valid_emails,
    invalid_emails,
    validation_results
  };
}

async function validateSingleEmail(
  email: string, 
  options: { domain_whitelist?: string[]; check_deliverability?: boolean }
): Promise<{ email: string; valid: boolean; reason?: string }> {
  // Email format validation
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    return { email, valid: false, reason: "Invalid email format" };
  }
  
  // Domain whitelist check
  if (options.domain_whitelist) {
    const domain = email.split('@')[1];
    if (!options.domain_whitelist.includes(domain)) {
      return { email, valid: false, reason: "Domain not whitelisted" };
    }
  }
  
  // Deliverability check (if enabled)
  if (options.check_deliverability) {
    // Implementation would check MX records, etc.
    // For demo purposes, we'll simulate this
    const isDeliverable = await checkEmailDeliverability(email);
    if (!isDeliverable) {
      return { email, valid: false, reason: "Email not deliverable" };
    }
  }
  
  return { email, valid: true };
}

async function checkEmailDeliverability(email: string): Promise<boolean> {
  // Placeholder for actual deliverability check
  // In practice, this would check MX records, validate domains, etc.
  return true;
}
```

</Step>

<Step title="Use the Tool in Your Workflow" description="Reference the tool in your task configuration">

```yaml title="workflow.yaml"
- id: validate_recipients
  type: basic
  $use: tool(local::tools.#(id=="email_validator"))
  with:
    recipient_list: "{{ .workflow.input.subscribers }}"
    domain_whitelist: ["company.com", "trusted-partner.com"]
    check_deliverability: true
```

</Step>

<Step title="Handle Tool Results" description="Process the tool output in subsequent tasks">

```yaml title="workflow.yaml"
- id: send_validation_report
  type: basic
  $use: agent(local::agents.#(id=="reporter"))
  action: generate_report
  with:
    total_emails: "{{ len .workflow.input.subscribers }}"
    valid_count: "{{ len .tasks.validate_recipients.output.valid_emails }}"
    invalid_count: "{{ len .tasks.validate_recipients.output.invalid_emails }}"
    validation_details: "{{ .tasks.validate_recipients.output.validation_results }}"
```

</Step>
</Steps>

### 3. AI-Powered Processing with Agents

Use AI agents for intelligent, adaptive processing:

```yaml
# AI-powered content generation and analysis
- id: intelligent_content_processor
  type: composite
  tasks:
    # Analyze content requirements
    - id: analyze_requirements
      type: basic
      $use: agent(local::agents.#(id=="content_analyzer"))
      action: analyze_content_needs
      with:
        target_audience: "{{ .workflow.input.audience }}"
        content_type: "{{ .workflow.input.type }}"
        business_context: "{{ .workflow.input.context }}"
        constraints: "{{ .workflow.input.constraints }}"
    
    # Generate content variations
    - id: generate_variations
      type: collection
      mode: parallel
      items: "{{ .tasks.analyze_requirements.output.content_strategies }}"
      task:
        id: "generate_content_{{ .index }}"
        type: basic
        $use: agent(local::agents.#(id=="content_generator"))
        action: generate_content
        with:
          strategy: "{{ .item }}"
          requirements: "{{ .tasks.analyze_requirements.output.requirements }}"
          style_guide: "{{ .workflow.input.style_guide }}"
    
    # Evaluate and select best content
    - id: evaluate_content
      type: basic
      $use: agent(local::agents.#(id=="content_evaluator"))
      action: evaluate_variations
      with:
        content_variations: "{{ .tasks.generate_variations.output }}"
        evaluation_criteria: "{{ .tasks.analyze_requirements.output.criteria }}"
        target_metrics: "{{ .workflow.input.target_metrics }}"
```

This demonstrates how AI agents can:
- **Analyze Requirements**: Understand complex business needs and constraints
- **Generate Variations**: Create multiple approaches to solving problems
- **Evaluate Solutions**: Assess and select the best outcomes based on criteria
- **Adapt to Context**: Adjust behavior based on business rules and feedback

## Best Practices

### 1. Task Composition Strategy

**Use the Right Task Type for Each Job:**

```yaml
# Combine task types effectively
- id: comprehensive_workflow
  type: composite
  tasks:
    # Use basic tasks for single operations
    - id: validate_input
      type: basic
      $use: tool(local::tools.#(id=="validator"))
    
    # Use router tasks for conditional logic
    - id: route_by_priority
      type: router
      condition: "{{ .workflow.input.priority }}"
      routes:
        high:
          type: parallel  # Use parallel for urgent processing
          tasks:
            - id: high_priority_handler
              type: basic
              $use: agent(local::agents.#(id=="priority_handler"))
        normal:
          type: collection  # Use collection for batch processing
          items: "{{ .workflow.input.items }}"
          task:
            type: basic
            $use: tool(local::tools.#(id=="batch_processor"))
    
    # Use aggregate tasks to combine results
    - id: combine_results
      type: aggregate
      inputs:
        - "{{ .tasks.route_by_priority.output }}"
        - "{{ .tasks.validate_input.output }}"
```

### 2. Error Handling and Resilience

**Build robust workflows with proper error handling:**

```yaml
- id: resilient_workflow
  type: composite
  on_error:
    next: error_handler
  tasks:
    - id: primary_task
      type: basic
      $use: tool(local::tools.#(id=="primary_processor"))
      on_error:
        next: fallback_task
    
    - id: fallback_task
      type: basic
      $use: tool(local::tools.#(id=="fallback_processor"))
      on_error:
        next: manual_intervention
    
    - id: manual_intervention
      type: signal
      signal_name: "manual_review_required"
      with:
        error_context: "{{ .error }}"
        workflow_state: "{{ .workflow }}"
```

### 3. Performance Optimization

**Optimize workflow performance with smart task selection:**

```yaml
- id: optimized_workflow
  type: composite
  tasks:
    # Use parallel tasks for independent operations
    - id: parallel_processing
      type: parallel
      strategy: wait_all
      max_workers: 8
      tasks:
        - id: process_batch_1
          type: collection
          mode: parallel
          items: "{{ slice .workflow.input.data 0 1000 }}"
        - id: process_batch_2
          type: collection
          mode: parallel
          items: "{{ slice .workflow.input.data 1000 2000 }}"
    
    # Use memory tasks for caching expensive operations
    - id: cache_results
      type: memory
      operation: store
      key: "processed_data_{{ .workflow.id }}"
      value: "{{ .tasks.parallel_processing.output }}"
```

## CLI Commands

### Configuration Management
```bash
# View task type configuration and system settings
compozy config show

# Validate task type definitions and syntax
compozy config validate

# Check system diagnostics for task execution environment
compozy config diagnostics
```

### User Management
```bash
# Create new user for task development collaboration
compozy auth create-user

# List users with task development permissions
compozy auth list-users

# Update user roles for task system access
compozy auth update-user

# Remove user from task development environment
compozy auth delete-user
```

## Next Steps

<ReferenceCardList>
  <ReferenceCard
    title="Basic Tasks"
    description="Foundation patterns and core task execution principles"
    href="/docs/core/tasks/basic-tasks"
    icon="Cog"
  />
  <ReferenceCard
    title="Composite Tasks"
    description="Group tasks for reusability and sequential orchestration"
    href="/docs/core/tasks/composite-tasks"
    icon="Layers"
  />
  <ReferenceCard
    title="TypeScript Tool Development"
    description="Implement custom business logic with TypeScript tools"
    href="/docs/core/tools/typescript-development"
    icon="Code"
  />
  <ReferenceCard
    title="Agent Configuration"
    description="Configure AI agents for intelligent task processing"
    href="/docs/core/agents/overview"
    icon="Bot"
  />
  <ReferenceCard
    title="Business Workflow Examples"
    description="Real-world patterns and sophisticated automation examples"
    href="/docs/core/examples/business-workflows"
    icon="Building"
  />
  <ReferenceCard
    title="Flow Control"
    description="Advanced routing and conditional workflow orchestration"
    href="/docs/core/tasks/flow-control"
    icon="GitBranch"
  />
</ReferenceCardList>