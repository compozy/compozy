---
title: Composite Tasks
description: Understanding composite task execution for grouping related tasks into logical units with sequential orchestration
---

Composite tasks are the **organizational building blocks** of Compozy workflows, enabling you to group related tasks into logical units that execute sequentially. They transform complex multi-step processes into reusable, maintainable components while providing sophisticated control over execution strategies and error handling.



## Overview

Composite tasks provide sophisticated sequential orchestration for multi-step processes:

- **ðŸ”„ Sequential Execution**: Tasks run in order, with each task waiting for the previous to complete
- **ðŸ“¦ Logical Grouping**: Related tasks are organized into cohesive units
- **ðŸ”„ Dependency Management**: Task outputs automatically flow to subsequent tasks
- **ðŸš« Strategy Control**: Configurable error handling with `fail_fast` and `best_effort` strategies
- **ðŸ”„ Template Integration**: Full support for dynamic parameters and cross-task data flow
- **ðŸ“Š Hierarchical Organization**: Composite tasks can contain other composite tasks

<Callout type="info">
Composite tasks are always executed sequentially (one after another), making them ideal for multi-step processes where each step depends on the previous one's completion.
</Callout>

## Task Structure

### Core Configuration

Every composite task shares this fundamental structure:

```yaml
id: task-name
type: composite
strategy: fail_fast # or best_effort
tasks:
  - id: first-task
    type: basic
    $use: agent(local::agents.#(id=="processor"))
    # ... task configuration
  - id: second-task
    type: basic
    $use: tool(local::tools.#(id=="formatter"))
    # ... task configuration
outputs:
  result: "{{ .tasks.second-task.output.result }}"
on_success:
  next: next-workflow-task
on_error:
  next: error-handler
```

### Key Components

<Tabs items={["Strategy Control", "Task Dependencies", "Output Aggregation", "Error Handling"]}>
<Tab value="Strategy Control">

Composite tasks support two execution strategies:

```yaml
# Fail Fast Strategy (default)
id: critical-pipeline
type: composite
strategy: fail_fast  # Stop immediately on first failure

tasks:
  - id: validate-input
    type: basic
    $use: agent(local::agents.#(id=="validator"))
    with:
      data: "{{ .workflow.input.data }}"

  - id: process-data
    type: basic
    $use: tool(local::tools.#(id=="processor"))
    with:
      validated_data: "{{ .tasks.validate-input.output.result }}"

  - id: save-results
    type: basic
    $use: tool(local::tools.#(id=="database"))
    with:
      processed_data: "{{ .tasks.process-data.output.result }}"
```

```yaml
# Best Effort Strategy
id: data-enrichment
type: composite
strategy: best_effort  # Continue even if some tasks fail

tasks:
  - id: extract-metadata
    type: basic
    $use: tool(local::tools.#(id=="metadata-extractor"))
    
  - id: enhance-data
    type: basic
    $use: agent(local::agents.#(id=="enhancer"))
    # This task will run even if extract-metadata fails
    
  - id: final-processing
    type: basic
    $use: tool(local::tools.#(id=="finalizer"))
    # This task will run regardless of previous failures
```

</Tab>
<Tab value="Task Dependencies">

Tasks within a composite automatically have access to outputs from previous tasks:

```yaml
id: document-processing
type: composite
strategy: fail_fast

tasks:
  - id: extract-text
    type: basic
    $use: tool(local::tools.#(id=="text-extractor"))
    with:
      document: "{{ .workflow.input.document }}"

  - id: analyze-content
    type: basic
    $use: agent(local::agents.#(id=="analyzer"))
    with:
      # Access output from previous task
      text: "{{ .tasks.extract-text.output.content }}"
      metadata: "{{ .tasks.extract-text.output.metadata }}"

  - id: generate-summary
    type: basic
    $use: agent(local::agents.#(id=="summarizer"))
    with:
      # Access outputs from multiple previous tasks
      original_text: "{{ .tasks.extract-text.output.content }}"
      analysis: "{{ .tasks.analyze-content.output.analysis }}"
      confidence: "{{ .tasks.analyze-content.output.confidence }}"

outputs:
  # Aggregate outputs from all tasks
  extracted_text: "{{ .tasks.extract-text.output.content }}"
  analysis_result: "{{ .tasks.analyze-content.output.analysis }}"
  summary: "{{ .tasks.generate-summary.output.summary }}"
  processing_metadata:
    total_tasks: 3
    completed_tasks: "{{ len .tasks }}"
    success_rate: "{{ .composite_metadata.success_rate }}"
```

</Tab>
<Tab value="Output Aggregation">

Composite tasks can aggregate outputs from all subtasks:

```yaml
id: user-onboarding
type: composite
strategy: fail_fast

tasks:
  - id: validate-user
    type: basic
    $use: agent(local::agents.#(id=="validator"))
    with:
      user_data: "{{ .workflow.input.user_data }}"

  - id: create-account
    type: basic
    $use: tool(local::tools.#(id=="account-creator"))
    with:
      validated_data: "{{ .tasks.validate-user.output.validated_data }}"

  - id: send-welcome
    type: basic
    $use: tool(local::tools.#(id=="email-sender"))
    with:
      user_id: "{{ .tasks.create-account.output.user_id }}"
      email: "{{ .tasks.create-account.output.email }}"

  - id: setup-preferences
    type: basic
    $use: agent(local::agents.#(id=="preference-manager"))
    with:
      user_id: "{{ .tasks.create-account.output.user_id }}"
      preferences: "{{ .workflow.input.preferences }}"

# Comprehensive output aggregation
outputs:
  user_id: "{{ .tasks.create-account.output.user_id }}"
  account_status: "{{ .tasks.create-account.output.status }}"
  welcome_sent: "{{ .tasks.send-welcome.output.success }}"
  preferences_configured: "{{ .tasks.setup-preferences.output.success }}"
  
  # Metadata about the composite execution
  onboarding_summary:
    total_steps: 4
    completed_steps: "{{ .composite_metadata.child_count }}"
    execution_time: "{{ .task.duration }}"
    success: "{{ not .task.error }}"
    failed_step: "{{ .task.error.task_id | default 'none' }}"
```

</Tab>
<Tab value="Error Handling">

Comprehensive error handling and recovery strategies:

```yaml
id: resilient-pipeline
type: composite
strategy: fail_fast

tasks:
  - id: critical-validation
    type: basic
    $use: agent(local::agents.#(id=="validator"))
    with:
      data: "{{ .workflow.input.data }}"
    
    # Individual task error handling
    retry_policy:
      maximum_attempts: 3
      initial_interval: 1s
      maximum_interval: 10s
    
    on_error:
      next: validation-fallback
      with:
        original_data: "{{ .workflow.input.data }}"
        error_details: "{{ .task.error }}"

  - id: primary-processing
    type: basic
    $use: tool(local::tools.#(id=="processor"))
    with:
      validated_data: "{{ .tasks.critical-validation.output.result }}"
    
    timeout: 30s
    heartbeat_timeout: 10s

  - id: backup-processing
    type: basic
    $use: tool(local::tools.#(id=="backup-processor"))
    with:
      data: "{{ .tasks.critical-validation.output.result }}"
    
    # Conditional execution based on primary processing
    condition: "{{ .tasks.primary-processing.error }}"

# Composite-level error handling
on_error:
  next: composite-error-handler
  with:
    failed_task: "{{ .task.error.task_id }}"
    error_message: "{{ .task.error.message }}"
    completed_tasks: "{{ keys .tasks }}"
    partial_results: "{{ .tasks }}"

# Timeout for entire composite
timeout: 5m
```

</Tab>
</Tabs>

## Execution Strategies

### Fail Fast Strategy

The `fail_fast` strategy (default) stops execution immediately when any task fails:

```yaml
id: financial-transaction
type: composite
strategy: fail_fast  # Critical for financial operations

tasks:
  - id: validate-account
    type: basic
    $use: agent(local::agents.#(id=="account-validator"))
    with:
      account_id: "{{ .workflow.input.account_id }}"
      amount: "{{ .workflow.input.amount }}"

  - id: check-balance
    type: basic
    $use: tool(local::tools.#(id=="balance-checker"))
    with:
      account_id: "{{ .workflow.input.account_id }}"
      required_amount: "{{ .workflow.input.amount }}"

  - id: process-transaction
    type: basic
    $use: tool(local::tools.#(id=="transaction-processor"))
    with:
      account_id: "{{ .workflow.input.account_id }}"
      amount: "{{ .workflow.input.amount }}"
      validation_result: "{{ .tasks.validate-account.output.result }}"

# If any task fails, the entire composite fails immediately
# No subsequent tasks will execute
```

**âœ… Use fail_fast when:**
- All tasks must succeed for the process to be valid
- Failure of any step makes subsequent steps meaningless
- System integrity or data consistency is critical
- Financial, legal, or security-sensitive operations

### Best Effort Strategy

The `best_effort` strategy continues execution even when some tasks fail:

```yaml
id: data-enrichment-pipeline
type: composite
strategy: best_effort  # Continue despite failures

tasks:
  - id: extract-basic-info
    type: basic
    $use: tool(local::tools.#(id=="info-extractor"))
    with:
      data: "{{ .workflow.input.raw_data }}"

  - id: enrich-with-external-api
    type: basic
    $use: tool(local::tools.#(id=="external-enricher"))
    with:
      basic_info: "{{ .tasks.extract-basic-info.output.info }}"
    # This might fail due to API issues, but we continue

  - id: apply-ml-analysis
    type: basic
    $use: agent(local::agents.#(id=="ml-analyzer"))
    with:
      data: "{{ .tasks.extract-basic-info.output.info }}"
      enriched_data: "{{ .tasks.enrich-with-external-api.output.data | default dict }}"
    # This runs even if external enrichment failed

  - id: generate-report
    type: basic
    $use: tool(local::tools.#(id=="report-generator"))
    with:
      basic_info: "{{ .tasks.extract-basic-info.output.info }}"
      enriched_data: "{{ .tasks.enrich-with-external-api.output.data | default dict }}"
      analysis: "{{ .tasks.apply-ml-analysis.output.analysis | default dict }}"

outputs:
  # Collect all available results
  basic_info: "{{ .tasks.extract-basic-info.output.info }}"
  enriched_data: "{{ .tasks.enrich-with-external-api.output.data | default null }}"
  analysis: "{{ .tasks.apply-ml-analysis.output.analysis | default null }}"
  report: "{{ .tasks.generate-report.output.report }}"
  
  # Track which tasks succeeded/failed
  enrichment_success: "{{ not .tasks.enrich-with-external-api.error }}"
  analysis_success: "{{ not .tasks.apply-ml-analysis.error }}"
  overall_success: "{{ not .task.error }}"
```

**âœ… Use best_effort when:**
- Some tasks are optional or provide enhancement
- Partial results are still valuable
- System should be resilient to external service failures
- Data collection or enrichment scenarios

## Hierarchical Organization

Composite tasks can contain other composite tasks for complex workflows:

```yaml
id: complete-document-pipeline
type: composite
strategy: fail_fast

tasks:
  - id: document-processing
    type: composite
    strategy: best_effort  # Some processing steps can fail
    tasks:
      - id: extract-text
        type: basic
        $use: tool(local::tools.#(id=="text-extractor"))
        with:
          document: "{{ .workflow.input.document }}"

      - id: extract-images
        type: basic
        $use: tool(local::tools.#(id=="image-extractor"))
        with:
          document: "{{ .workflow.input.document }}"

      - id: extract-metadata
        type: basic
        $use: tool(local::tools.#(id=="metadata-extractor"))
        with:
          document: "{{ .workflow.input.document }}"

  - id: content-analysis
    type: composite
    strategy: fail_fast  # Analysis must be complete
    tasks:
      - id: analyze-text
        type: basic
        $use: agent(local::agents.#(id=="text-analyzer"))
        with:
          text: "{{ .tasks.document-processing.tasks.extract-text.output.content }}"

      - id: analyze-structure
        type: basic
        $use: agent(local::agents.#(id=="structure-analyzer"))
        with:
          text: "{{ .tasks.document-processing.tasks.extract-text.output.content }}"
          metadata: "{{ .tasks.document-processing.tasks.extract-metadata.output.metadata }}"

  - id: generate-outputs
    type: composite
    strategy: best_effort  # Some outputs are optional
    tasks:
      - id: create-summary
        type: basic
        $use: agent(local::agents.#(id=="summarizer"))
        with:
          text_analysis: "{{ .tasks.content-analysis.tasks.analyze-text.output.analysis }}"
          structure_analysis: "{{ .tasks.content-analysis.tasks.analyze-structure.output.structure }}"

      - id: create-keywords
        type: basic
        $use: agent(local::agents.#(id=="keyword-extractor"))
        with:
          text_analysis: "{{ .tasks.content-analysis.tasks.analyze-text.output.analysis }}"

      - id: create-report
        type: basic
        $use: tool(local::tools.#(id=="report-generator"))
        with:
          summary: "{{ .tasks.create-summary.output.summary }}"
          keywords: "{{ .tasks.create-keywords.output.keywords }}"
          raw_data: "{{ .tasks.document-processing.outputs }}"

outputs:
  processing_results: "{{ .tasks.document-processing.outputs }}"
  analysis_results: "{{ .tasks.content-analysis.outputs }}"
  final_outputs: "{{ .tasks.generate-outputs.outputs }}"
  
  # High-level summary
  document_summary: "{{ .tasks.generate-outputs.tasks.create-summary.output.summary }}"
  keywords: "{{ .tasks.generate-outputs.tasks.create-keywords.output.keywords }}"
  full_report: "{{ .tasks.generate-outputs.tasks.create-report.output.report }}"
```

## Template Expressions

Composite tasks support powerful template expressions for dynamic configuration and data flow:

### Cross-Task Data Flow

```yaml
id: user-workflow
type: composite
strategy: fail_fast

tasks:
  - id: load-user
    type: basic
    $use: tool(local::tools.#(id=="user-loader"))
    with:
      user_id: "{{ .workflow.input.user_id }}"

  - id: process-preferences
    type: basic
    $use: agent(local::agents.#(id=="preference-processor"))
    with:
      user_data: "{{ .tasks.load-user.output.user }}"
      preferences: "{{ .workflow.input.preferences }}"
      # Complex data transformation
      enhanced_profile:
        id: "{{ .tasks.load-user.output.user.id }}"
        name: "{{ .tasks.load-user.output.user.name }}"
        email: "{{ .tasks.load-user.output.user.email }}"
        settings: "{{ .workflow.input.preferences }}"
        last_seen: "{{ .tasks.load-user.output.user.last_activity }}"
        account_type: "{{ .tasks.load-user.output.user.subscription.type }}"

  - id: update-database
    type: basic
    $use: tool(local::tools.#(id=="database-updater"))
    with:
      # Conditional data based on previous results
      update_data: |
        {{- if .tasks.process-preferences.output.changes -}}
        {
          "user_id": "{{ .tasks.load-user.output.user.id }}",
          "preferences": {{ .tasks.process-preferences.output.updated_preferences | toJson }},
          "updated_at": "{{ now }}",
          "updated_by": "{{ .workflow.input.requester_id }}"
        }
        {{- else -}}
        null
        {{- end -}}

outputs:
  # Computed results from multiple tasks
  user_profile: "{{ .tasks.load-user.output.user }}"
  preferences_updated: "{{ .tasks.process-preferences.output.changes }}"
  database_updated: "{{ .tasks.update-database.output.success }}"
  
  # Conditional outputs
  update_summary: |
    {{- if .tasks.process-preferences.output.changes -}}
    User {{ .tasks.load-user.output.user.name }} preferences updated successfully
    {{- else -}}
    No changes were made to user preferences
    {{- end -}}
  
  # Mathematical computations
  processing_time: "{{ add .tasks.load-user.duration .tasks.process-preferences.duration .tasks.update-database.duration }}"
  success_rate: "{{ div (sub 3 (len .task.errors)) 3 }}"
```

### Conditional Task Execution

```yaml
id: conditional-processing
type: composite
strategy: best_effort

tasks:
  - id: check-eligibility
    type: basic
    $use: agent(local::agents.#(id=="eligibility-checker"))
    with:
      user_data: "{{ .workflow.input.user_data }}"

  - id: standard-processing
    type: basic
    $use: tool(local::tools.#(id=="standard-processor"))
    with:
      data: "{{ .workflow.input.data }}"
    # Only run if user is eligible
    condition: "{{ .tasks.check-eligibility.output.eligible }}"

  - id: premium-processing
    type: basic
    $use: tool(local::tools.#(id=="premium-processor"))
    with:
      data: "{{ .workflow.input.data }}"
    # Only run if user is premium and eligible
    condition: "{{ and .tasks.check-eligibility.output.eligible .tasks.check-eligibility.output.premium }}"

  - id: generate-report
    type: basic
    $use: tool(local::tools.#(id=="report-generator"))
    with:
      # Use results from whichever processing task ran
      standard_results: "{{ .tasks.standard-processing.output.results | default null }}"
      premium_results: "{{ .tasks.premium-processing.output.results | default null }}"
      eligibility: "{{ .tasks.check-eligibility.output }}"
    # Always run the report generation
    condition: "{{ .tasks.check-eligibility.output.eligible }}"
```

## Practical Examples

### Example 1: Customer Onboarding Pipeline

<Steps>
<Step>

**Complete User Onboarding Process**

```yaml
id: customer-onboarding
type: composite
strategy: fail_fast  # Critical business process

tasks:
  - id: validate-user-data
    type: basic
    $use: agent(local::agents.#(id=="validation-service"))
    with:
      email: "{{ .workflow.input.email }}"
      name: "{{ .workflow.input.name }}"
      phone: "{{ .workflow.input.phone }}"
    
    input:
      type: object
      properties:
        email:
          type: string
          format: email
        name:
          type: string
          minLength: 2
        phone:
          type: string
      required: [email, name]

  - id: create-user-account
    type: basic
    $use: tool(local::tools.#(id=="account-creator"))
    with:
      validated_data: "{{ .tasks.validate-user-data.output }}"
      account_type: "{{ .workflow.input.account_type | default 'standard' }}"
    
    timeout: 30s
    retry_policy:
      maximum_attempts: 2
      initial_interval: 1s

  - id: send-welcome-email
    type: basic
    $use: tool(local::tools.#(id=="email-sender"))
    with:
      user_id: "{{ .tasks.create-user-account.output.user_id }}"
      email: "{{ .tasks.create-user-account.output.email }}"
      name: "{{ .tasks.create-user-account.output.name }}"
      template: "welcome_new_user"
    
    env:
      SMTP_HOST: "{{ .env.SMTP_HOST }}"
      SMTP_PORT: "{{ .env.SMTP_PORT }}"

  - id: initialize-user-preferences
    type: basic
    $use: agent(local::agents.#(id=="settings-service"))
    with:
      user_id: "{{ .tasks.create-user-account.output.user_id }}"
      preferences: "{{ .workflow.input.preferences }}"
      email_sent: "{{ .tasks.send-welcome-email.output.success }}"

outputs:
  user_id: "{{ .tasks.create-user-account.output.user_id }}"
  account_status: "{{ .tasks.create-user-account.output.status }}"
  welcome_email_sent: "{{ .tasks.send-welcome-email.output.success }}"
  preferences_initialized: "{{ .tasks.initialize-user-preferences.output.success }}"
  
  onboarding_summary:
    completed_at: "{{ now }}"
    total_steps: 4
    user_email: "{{ .workflow.input.email }}"
    success: true

on_success:
  next: user-onboarding-complete
  with:
    user_id: "{{ .output.user_id }}"
    completed_at: "{{ now }}"

on_error:
  next: onboarding-failed
  with:
    user_email: "{{ .workflow.input.email }}"
    failed_step: "{{ .task.error.task_id }}"
    error_message: "{{ .task.error.message }}"
```

</Step>
</Steps>

### Example 2: Document Processing Pipeline

```yaml
id: document-processing
type: composite
strategy: best_effort

tasks:
  - id: extract-content
    type: basic
    $use: tool(local::tools.#(id=="document-extractor"))
    with:
      document: "{{ .workflow.input.document }}"

  - id: analyze-content
    type: basic
    $use: agent(local::agents.#(id=="text-analyzer"))
    with:
      text: "{{ .tasks.extract-content.output.text }}"

  - id: generate-summary
    type: basic
    $use: agent(local::agents.#(id=="summarizer"))
    with:
      text: "{{ .tasks.extract-content.output.text }}"
      analysis: "{{ .tasks.analyze-content.output.analysis }}"

outputs:
  summary: "{{ .tasks.generate-summary.output.summary }}"
  analysis: "{{ .tasks.analyze-content.output.analysis }}"
```

## Best Practices

1. **Logical Grouping**: Group related tasks that naturally belong together
2. **Appropriate Strategy**: Choose `fail_fast` for critical processes, `best_effort` for enhancement
3. **Clear Dependencies**: Ensure task order reflects logical dependencies
4. **Error Handling**: Plan for partial failures and recovery scenarios
5. **Performance**: Set appropriate timeouts and minimize data passing
6. **Output Design**: Create meaningful aggregated outputs

Composite tasks provide powerful sequential orchestration capabilities that enable complex multi-step processes while maintaining clear organization and robust error handling. They serve as the foundation for building sophisticated workflows that can handle both simple linear processes and complex branching logic.

## CLI Commands

### Configuration Management
```bash
# View current configuration including composite task settings
compozy config show

# Validate composite task configurations  
compozy config validate

# Run diagnostics to check composite task setup
compozy config diagnostics
```

### User Management
```bash
# Create new user for collaborative composite task development
compozy auth create-user

# List all users with access to composite tasks
compozy auth list-users

# Update user permissions for composite task management
compozy auth update-user

# Remove user access to composite task systems
compozy auth delete-user
```

## Related Documentation

<ReferenceCardList>
  <ReferenceCard
    title="Basic Tasks"
    description="Learn about the fundamental building blocks that compose composite tasks"
    href="/docs/core/tasks/basic-tasks"
    icon="Cog"
  />
  <ReferenceCard
    title="Parallel Tasks"
    description="Understand concurrent execution patterns that complement sequential composite tasks"
    href="/docs/core/tasks/parallel-tasks"
    icon="Layers"
  />
  <ReferenceCard
    title="Collection Tasks"
    description="Explore array processing patterns that can contain composite task templates"
    href="/docs/core/tasks/collection-tasks"
    icon="List"
  />
  <ReferenceCard
    title="Error Handling"
    description="Master error handling strategies for robust composite task workflows"
    href="/docs/core/tasks/error-handling"
    icon="AlertTriangle"
  />
</ReferenceCardList>

## Next Steps

<ReferenceCardList>
  <ReferenceCard
    title="Router Tasks"
    description="Add conditional branching to your composite task workflows"
    href="/docs/core/tasks/router-tasks"
    icon="GitBranch"
  />
  <ReferenceCard
    title="Signal Tasks"
    description="Coordinate composite tasks across different workflows"
    href="/docs/core/tasks/signal-tasks"
    icon="Radio"
  />
  <ReferenceCard
    title="Workflow Examples"
    description="Explore real-world composite task patterns and use cases"
    href="/docs/core/examples/composite-examples"
    icon="FileText"
  />
  <ReferenceCard
    title="Agent Integration"
    description="Learn how to integrate AI agents within composite task workflows"
    href="/docs/core/agents/overview"
    icon="Bot"
  />
</ReferenceCardList>
