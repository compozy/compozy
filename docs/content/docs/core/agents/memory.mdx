---
title: "Agent Memory"
description: "Memory systems that enable agents to maintain context and state across interactions"
---

## Overview

Memory in Compozy allows agents to maintain context across workflow steps, sessions, and even between different workflow executions. This enables stateful interactions, personalization, and complex multi-turn conversations.

## Key Features

<FeatureCardList cols={2} size="default">
  <FeatureCard
    title="Persistent Context"
    description="Maintain conversation history and state across multiple interactions and workflow executions"
    icon="Database"
  />
  <FeatureCard
    title="Multiple Backends"
    description="Choose from Redis, PostgreSQL, or in-memory storage based on your performance and persistence needs"
    icon="HardDrive"
  />
  <FeatureCard
    title="Dynamic Keys"
    description="Use template expressions to create user-specific, session-based, or context-aware memory instances"
    icon="Key"
  />
  <FeatureCard
    title="Access Control"
    description="Configure read-write or read-only access modes to control how agents interact with memory"
    icon="Shield"
  />
</FeatureCardList>

## Memory Architecture

<Mermaid chart={`graph TD
    A[Agent] -->|References| B[Memory Configuration]
    B -->|Resolves| C[Memory Instance]
    C -->|Read/Write| D[Memory Storage]

    D --> E[Redis Backend]
    D --> F[PostgreSQL Backend]
    D --> G[In-Memory Backend]

    C -->|Contains| H[Messages]
    H --> I[System Messages]
    H --> J[User Messages]
    H --> K[Assistant Messages]`} />

## Memory Configuration

### Basic Memory Setup

Configure memory references in your agent:

```yaml
agents:
  - id: conversational-agent
    config:
      provider: openai
      model: gpt-4-turbo-preview
    instructions: |
      You are a helpful assistant that remembers previous conversations.
      Use context from memory to provide personalized responses.
    memory:
      - id: user_memory           # Memory resource ID
        key: "user:{{.workflow.input.user_id}}"  # Dynamic key
        mode: "read-write"        # Access mode
```

### Memory Reference Structure

Memory references in agent configurations connect agents to memory resources. Each reference specifies which memory resource to use, how to access it, and provides a template key for dynamic memory instances.

Each memory reference requires:

| Field | Type | Description | Required |
|-------|------|-------------|----------|
| `id` | string | References a memory resource | Yes |
| `key` | string | Template for the memory instance key | Yes |
| `mode` | string | Access mode: `read-write` or `read-only` | No (default: `read-write`) |

### Dynamic Key Templates

Memory keys support template expressions that are evaluated at runtime to create unique memory instances. This enables context-aware memory management where different users, sessions, or workflows can have separate memory spaces.

Memory keys support template expressions:

```yaml
memory:
  # User-specific memory
  - id: user_context
    key: "user:{{.workflow.input.user_id}}"

  # Session-based memory
  - id: session_memory
    key: "session:{{.workflow.input.session_id}}"

  # Conversation threads
  - id: conversation
    key: "thread:{{.workflow.input.thread_id}}:{{.workflow.input.user_id}}"

  # Time-based memory
  - id: daily_context
    key: "daily:{{.workflow.input.date}}:{{.workflow.input.user_id}}"
```

## Memory Resources

Memory resources define the storage configuration and schema for memory instances. These resources are referenced by agents through memory references and provide the actual storage backend and configuration.

Define memory resources that agents can reference:

```yaml
# memory/user_memory.yaml
resource: memory
id: user_memory
description: Persistent user context and preferences

config:
  provider: redis
  ttl: 2592000  # 30 days in seconds
  namespace: "compozy:memory:users"

schema:
  type: object
  properties:
    preferences:
      type: object
    history:
      type: array
      items:
        type: object
```

## Memory Access Patterns

### Read-Write Memory

Read-write memory access allows agents to both read existing memory content and add new messages or modify the conversation history. This is the default mode and is suitable for most conversational agents.

Full access to read and modify memory:

```yaml
agents:
  - id: personal-assistant
    memory:
      - id: user_preferences
        key: "prefs:{{.workflow.input.user_id}}"
        mode: "read-write"

    actions:
      - id: update-preferences
        prompt: |
          Based on the user's request: {{.input.request}}

          Current preferences from memory will be available.
          Update preferences as needed based on the conversation.
```

### Read-Only Memory

Read-only memory access restricts agents to only viewing existing memory content without the ability to modify or add new messages. This is useful for support agents or when you want to provide context without allowing changes.

Access memory without modification rights:

```yaml
agents:
  - id: support-agent
    memory:
      - id: user_history
        key: "history:{{.workflow.input.user_id}}"
        mode: "read-only"

    instructions: |
      You can view user history but cannot modify it.
      Use historical context to provide better support.
```

### Multiple Memory Contexts

Agents can access multiple memory instances simultaneously, allowing them to maintain different types of context (user profiles, team information, project state) within the same conversation.

Agents can access multiple memory instances:

```yaml
agents:
  - id: multi-context-agent
    memory:
      - id: user_profile
        key: "profile:{{.workflow.input.user_id}}"
      - id: team_context
        key: "team:{{.workflow.input.team_id}}"
      - id: project_state
        key: "project:{{.workflow.input.project_id}}"
```

## Memory Content Structure

Memory stores conversation messages with metadata:

```json
{
  "messages": [
    {
      "role": "system",
      "content": "Initial system context",
      "timestamp": "2024-01-15T10:00:00Z"
    },
    {
      "role": "user",
      "content": "User message",
      "timestamp": "2024-01-15T10:00:01Z",
      "metadata": {
        "user_id": "user123",
        "session_id": "sess456"
      }
    },
    {
      "role": "assistant",
      "content": "Agent response",
      "timestamp": "2024-01-15T10:00:02Z",
      "metadata": {
        "agent_id": "personal-assistant",
        "tokens_used": 150
      }
    }
  ]
}
```

## Memory in Action

### Conversational Memory

Build conversational agents with context:

```yaml
# Workflow with conversational memory
tasks:
  - id: chat
    type: basic
    $use: agent(local::agents.#(id="chat-agent"))
    action: respond
    with:
      message: "{{.workflow.input.message}}"

agents:
  - id: chat-agent
    memory:
      - id: conversation
        key: "chat:{{.workflow.input.session_id}}"

    actions:
      - id: respond
        prompt: |
          Continue the conversation naturally.
          User message: {{.input.message}}

          Use previous context to maintain conversation flow.
          Reference earlier topics when relevant.
```

### User Preference Learning

Agents that learn and adapt:

```yaml
agents:
  - id: recommendation-agent
    memory:
      - id: user_preferences
        key: "prefs:{{.workflow.input.user_id}}"

    instructions: |
      You provide personalized recommendations.
      Learn from user feedback and choices.
      Adapt suggestions based on historical preferences.

    actions:
      - id: recommend
        prompt: |
          Suggest items based on:
          - User request: {{.input.request}}
          - Historical preferences from memory
          - Previous successful recommendations
```

### Multi-Agent Collaboration

Share memory between agents:

```yaml
agents:
  - id: researcher
    memory:
      - id: research_notes
        key: "research:{{.workflow.input.topic}}"
        mode: "read-write"
    actions:
      - id: research
        prompt: "Research the topic and store findings in memory"

  - id: writer
    memory:
      - id: research_notes
        key: "research:{{.workflow.input.topic}}"
        mode: "read-only"
    actions:
      - id: write
        prompt: "Write article based on research notes in memory"
```

## Memory Management

### Memory Lifecycle

<Steps numbered size="sm">
  <Step title="Initialization" description="Memory instance created when first referenced with a specific key" />
  <Step title="Population" description="Messages appended during agent interactions" />
  <Step title="Retrieval" description="Full conversation history provided to agent as context" />
  <Step title="Expiration" description="Memory expires based on TTL configuration" />
</Steps>

### Memory Size Considerations

<Callout type="info">
Memory content counts toward the agent's context window. Large conversation histories may need truncation.
</Callout>

Strategies for managing memory size:

<List>
  <ListItem title="Set appropriate TTLs">
    Configure expiration times to automatically remove old memories and prevent unbounded growth
  </ListItem>
  <ListItem title="Use separate memory instances">
    Isolate different contexts using distinct memory keys for better organization and performance
  </ListItem>
  <ListItem title="Implement memory summarization">
    Compress long conversations into concise summaries while preserving key information
  </ListItem>
  <ListItem title="Archive old memories">
    Move historical data to secondary storage for long-term retention without impacting performance
  </ListItem>
</List>

### Memory Operations via API

Manage memory through the HTTP API:

```bash
# Write to memory
curl -X POST http://localhost:5001/api/v0/memory/write \
  -H "Content-Type: application/json" \
  -d '{
    "key": "user:123",
    "message": {
      "role": "system",
      "content": "User prefers technical explanations"
    }
  }'

# Read memory
curl http://localhost:5001/api/v0/memory/read?key=user:123

# Clear memory
curl -X POST http://localhost:5001/api/v0/memory/clear \
  -H "Content-Type: application/json" \
  -d '{"key": "user:123"}'
```

## Advanced Patterns

### Contextual Memory Selection

Dynamically select memory based on context:

```yaml
agents:
  - id: adaptive-agent
    memory:
      - id: "{{.workflow.input.memory_type}}_memory"
        key: "{{.workflow.input.memory_type}}:{{.workflow.input.context_id}}"
```

### Memory Summarization

Implement memory compression for long conversations:

```yaml
actions:
  - id: summarize-conversation
    prompt: |
      The conversation has reached 50 messages.
      Create a concise summary of key points, decisions, and context.
      This summary will replace the full conversation history.
    json_mode: true
    output:
      type: object
      properties:
        summary:
          type: string
        key_points:
          type: array
          items:
            type: string
        user_preferences:
          type: object
```

### Cross-Workflow Memory

Share memory across different workflows:

```yaml
# Workflow 1: Data Collection
agents:
  - id: collector
    memory:
      - id: shared_data
        key: "project:{{.env.PROJECT_ID}}:data"

# Workflow 2: Data Analysis
agents:
  - id: analyzer
    memory:
      - id: shared_data
        key: "project:{{.env.PROJECT_ID}}:data"
```

## Best Practices

<AccordionGroup>
  <Accordion title="Key Design">
    <List>
      <ListItem title="Use hierarchical keys">
        Organize memory with structured key patterns like "domain:entity:id" for better organization
      </ListItem>
      <ListItem title="Include relevant IDs">
        Embed user, session, or workflow IDs in key templates for proper isolation
      </ListItem>
      <ListItem title="Consider key uniqueness">
        Design keys to prevent collisions between different contexts or users
      </ListItem>
      <ListItem title="Document conventions">
        Establish and document consistent key naming patterns across your project
      </ListItem>
    </List>
  </Accordion>

  <Accordion title="Access Control">
    <List>
      <ListItem title="Use read-only mode">
        Apply read-only access when agents only need to view historical context
      </ListItem>
      <ListItem title="Separate by security context">
        Isolate memory instances based on user permissions and security requirements
      </ListItem>
      <ListItem title="Validate user access">
        Verify user authorization before granting access to memory keys
      </ListItem>
      <ListItem title="Implement key sanitization">
        Sanitize dynamic key components to prevent injection attacks
      </ListItem>
    </List>
  </Accordion>

  <Accordion title="Performance">
    <List>
      <ListItem title="Set appropriate TTLs">
        Configure expiration times to prevent unbounded memory growth
      </ListItem>
      <ListItem title="Monitor memory usage">
        Track memory size and token consumption to optimize performance
      </ListItem>
      <ListItem title="Implement pagination">
        Handle large conversation histories with pagination strategies
      </ListItem>
      <ListItem title="Use caching">
        Cache frequently accessed memories to reduce storage backend load
      </ListItem>
    </List>
  </Accordion>

  <Accordion title="Privacy">
    <List>
      <ListItem title="Encrypt sensitive content">
        Apply encryption to memory containing personal or sensitive data
      </ListItem>
      <ListItem title="Implement retention policies">
        Define and enforce data retention rules for compliance
      </ListItem>
      <ListItem title="Provide user controls">
        Enable users to view, export, and delete their memory data
      </ListItem>
      <ListItem title="Audit access patterns">
        Log and monitor memory access for security and compliance
      </ListItem>
    </List>
  </Accordion>
</AccordionGroup>

## Next Steps

<ReferenceCardList>
  <ReferenceCard
    title="Context Management"
    description="Learn about managing agent context effectively"
    href="/docs/core/agents/context"
    icon="Layers"
  />
  <ReferenceCard
    title="Multi-Agent Patterns"
    description="Explore patterns for multi-agent collaboration"
    href="/docs/core/agents/multi-agent-patterns"
    icon="Users"
  />
</ReferenceCardList>
