---
title: "Agent Memory"
description: "Memory systems that enable agents to maintain context and state across interactions"
---

## Overview

Memory in Compozy allows agents to maintain context across workflow steps, sessions, and even between different workflow executions. This enables stateful interactions, personalization, and complex multi-turn conversations. Memory is essential for building AI agents that can remember user preferences, maintain conversation history, and share context between different agents in your workflows.

If you're new to Compozy, start with the [Quick Start guide](/docs/core/getting-started/quick-start) to understand the basics before diving into memory configuration. For a complete understanding of how memory fits into the broader system, see [Core Concepts](/docs/core/getting-started/core-concepts).

<Callout type="info">
**Getting Started with Memory?** Check out our [First Workflow tutorial](/docs/core/getting-started/first-workflow) which includes a simple memory implementation example.
</Callout>

## Key Features

<FeatureCardList cols={2} size="default">
  <FeatureCard
    title="Persistent Context"
    description="Maintain conversation history and state across multiple interactions and workflow executions"
    icon="Database"
  />
  <FeatureCard
    title="Multiple Backends"
    description="Choose from Redis, PostgreSQL, or in-memory storage based on your performance and persistence needs"
    icon="HardDrive"
  />
  <FeatureCard
    title="Dynamic Keys"
    description="Use template expressions to create user-specific, session-based, or context-aware memory instances"
    icon="Key"
  />
  <FeatureCard
    title="Access Control"
    description="Configure read-write or read-only access modes to control how agents interact with memory"
    icon="Shield"
  />
</FeatureCardList>

## Memory Architecture

Understanding the memory architecture is crucial for effective implementation. The system uses a layered approach where agents reference memory configurations that resolve to actual storage instances. Learn more about the technical implementation details and storage backend options.

<Mermaid chart={`graph TD
    A[Agent] -->|References| B[Memory Configuration]
    B -->|Resolves| C[Memory Instance]
    C -->|Read/Write| D[Memory Storage]

    D --> E[Redis Backend]
    D --> F[PostgreSQL Backend]
    D --> G[In-Memory Backend]

    C -->|Contains| H[Messages]
    H --> I[System Messages]
    H --> J[User Messages]
    H --> K[Assistant Messages]`} />

The architecture supports multiple persistence backends with automatic failover and circuit breaker patterns for production reliability.

## Memory Configuration

### Basic Memory Setup

Configure memory references in your agent:

```yaml
agents:
  - id: conversational-agent
    model:
      provider: openai
      model: gpt-4-turbo-preview
    instructions: |
      You are a helpful assistant that remembers previous conversations.
      Use context from memory to provide personalized responses.
    memory:
      - id: user_memory           # Memory resource ID
        key: "user:{{.workflow.input.user_id}}"  # Dynamic key
        mode: "read-write"        # Access mode
```

### Memory Reference Structure

Memory references in agent configurations connect agents to memory resources. Each reference specifies which memory resource to use, how to access it, and provides a template key for dynamic memory instances. This follows the same reference pattern used throughout Compozy for connecting resources.

Each memory reference requires:

| Field | Type | Description | Required |
|-------|------|-------------|----------|
| `id` | string | References a memory resource defined in your memory configuration files | Yes |
| `key` | string | Template for the memory instance key using Go template syntax | Yes |
| `mode` | string | Access mode: `read-write` or `read-only` | No (default: `read-write`) |

For more details on memory resource configuration, see the [Memory Configuration guide](/docs/core/memory/configuration).

### Dynamic Key Templates

Memory keys support template expressions that are evaluated at runtime to create unique memory instances. This enables context-aware memory management where different users, sessions, or workflows can have separate memory spaces. The template system is powered by Go templates with Sprig functions, giving you powerful string manipulation and logic capabilities.

Memory keys support template expressions:

```yaml
memory:
  # User-specific memory
  - id: user_context
    key: "user:{{.workflow.input.user_id}}"

  # Session-based memory
  - id: session_memory
    key: "session:{{.workflow.input.session_id}}"

  # Conversation threads
  - id: conversation
    key: "thread:{{.workflow.input.thread_id}}:{{.workflow.input.user_id}}"

  # Time-based memory
  - id: daily_context
    key: "daily:{{.workflow.input.date}}:{{.workflow.input.user_id}}"
```

Learn more about available template variables and key design best practices.

## Memory Resources

Memory resources define the storage configuration and schema for memory instances. These resources are referenced by agents through memory references and provide the actual storage backend and configuration. Memory resources follow the same resource definition pattern as other Compozy components.

Define memory resources that agents can reference:

```yaml
# memory/user_memory.yaml
resource: memory
id: user_memory
description: Persistent user context and preferences

config:
  provider: redis
  ttl: 2592000  # 30 days in seconds
  namespace: "compozy:memory:users"

schema:
  type: object
  properties:
    preferences:
      type: object
    history:
      type: array
      items:
        type: object
```

For a complete guide on memory resource configuration including persistence options, TTL strategies, and privacy controls, see the [Memory Configuration documentation](/docs/core/memory/configuration). Memory resources are typically stored in the `memory/` directory and can be auto-loaded like other resources.

## Multiple Memory Contexts

Agents can access multiple memory instances simultaneously, allowing them to maintain different types of context (user profiles, team information, project state) within the same conversation. This pattern is essential for multi-agent systems and complex workflows that need to maintain separate contexts for different aspects of the interaction.

Agents can access multiple memory instances:

```yaml
agents:
  - id: multi-context-agent
    memory:
      - id: user_profile
        key: "profile:{{.workflow.input.user_id}}"
      - id: team_context
        key: "team:{{.workflow.input.team_id}}"
      - id: project_state
        key: "project:{{.workflow.input.project_id}}"
```

Each memory instance operates independently with its own eviction policies and TTL settings.

## Memory in Action

### Conversational Memory

Build conversational agents with context. This example demonstrates how to implement a chat system that maintains conversation history across multiple interactions. For more advanced patterns, see conversational AI patterns:

```yaml
# Workflow with conversational memory
tasks:
  - id: chat
    type: basic
    agent: chat-agent
    action: respond
    with:
      message: "{{.workflow.input.message}}"

agents:
  - id: chat-agent
    memory:
      - id: conversation
        key: "chat:{{.workflow.input.session_id}}"

    actions:
      - id: respond
        prompt: |
          Continue the conversation naturally.
          User message: {{.input.message}}

          Use previous context to maintain conversation flow.
          Reference earlier topics when relevant.
```

The agent automatically receives the full conversation history as context. To manage token usage in long conversations, consider implementing memory summarization or sliding window patterns.

## Memory Lifecycle

<Steps numbered size="sm">
  <Step title="Initialization" description="Memory instance created when first referenced with a specific key" />
  <Step title="Population" description="Messages appended during agent interactions" />
  <Step title="Retrieval" description="Full conversation history provided to agent as context" />
  <Step title="Expiration" description="Memory expires based on TTL configuration" />
</Steps>

## Memory Size Considerations

<Callout type="info">
Memory content counts toward the agent's context window. Large conversation histories may need truncation. Learn about token management strategies and context window optimization.
</Callout>

Strategies for managing memory size:

<List>
  <ListItem title="Set appropriate TTLs">
    Configure expiration times to automatically remove old memories and prevent unbounded growth
  </ListItem>
  <ListItem title="Use separate memory instances">
    Isolate different contexts using distinct memory keys for better organization and performance
  </ListItem>
  <ListItem title="Implement memory summarization">
    Compress long conversations into concise summaries while preserving key information
  </ListItem>
  <ListItem title="Archive old memories">
    Move historical data to secondary storage for long-term retention without impacting performance
  </ListItem>
</List>

## Memory Operations via API

Manage memory through the HTTP API. The memory API provides direct access to memory operations for integration with external systems. For detailed API documentation, see the [Memory API reference](/docs/api/memory):

```bash
# Write to memory
curl -X POST http://localhost:5001/api/v0/memory/write \
  -H "Content-Type: application/json" \
  -d '{
    "key": "user:123",
    "message": {
      "role": "system",
      "content": "User prefers technical explanations"
    }
  }'

# Read memory
curl http://localhost:5001/api/v0/memory/read?key=user:123

# Clear memory
curl -X POST http://localhost:5001/api/v0/memory/clear \
  -H "Content-Type: application/json" \
  -d '{"key": "user:123"}'
```

For programmatic access from workflows, use memory tasks instead of direct API calls.

## Advanced Patterns

<Tabs items={["Contextual Memory Selection", "Memory Summarization", "Cross-Workflow Memory"]} defaultValue="Contextual Memory Selection">
  <Tab>
Dynamically select memory based on context. This pattern is useful for multi-tenant applications or when different memory backends are needed based on user type. Learn more about dynamic configuration patterns:

```yaml
agents:
  - id: adaptive-agent
    memory:
      - id: "{{.workflow.input.memory_type}}_memory"
        key: "{{.workflow.input.memory_type}}:{{.workflow.input.context_id}}"
```
  </Tab>

  <Tab>
Implement memory compression for long conversations. This pattern helps manage token limits by periodically summarizing older conversations. For implementation details, see memory summarization strategies:

```yaml
actions:
  - id: summarize-conversation
    prompt: |
      The conversation has reached 50 messages.
      Create a concise summary of key points, decisions, and context.
      This summary will replace the full conversation history.
    output:
      type: object
      properties:
        summary:
          type: string
        key_points:
          type: array
          items:
            type: string
        user_preferences:
          type: object
```
  </Tab>

  <Tab>
Share memory across different workflows. This enables complex multi-step processes where different workflows contribute to and consume from shared memory. For coordination patterns, see signal-based memory sharing:

```yaml
# Workflow 1: Data Collection
agents:
  - id: collector
    memory:
      - id: shared_data
        key: "project:{{.env.PROJECT_ID}}:data"

# Workflow 2: Data Analysis
agents:
  - id: analyzer
    memory:
      - id: shared_data
        key: "project:{{.env.PROJECT_ID}}:data"
```
  </Tab>
</Tabs>

For more advanced patterns including event-driven memory updates and distributed memory architectures, see the integration patterns guide.

## Best Practices

<AccordionGroup>
  <Accordion title="Key Design">
    <List>
      <ListItem title="Use hierarchical keys">
        Organize memory with structured key patterns like "domain:entity:id" for better organization.
      </ListItem>
      <ListItem title="Include relevant IDs">
        Embed user, session, or workflow IDs in key templates for proper isolation.
      </ListItem>
      <ListItem title="Consider key uniqueness">
        Design keys to prevent collisions between different contexts or users.
      </ListItem>
      <ListItem title="Document conventions">
        Establish and document consistent key naming patterns across your project.
      </ListItem>
    </List>
  </Accordion>

  <Accordion title="Access Control">
    <List>
      <ListItem title="Use read-only mode">
        Apply read-only access when agents only need to view historical context.
      </ListItem>
      <ListItem title="Separate by security context">
        Isolate memory instances based on user permissions and security requirements.
      </ListItem>
      <ListItem title="Validate user access">
        Verify user authorization before granting access to memory keys.
      </ListItem>
      <ListItem title="Implement key sanitization">
        Sanitize dynamic key components to prevent injection attacks.
      </ListItem>
    </List>
  </Accordion>

  <Accordion title="Performance">
    <List>
      <ListItem title="Set appropriate TTLs">
        Configure expiration times to prevent unbounded memory growth.
      </ListItem>
      <ListItem title="Monitor memory usage">
        Track memory size and token consumption to optimize performance.
      </ListItem>
      <ListItem title="Implement pagination">
        Handle large conversation histories with pagination strategies.
      </ListItem>
      <ListItem title="Use caching">
        Cache frequently accessed memories to reduce storage backend load.
      </ListItem>
    </List>
  </Accordion>

  <Accordion title="Privacy">
    <List>
      <ListItem title="Encrypt sensitive content">
        Apply encryption to memory containing personal or sensitive data.
      </ListItem>
      <ListItem title="Implement retention policies">
        Define and enforce data retention rules for compliance.
      </ListItem>
      <ListItem title="Provide user controls">
        Enable users to view, export, and delete their memory data.
      </ListItem>
      <ListItem title="Audit access patterns">
        Log and monitor memory access for security and compliance.
      </ListItem>
    </List>
  </Accordion>
</AccordionGroup>

## Next Steps

<ReferenceCardList>
  <ReferenceCard
    title="Context Management"
    description="Learn about managing agent context effectively"
    href="/docs/core/agents/context"
    icon="Layers"
  />
</ReferenceCardList>
