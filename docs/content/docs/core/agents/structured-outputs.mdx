---
title: "Structured Outputs"
description: "Schema-driven structured outputs with provider-native enforcement"
---

## Overview

Structured outputs ensure agents return data in predictable, machine‑readable formats. This is essential for workflow automation, [API integrations](/docs/api/overview), and reliable data processing. Compozy uses your action <code>output</code> JSON Schemas to request provider‑native structured outputs when supported (e.g., OpenAI response_format) and always validates responses against the schema.

If you're new to structured outputs, start with our [Quick Start Guide](/docs/core/getting-started/quick-start) to understand basic workflow concepts, then explore [Agent Configuration](/docs/core/agents/overview) for foundational agent setup patterns.

<Callout type="info">
  For complex validation scenarios, leverage [reusable schemas](#reusable-schemas) and Compozy's [YAML template system](/docs/core/yaml-templates/overview) to build maintainable, modular configurations.
</Callout>

## Enabling Structured Outputs

Structured outputs are enabled by defining an <code>output</code> schema on an action. When present, Compozy:

- Requests native structured outputs for providers that support it (e.g., OpenAI compatible response_format JSON schema).
- Falls back to prompt guidance and post‑validation when native support isn’t available.

<Tabs items={["Per Action", "Schema Reference"]} defaultValue="Per Action">
  <Tab value="Per Action">
    ```yaml
    actions:
      - id: analyze-data
        prompt: "Analyze the data and return findings"
        output:
          type: object
          properties:
            findings:
              type: array
              items:
                type: string
    ```
  </Tab>

  <Tab value="Schema Reference">
    Reference a reusable schema by ID:

    ```yaml
    schemas:
      - id: findings
        type: object
        properties:
          items:
            type: array
            items: { type: string }

    agents:
      - id: researcher
        actions:
          - id: analyze
            prompt: "Analyze and summarize findings"
            output: findings
    ```
  </Tab>
</Tabs>

### Structured Output Behavior

When structured outputs are in effect, agent behavior ensures schema‑compatible responses:

- **Pure JSON Response**: Agent must respond with valid JSON only
- **No Markdown**: No markdown formatting or explanatory text outside JSON
- **Direct Parsing**: Response is directly parseable by downstream workflow tasks
- **Validation Errors**: Runtime errors occur if response isn't valid JSON

<Callout type="warning">
  **Trade‑off Consideration**: Enforcing strictly structured responses may limit free‑form explanations. For debugging complex logic, enable verbose logging or temporarily remove the schema.
</Callout>

## Output Schemas

Output schemas define the expected structure of agent responses using [JSON Schema (Draft 7)](https://json-schema.org/). Schemas provide validation, type safety, and clear contracts for agent interactions within workflow orchestration.

### Basic Schema Definition

Define schemas directly within action definitions for simple validation:

```yaml
actions:
  - id: classify-text
    prompt: "Classify the sentiment of the text"
    output:
      type: object
      properties:
        sentiment:
          type: string
          enum: ["positive", "negative", "neutral"]
          description: "Overall sentiment"
        confidence:
          type: number
          minimum: 0
          maximum: 1
          description: "Confidence score"
        keywords:
          type: array
          items:
            type: string
          description: "Key words indicating sentiment"
      required: ["sentiment", "confidence"]
```

This basic approach works well for simple schemas. For complex validation patterns, consider using [reusable schemas](#reusable-schemas) to promote consistency across your workflow definitions.

## Reusable Schemas

Define reusable schemas within your workflow to promote consistency and reduce duplication across multiple agents and actions. Reference schemas directly by ID (no `$ref`).

### Defining Schemas

Add schema definitions to your workflow configuration under the `schemas` property:

```yaml
# workflow.yaml
schemas:
  - id: user_profile
    type: object
    properties:
      email:
        type: string
        format: email
      name:
        type: string
        minLength: 2
      age:
        type: integer
        minimum: 0
        maximum: 150
    required: [email, name]

  - id: api_response
    type: object
    properties:
      status:
        type: string
        enum: [success, error, pending]
      data:
        type: object
      message:
        type: string
    required: [status]

  - id: classification_result
    type: object
    properties:
      category:
        type: string
      confidence:
        type: number
        minimum: 0
        maximum: 1
      metadata:
        type: object
    required: [category, confidence]
```

### Referencing Schemas

Reference defined schemas in your agent actions by ID:

<Tabs items={["Basic Reference", "Input Validation", "Complex Composition"]}>
  <Tab value="Basic Reference">
    Reference a schema by ID using local scope:

    ```yaml
    agents:
      - id: user-processor
        actions:
          - id: validate-user
            prompt: "Validate the user data structure"
            output: user_profile

          - id: classify-content
            prompt: "Classify the content type"
            output: classification_result
    ```
  </Tab>

  <Tab value="Input Validation">
    Use schemas for both input and output validation:

    ```yaml
    config:
      input: user_profile

    agents:
      - id: profile-analyzer
        actions:
          - id: analyze-profile
            prompt: "Analyze the user profile: {{.input | toJson}}"
            output: api_response
    ```

    This pattern ensures consistent validation throughout your workflow execution.
  </Tab>

  <Tab value="Complex Composition">
    Combine schemas using JSON Schema composition keywords:

    ```yaml
    schemas:
      - id: enhanced_response
        allOf:
          - api_response
          - type: object
            properties:
              timestamp:
                type: string
                format: date-time
              request_id:
                type: string
            required: [timestamp, request_id]

    agents:
      - id: api-handler
        actions:
          - id: process-request
            prompt: "Process the API request"
            output: enhanced_response
    ```

    Learn more about schema composition in the YAML Template Advanced Patterns documentation.
  </Tab>
</Tabs>

### Schema Benefits

Reusable schemas provide several advantages for workflow development:

- **Consistency**: Ensure uniform data structures across agents and actions
- **Maintainability**: Update schema definitions in one place for project-wide changes
- **Validation**: Leverage JSON Schema's powerful validation capabilities
- **Documentation**: Schema descriptions serve as inline documentation for data structures
- **Integration**: Seamless integration with [YAML template system](/docs/core/yaml-templates/overview) and [workflow configuration](/docs/core/configuration/workflows)

<Callout type="info">
  For schemas shared across multiple workflows, consider defining them in your [global configuration](/docs/core/configuration/global) and reference them by ID. See [ID References](/docs/core/yaml-templates/directives) for patterns.
</Callout>

## Practical Examples

Real-world examples demonstrating structured outputs in common scenarios. These patterns work well with parallel task execution and collection tasks for processing multiple data items efficiently.

<Tabs items={["Data Extraction", "Analysis Results", "API Integration"]} defaultValue="Data Extraction">
  <Tab value="Data Extraction">
    Extract structured data from unstructured text using precise schemas:

    ```yaml
    schemas:
      - id: invoice_data
        type: object
        properties:
          invoice_number:
            type: string
            description: "Unique invoice identifier"
          date:
            type: string
            format: date
            description: "Invoice issue date in YYYY-MM-DD format"
          due_date:
            type: string
            format: date
          vendor:
            type: object
            properties:
              name:
                type: string
              address:
                type: string
              tax_id:
                type: string
          line_items:
            type: array
            items:
              type: object
              properties:
                description:
                  type: string
                quantity:
                  type: number
                unit_price:
                  type: number
                total:
                  type: number
          subtotal:
            type: number
          tax:
            type: number
          total:
            type: number
        required: ["invoice_number", "date", "vendor", "line_items", "total"]

    agents:
      - id: invoice-processor
        actions:
          - id: extract-invoice
            prompt: |
              Extract invoice information from the text:
              {{.input.text}}

              Return all monetary values as numbers without currency symbols.
              Return dates in ISO 8601 format.
            # structured outputs are derived from the schema
            output: invoice_data
    ```

    This pattern works well for document processing workflows that need to extract and validate financial data.
  </Tab>

  <Tab value="Analysis Results">
    Analysis task with focused output schema for business intelligence:

    ```yaml
    schemas:
      - id: customer_analysis
        type: object
        properties:
          segment:
            type: string
            enum: ["high-value", "regular", "at-risk", "churned"]
            description: "Customer segment classification"
          lifetime_value:
            type: number
            minimum: 0
            description: "Estimated customer lifetime value in USD"
          key_insights:
            type: array
            items:
              type: string
            maxItems: 3
            description: "Top 3 behavioral insights"
          recommended_action:
            type: string
            description: "Recommended business action"
        required: ["segment", "lifetime_value", "key_insights"]

    agents:
      - id: customer-analyzer
        actions:
          - id: analyze-customer
            prompt: |
              Analyze customer behavior from transaction data:
              {{.input.transactions | toJson}}

              Focus on purchase patterns, frequency, and value trends.
            output:
              customer_analysis
    ```

    Ideal for multi-agent workflows where customer analysis feeds into recommendation engines or marketing automation.
  </Tab>

  <Tab value="API Integration">
    Structured outputs for seamless API integrations:

    ```yaml
    schemas:
      - id: api_request
        type: object
        properties:
          endpoint:
            type: string
            format: uri
          method:
            type: string
            enum: ["GET", "POST", "PUT", "DELETE"]
          headers:
            type: object
          body:
            type: object
        required: ["endpoint", "method"]

      - id: api_response
        type: object
        properties:
          status_code:
            type: integer
            minimum: 100
            maximum: 599
          response_body:
            type: object
          error_message:
            type: string
        required: ["status_code"]

    agents:
      - id: api-orchestrator
        actions:
          - id: prepare-request
            prompt: |
              Generate an API request for: {{.input.operation}}
              Target system: {{.input.target_system}}
            output: api_request

          - id: process-response
            prompt: |
              Process the API response and extract key information:
              {{.input.api_response | toJson}}
            output: api_response
    ```

    This pattern enables robust [tool integration](/docs/core/tools/overview) and seamless connectivity with external services.
  </Tab>
</Tabs>

## Schema Validation Process

Understanding the validation lifecycle helps with debugging and building robust AI-powered workflows. Compozy validates schemas at multiple stages to ensure data integrity throughout the execution pipeline.

<Steps>
  <Step title="Pre-execution" description="Input schema validates incoming parameters. The input schema is applied to validate all incoming workflow parameters before execution begins, ensuring data integrity from the start. Failed validation prevents workflow execution and returns detailed error messages." />
  <Step title="Agent Processing" description="Agent generates response following the schema. When supported, Compozy requests native structured outputs; otherwise it instructs the model and validates the response against the schema." />
  <Step title="Post-execution" description="Output schema validates agent response. The generated response is validated against the defined output schema to ensure compliance with expected structure. This prevents malformed data from propagating to downstream tasks." />
  <Step title="Error Handling" description="Validation errors are returned with details. Any validation failures produce detailed error messages with specific paths and expected values for debugging. Use these error messages to refine prompts or adjust schema definitions." />
</Steps>

<Callout type="info">
  **Debugging Validation Issues**: When validation fails, examine the error path to identify which schema property caused the issue. Common problems include missing required fields, incorrect data types, or values outside defined ranges.
</Callout>

### Validation Error Examples

Common validation scenarios and their error messages:

```yaml
# Schema definition
output:
  type: object
  properties:
    score:
      type: number
      minimum: 0
      maximum: 100
  required: [score]

# Valid response ✅
{"score": 85}

# Invalid responses ❌
{"score": "high"}       # Error: expected number, got string
{"rating": 85}          # Error: missing required property 'score'
{"score": 150}          # Error: value exceeds maximum of 100
```

For advanced validation patterns and custom error handling, explore YAML Template Advanced Patterns and Error Handling in Workflows.

## Advanced Topics

<ReferenceCardList>
  <ReferenceCard
    title="YAML Template System"
    description="Master template expressions, variables, and advanced composition patterns for dynamic schemas"
    href="/docs/core/yaml-templates/overview"
    icon="Code"
  />
  <ReferenceCard
    title="ID References"
    description="How to reference schemas, agents, tools, and MCPs by ID"
    href="/docs/core/yaml-templates/directives"
    icon="Link"
  />
  <ReferenceCard
    title="Workflow Configuration"
    description="Learn about schemas property and input validation patterns in workflow definitions"
    href="/docs/core/configuration/workflows#schema-definitions"
    icon="Settings"
  />
  <ReferenceCard
    title="Validation & Debugging"
    description="Troubleshooting techniques for schema validation errors and complex debugging scenarios"
    href="/docs/core/yaml-templates/overview"
    icon="Bug"
  />
</ReferenceCardList>

## Integration Patterns

<ReferenceCardList>
  <ReferenceCard
    title="Collection Tasks"
    description="Apply structured outputs to batch processing and data collection workflows"
    href="/docs/core/tasks/collection-tasks"
    icon="Database"
  />
  <ReferenceCard
    title="Tool Integration"
    description="Connect structured agent outputs to external tools and API integrations"
    href="/docs/core/tools/overview"
    icon="Wrench"
  />
</ReferenceCardList>

## Learning Path

<ReferenceCardList>
  <ReferenceCard
    title="Quick Start Guide"
    description="Begin with basic workflow concepts and simple structured output examples"
    href="/docs/core/getting-started/quick-start"
    icon="Rocket"
  />
  <ReferenceCard
    title="First Workflow Tutorial"
    description="Build a complete AI application with structured outputs and validation patterns"
    href="/docs/core/getting-started/first-workflow"
    icon="GraduationCap"
  />
  <ReferenceCard
    title="Agent Configuration"
    description="Master agent setup patterns and configuration best practices"
    href="/docs/core/agents/overview"
    icon="Cpu"
  />
  <ReferenceCard
    title="API Documentation"
    description="Execute workflows with structured outputs via CLI commands and REST APIs"
    href="/docs/api/workflows"
    icon="Terminal"
  />
</ReferenceCardList>
