---
title: "Structured Outputs"
description: "JSON mode and schema validation for predictable agent responses"
---

## Overview

Structured outputs ensure agents return data in predictable, machine-readable formats. This is essential for workflow automation, API integrations, and reliable data processing. Compozy provides JSON mode and schema validation to guarantee consistent output structures.

## JSON Mode

JSON mode forces agents to respond with valid JSON, enabling reliable parsing and processing of agent outputs.

### Enabling JSON Mode

JSON mode can be enabled at multiple levels:

<Tabs items={["Agent Level", "Action Level", "Automatic"]} defaultValue="Agent Level">
  <Tab value="Agent Level">
    ```yaml
    agents:
      - id: data-processor
        config:
          provider: openai
          model: gpt-4-turbo-preview
        json_mode: true  # All actions default to JSON
        instructions: |
          Always respond with valid JSON objects.
    ```
  </Tab>

  <Tab value="Action Level">
    ```yaml
    actions:
      - id: analyze-data
        prompt: "Analyze the data and return findings"
        json_mode: true  # Only this action uses JSON mode
        output:
          type: object
          properties:
            findings:
              type: array
    ```
  </Tab>

  <Tab value="Automatic">
    ```yaml
    actions:
      - id: get-metrics
        prompt: "Calculate metrics"
        # json_mode automatically enabled when output schema is defined
        output:
          type: object
          properties:
            metrics:
              type: object
    ```
  </Tab>
</Tabs>

### JSON Mode Behavior

When JSON mode is enabled:
- Agent must respond with valid JSON
- No markdown formatting or explanatory text
- Response is directly parseable
- Errors occur if response isn't valid JSON

<Callout>
JSON mode may limit the agent's ability to provide explanations or reasoning. Consider if you need pure data or contextual responses.
</Callout>

## Output Schemas

Output schemas define the expected structure of agent responses using JSON Schema (Draft 7).

### Basic Schema Definition

```yaml
actions:
  - id: classify-text
    prompt: "Classify the sentiment of the text"
    output:
      type: object
      properties:
        sentiment:
          type: string
          enum: ["positive", "negative", "neutral"]
          description: "Overall sentiment"
        confidence:
          type: number
          minimum: 0
          maximum: 1
          description: "Confidence score"
        keywords:
          type: array
          items:
            type: string
          description: "Key words indicating sentiment"
      required: ["sentiment", "confidence"]
```

### Schema Types and Validation

<AccordionGroup>
  <Accordion title="Object Schemas">
    ```yaml
    output:
      type: object
      properties:
        user:
          type: object
          properties:
            id:
              type: string
            name:
              type: string
              minLength: 1
            email:
              type: string
              format: email
            role:
              type: string
              enum: ["admin", "user", "moderator"]
          required: ["id", "name", "email"]
      required: ["user"]
    ```
  </Accordion>

  <Accordion title="Array Schemas">
    ```yaml
    output:
      type: object
      properties:
        results:
          type: array
          items:
            type: object
            properties:
              id:
                type: integer
              score:
                type: number
              category:
                type: string
          minItems: 1
        total:
          type: integer
    ```
  </Accordion>

  <Accordion title="Conditional Schemas">
    ```yaml
    output:
      type: object
      properties:
        status:
          type: string
          enum: ["success", "error", "partial"]
        data:
          type: object
        error:
          type: object
          properties:
            code:
              type: string
            message:
              type: string
      # Conditional validation
      oneOf:
        - properties:
            status:
              const: "success"
          required: ["status", "data"]
        - properties:
            status:
              const: "error"
          required: ["status", "error"]
    ```
  </Accordion>

  <Accordion title="Complex Types">
    ```yaml
    output:
      type: object
      properties:
        timestamp:
          type: string
          format: date-time
        metrics:
          type: object
          additionalProperties:
            type: number
        metadata:
          type: object
          properties:
            version:
              type: string
              pattern: "^\\d+\\.\\d+\\.\\d+$"
        tags:
          type: array
          items:
            type: string
          uniqueItems: true
    ```
  </Accordion>
</AccordionGroup>

## Practical Examples

### Data Extraction

Extract structured data from unstructured text:

```yaml
actions:
  - id: extract-invoice
    prompt: |
      Extract invoice information from the text:
      {{.input.text}}

      Return all monetary values as numbers without currency symbols.
      Return dates in ISO 8601 format.
    json_mode: true
    output:
      type: object
      properties:
        invoice_number:
          type: string
        date:
          type: string
          format: date
        due_date:
          type: string
          format: date
        vendor:
          type: object
          properties:
            name:
              type: string
            address:
              type: string
            tax_id:
              type: string
        line_items:
          type: array
          items:
            type: object
            properties:
              description:
                type: string
              quantity:
                type: number
              unit_price:
                type: number
              total:
                type: number
        subtotal:
          type: number
        tax:
          type: number
        total:
          type: number
      required: ["invoice_number", "date", "vendor", "line_items", "total"]
```

### Analysis with Structured Results

Analysis task with clear, focused output schema:

```yaml
actions:
  - id: analyze-customer
    prompt: |
      Analyze customer behavior from transaction data:
      {{.input.transactions | toJson}}
    output:
      type: object
      properties:
        segment:
          type: string
          enum: ["high-value", "regular", "at-risk", "churned"]
        lifetime_value:
          type: number
        key_insights:
          type: array
          items:
            type: string
          maxItems: 3
        recommended_action:
          type: string
      required: ["segment", "lifetime_value", "key_insights"]
```

### Error Handling

Structure error responses consistently:

```yaml
actions:
  - id: process-request
    prompt: |
      Process the request and handle any errors gracefully.
      If an error occurs, provide detailed information.
    output:
      type: object
      properties:
        success:
          type: boolean
        result:
          type: object
          description: "Present when success is true"
        error:
          type: object
          description: "Present when success is false"
          properties:
            code:
              type: string
              pattern: "^ERR_[A-Z_]+$"
            message:
              type: string
            details:
              type: object
            suggestions:
              type: array
              items:
                type: string
      # Ensure either result or error is present
      if:
        properties:
          success:
            const: true
      then:
        required: ["success", "result"]
      else:
        required: ["success", "error"]
```

## Validation and Error Handling

### Schema Validation Process

<Steps>
  <Step title="Pre-execution" description="Input schema validates incoming parameters. The input schema is applied to validate all incoming workflow parameters before execution begins, ensuring data integrity from the start." />
  <Step title="Agent Processing" description="Agent generates response following the schema. The agent processes the request with awareness of the output schema requirements, structuring its response accordingly." />
  <Step title="Post-execution" description="Output schema validates agent response. The generated response is validated against the defined output schema to ensure compliance with expected structure." />
  <Step title="Error Handling" description="Validation errors are returned with details. Any validation failures produce detailed error messages with specific paths and expected values for debugging." />
</Steps>

### Validation Error Example

When validation fails, you receive detailed error information:

```json
{
  "error": "output validation failed",
  "details": {
    "path": ".customer_profile.segment",
    "expected": ["high-value", "regular", "at-risk", "churned"],
    "actual": "premium",
    "message": "value must be one of the allowed values"
  }
}
```

### Handling Validation Gracefully

```yaml
tasks:
  - id: safe-processing
    type: basic
    $use: agent(local::agents.#(id="processor"))
    action: process
    on_error:
      - type: basic
        $use: agent(local::agents.#(id="error-handler"))
        action: handle-validation-error
        with:
          error: "{{.error}}"
          original_input: "{{.input}}"
```

## Advanced Patterns

### Dynamic Document Type Handling

Handle different document types dynamically by first classifying the document, then routing to type-specific extraction:

<Steps>
<Step title="Document Classification" description="Create an agent that can identify document types. The agent analyzes document content and structure to determine the type, returning both the classification and confidence level.">

```yaml
agents:
  - id: document-classifier
    instructions: |
      You classify documents by type based on their content and structure.
      Return the document type and confidence level.
    actions:
      - id: classify-document
        prompt: |
          Analyze this document and determine its type:
          {{.input.document}}

          Common types: invoice, purchase_order, contract, receipt, report
        output:
          type: object
          properties:
            type:
              type: string
              enum: ["invoice", "purchase_order", "contract", "receipt", "report", "unknown"]
            confidence:
              type: number
              minimum: 0
              maximum: 1
```

</Step>

<Step title="Dynamic Document Type Routing" description="Use router tasks to dynamically handle different document types. Based on the classification result, the workflow routes to the appropriate specialized extractor, ensuring optimal extraction for each document type.">

```yaml
tasks:
  - id: classify-document
    type: basic
    $use: agent(local::agents.#(id="document-classifier"))
    action: classify-document
    with:
      document: "{{.workflow.input.document}}"

  - id: extract-by-type
    type: router
    condition: "{{.tasks.classify-document.output.type}}"
    routes:
      invoice:
        type: basic
        $use: agent(local::agents.#(id="invoice-extractor"))
        action: extract-invoice
        with:
          document: "{{.workflow.input.document}}"
        output:
          type: object
          properties:
            invoice_number: { type: string }
            vendor: { type: object }
            total: { type: number }

      purchase_order:
        type: basic
        $use: agent(local::agents.#(id="po-extractor"))
        action: extract-purchase-order
        with:
          document: "{{.workflow.input.document}}"
        output:
          type: object
          properties:
            po_number: { type: string }
            buyer: { type: object }
            items: { type: array }

      default:
        type: basic
        $use: agent(local::agents.#(id="generic-extractor"))
        action: extract-generic
        with:
          document: "{{.workflow.input.document}}"
          document_type: "{{.tasks.classify-document.output.type}}"
```

</Step>
</Steps>

<List>
  <ListItem title="Dynamic routing" description="Route documents based on actual content classification rather than predetermined types. This enables flexible handling of various document formats without hardcoding paths." />
  <ListItem title="Type-specific schemas" description="Apply appropriate validation schemas for each document type. Each extractor uses a schema tailored to its document type's specific fields and structure." />
  <ListItem title="Fallback handling" description="Gracefully handle unknown document types with generic extraction. The default route ensures no document is left unprocessed, even if its type is unrecognized." />
  <ListItem title="Single workflow" description="One workflow handles multiple document types without modification. This reduces maintenance overhead and provides a unified interface for document processing." />
</List>

### Schema Composition

Reuse schema definitions:

```yaml
definitions:
  Address:
    type: object
    properties:
      street:
        type: string
      city:
        type: string
      state:
        type: string
      zip:
        type: string
      country:
        type: string
    required: ["street", "city", "country"]

  Contact:
    type: object
    properties:
      name:
        type: string
      email:
        type: string
        format: email
      phone:
        type: string
      address:
        $ref: "#/definitions/Address"

actions:
  - id: extract-contacts
    output:
      type: object
      properties:
        contacts:
          type: array
          items:
            $ref: "#/definitions/Contact"
```

### Polymorphic Outputs

Handle different output types:

```yaml
output:
  type: object
  properties:
    result_type:
      type: string
      enum: ["user", "organization", "group"]
    data:
      oneOf:
        - type: object
          properties:
            user_id:
              type: string
            username:
              type: string
          required: ["user_id", "username"]
        - type: object
          properties:
            org_id:
              type: string
            org_name:
              type: string
          required: ["org_id", "org_name"]
        - type: object
          properties:
            group_id:
              type: string
            members:
              type: array
          required: ["group_id", "members"]
```

## Best Practices

<AccordionGroup>
  <Accordion title="Schema Design">
    - Start simple and iterate
    - Use descriptive property names
    - Include descriptions for complex fields
    - Set reasonable constraints (min/max values)
    - Use enums for known value sets
  </Accordion>

  <Accordion title="Performance">
    - Avoid overly complex nested structures
    - Use references for repeated patterns
    - Consider schema size impact on tokens
    - Balance validation strictness with flexibility
  </Accordion>

  <Accordion title="Error Recovery">
    - Design schemas that allow partial success
    - Include error information in output schema
    - Provide fallback values where appropriate
    - Log validation failures for debugging
  </Accordion>

  <Accordion title="Maintainability">
    - Version your schemas
    - Document breaking changes
    - Use consistent naming conventions
    - Test schemas with edge cases
  </Accordion>
</AccordionGroup>

## Integration Patterns

### API Integration

```yaml
actions:
  - id: api-compatible
    prompt: "Generate API-compatible response"
    output:
      type: object
      properties:
        status:
          type: integer
          enum: [200, 201, 400, 404, 500]
        headers:
          type: object
          additionalProperties:
            type: string
        body:
          type: object
        _links:
          type: object
          properties:
            self:
              type: string
              format: uri
            next:
              type: string
              format: uri
```

### Database Integration

```yaml
actions:
  - id: db-record
    prompt: "Extract data for database insertion"
    output:
      type: object
      properties:
        table:
          type: string
        record:
          type: object
          additionalProperties: true
        relationships:
          type: array
          items:
            type: object
            properties:
              table:
                type: string
              foreign_key:
                type: string
              value:
                type: string
```

## Next Steps

<ReferenceCardList>
  <ReferenceCard
    title="Multi-Agent Patterns"
    description="Learn how structured outputs enable multi-agent workflows"
    href="/docs/core/agents/multi-agent-patterns"
    icon="Users"
  />
  <ReferenceCard
    title="Workflow Integration"
    description="See how structured outputs integrate with workflow tasks"
    href="/docs/core/workflows/overview"
    icon="GitBranch"
  />
</ReferenceCardList>
