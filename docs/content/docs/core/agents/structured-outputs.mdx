---
title: "Structured Outputs"
description: "JSON mode and schema validation for predictable agent responses"
---

## Overview

Structured outputs ensure agents return data in predictable, machine-readable formats. This is essential for [workflow automation](/docs/core/workflows/overview), [API integrations](/docs/api/overview), and reliable data processing. Compozy provides JSON mode and [JSON Schema validation](https://json-schema.org/) to guarantee consistent output structures.

If you're new to structured outputs, start with our [Quick Start Guide](/docs/core/getting-started/quick-start) to understand basic workflow concepts, then explore [Agent Configuration](/docs/core/agents/overview) for foundational agent setup patterns.

<Callout type="tip">
  For complex validation scenarios, leverage [reusable schemas](#reusable-schemas) and Compozy's [YAML template system](/docs/core/yaml-templates/overview) to build maintainable, modular configurations.
</Callout>

## JSON Mode

JSON mode forces agents to respond with valid JSON, enabling reliable parsing and processing of agent outputs. This is particularly valuable for [multi-agent workflows](/docs/core/agents/multi-agent-patterns) where agent outputs become inputs for subsequent [workflow tasks](/docs/core/tasks/basic-tasks).

### Enabling JSON Mode

JSON mode can be enabled at multiple levels, providing flexibility for different [agent configurations](/docs/core/agents/overview#agent-configuration) and [action patterns](/docs/core/agents/actions):

<Tabs items={["Agent Level", "Action Level", "Automatic"]} defaultValue="Agent Level">
  <Tab value="Agent Level">
    Enable JSON mode for all actions of an agent:
    
    ```yaml
    agents:
      - id: data-processor
        config:
          provider: openai
          model: gpt-4-turbo-preview
        json_mode: true  # All actions default to JSON
        instructions: |
          Always respond with valid JSON objects.
    ```
    
    This approach works well when building [specialized agents](/docs/core/agents/multi-agent-patterns#specialized-agents) focused on data processing tasks.
  </Tab>

  <Tab value="Action Level">
    Enable JSON mode for specific actions within an agent:
    
    ```yaml
    actions:
      - id: analyze-data
        prompt: "Analyze the data and return findings"
        json_mode: true  # Only this action uses JSON mode
        output:
          type: object
          properties:
            findings:
              type: array
    ```
    
    Use this pattern when mixing structured and conversational outputs within the same agent.
  </Tab>

  <Tab value="Automatic">
    JSON mode is automatically enabled when output schemas are defined:
    
    ```yaml
    actions:
      - id: get-metrics
        prompt: "Calculate metrics"
        # json_mode automatically enabled when output schema is defined
        output:
          type: object
          properties:
            metrics:
              type: object
    ```
    
    This automatic behavior ensures consistency between schema definitions and JSON output requirements.
  </Tab>
</Tabs>

### JSON Mode Behavior

When JSON mode is enabled, agent behavior changes to ensure structured output compatibility:

- **Pure JSON Response**: Agent must respond with valid JSON only
- **No Markdown**: No markdown formatting or explanatory text outside JSON
- **Direct Parsing**: Response is directly parseable by downstream [workflow tasks](/docs/core/tasks/basic-tasks)
- **Validation Errors**: Runtime errors occur if response isn't valid JSON

<Callout type="warning">
  **Trade-off Consideration**: JSON mode may limit the agent's ability to provide explanations or reasoning. For debugging complex logic, consider enabling [verbose logging](/docs/core/configuration/global#logging).
</Callout>

## Output Schemas

Output schemas define the expected structure of agent responses using [JSON Schema (Draft 7)](https://json-schema.org/). Schemas provide validation, type safety, and clear contracts for [agent interactions](/docs/core/agents/multi-agent-patterns) within [workflow orchestration](/docs/core/workflows/overview).

### Basic Schema Definition

Define schemas directly within action definitions for simple validation:

```yaml
actions:
  - id: classify-text
    prompt: "Classify the sentiment of the text"
    output:
      type: object
      properties:
        sentiment:
          type: string
          enum: ["positive", "negative", "neutral"]
          description: "Overall sentiment"
        confidence:
          type: number
          minimum: 0
          maximum: 1
          description: "Confidence score"
        keywords:
          type: array
          items:
            type: string
          description: "Key words indicating sentiment"
      required: ["sentiment", "confidence"]
```

This basic approach works well for simple schemas. For complex validation patterns, consider using [reusable schemas](#reusable-schemas) to promote consistency across your [workflow definitions](/docs/core/configuration/workflows).

## Reusable Schemas

Define reusable schemas within your workflow to promote consistency and reduce duplication across multiple agents and actions. This approach leverages Compozy's [`$ref` directive](/docs/core/yaml-templates/directives#ref-directive) to reference schema definitions.

### Defining Schemas

Add schema definitions to your workflow configuration under the `schemas` property:

```yaml
# workflow.yaml
schemas:
  - id: user_profile
    type: object
    properties:
      email:
        type: string
        format: email
      name:
        type: string
        minLength: 2
      age:
        type: integer
        minimum: 0
        maximum: 150
    required: [email, name]

  - id: api_response
    type: object
    properties:
      status:
        type: string
        enum: [success, error, pending]
      data:
        type: object
      message:
        type: string
    required: [status]

  - id: classification_result
    type: object
    properties:
      category:
        type: string
      confidence:
        type: number
        minimum: 0
        maximum: 1
      metadata:
        type: object
    required: [category, confidence]
```

### Referencing Schemas

Use the [`$ref` directive](/docs/core/yaml-templates/directives#ref-directive) to reference defined schemas in your agent actions:

<Tabs items={["Basic Reference", "Input Validation", "Complex Composition"]}>
  <Tab value="Basic Reference">
    Reference a schema by ID using local scope:
    
    ```yaml
    agents:
      - id: user-processor
        actions:
          - id: validate-user
            prompt: "Validate the user data structure"
            output:
              $ref: "local::schemas.#(id==\"user_profile\")"
          
          - id: classify-content
            prompt: "Classify the content type"
            output:
              $ref: "local::schemas.#(id==\"classification_result\")"
    ```
  </Tab>

  <Tab value="Input Validation">
    Use schemas for both input and output validation:
    
    ```yaml
    config:
      input:
        $ref: "local::schemas.#(id==\"user_profile\")"

    agents:
      - id: profile-analyzer
        actions:
          - id: analyze-profile
            prompt: "Analyze the user profile: {{.input | toJson}}"
            output:
              $ref: "local::schemas.#(id==\"api_response\")"
    ```
    
    This pattern ensures consistent validation throughout your [workflow execution](/docs/core/workflows/overview#execution-model).
  </Tab>

  <Tab value="Complex Composition">
    Combine schemas using JSON Schema composition keywords:
    
    ```yaml
    schemas:
      - id: enhanced_response
        allOf:
          - $ref: "local::schemas.#(id==\"api_response\")"
          - type: object
            properties:
              timestamp:
                type: string
                format: date-time
              request_id:
                type: string
            required: [timestamp, request_id]

    agents:
      - id: api-handler
        actions:
          - id: process-request
            prompt: "Process the API request"
            output:
              $ref: "local::schemas.#(id==\"enhanced_response\")"
    ```
    
    Learn more about schema composition in the [YAML Template Advanced Patterns](/docs/core/yaml-templates/advanced-patterns) documentation.
  </Tab>
</Tabs>

### Schema Benefits

Reusable schemas provide several advantages for [workflow development](/docs/core/getting-started/first-workflow):

- **Consistency**: Ensure uniform data structures across agents and actions
- **Maintainability**: Update schema definitions in one place for project-wide changes
- **Validation**: Leverage JSON Schema's powerful validation capabilities
- **Documentation**: Schema descriptions serve as inline documentation for data structures
- **Integration**: Seamless integration with [YAML template system](/docs/core/yaml-templates/overview) and [workflow configuration](/docs/core/configuration/workflows)

<Callout type="tip">
  For schemas shared across multiple workflows, consider defining them in your [global configuration](/docs/core/configuration/global) and using `global::` references, or organize them in external files with `resource::` references as described in the [Template Directives](/docs/core/yaml-templates/directives) documentation.
</Callout>

## Practical Examples

Real-world examples demonstrating structured outputs in common scenarios. These patterns work well with [parallel task execution](/docs/core/tasks/parallel-tasks) and [collection tasks](/docs/core/tasks/collection-tasks) for processing multiple data items efficiently.

<Tabs items={["Data Extraction", "Analysis Results", "API Integration"]} defaultValue="Data Extraction">
  <Tab value="Data Extraction">
    Extract structured data from unstructured text using precise schemas:

    ```yaml
    schemas:
      - id: invoice_data
        type: object
        properties:
          invoice_number:
            type: string
            description: "Unique invoice identifier"
          date:
            type: string
            format: date
            description: "Invoice issue date in YYYY-MM-DD format"
          due_date:
            type: string
            format: date
          vendor:
            type: object
            properties:
              name:
                type: string
              address:
                type: string
              tax_id:
                type: string
          line_items:
            type: array
            items:
              type: object
              properties:
                description:
                  type: string
                quantity:
                  type: number
                unit_price:
                  type: number
                total:
                  type: number
          subtotal:
            type: number
          tax:
            type: number
          total:
            type: number
        required: ["invoice_number", "date", "vendor", "line_items", "total"]

    agents:
      - id: invoice-processor
        actions:
          - id: extract-invoice
            prompt: |
              Extract invoice information from the text:
              {{.input.text}}

              Return all monetary values as numbers without currency symbols.
              Return dates in ISO 8601 format.
            json_mode: true
            output:
              $ref: "local::schemas.#(id==\"invoice_data\")"
    ```
    
    This pattern works well for [document processing workflows](/docs/core/workflows/overview) that need to extract and validate financial data.
  </Tab>

  <Tab value="Analysis Results">
    Analysis task with focused output schema for business intelligence:

    ```yaml
    schemas:
      - id: customer_analysis
        type: object
        properties:
          segment:
            type: string
            enum: ["high-value", "regular", "at-risk", "churned"]
            description: "Customer segment classification"
          lifetime_value:
            type: number
            minimum: 0
            description: "Estimated customer lifetime value in USD"
          key_insights:
            type: array
            items:
              type: string
            maxItems: 3
            description: "Top 3 behavioral insights"
          recommended_action:
            type: string
            description: "Recommended business action"
        required: ["segment", "lifetime_value", "key_insights"]

    agents:
      - id: customer-analyzer
        actions:
          - id: analyze-customer
            prompt: |
              Analyze customer behavior from transaction data:
              {{.input.transactions | toJson}}
              
              Focus on purchase patterns, frequency, and value trends.
            output:
              $ref: "local::schemas.#(id==\"customer_analysis\")"
    ```
    
    Ideal for [multi-agent workflows](/docs/core/agents/multi-agent-patterns) where customer analysis feeds into recommendation engines or marketing automation.
  </Tab>

  <Tab value="API Integration">
    Structured outputs for seamless API integrations:

    ```yaml
    schemas:
      - id: api_request
        type: object
        properties:
          endpoint:
            type: string
            format: uri
          method:
            type: string
            enum: ["GET", "POST", "PUT", "DELETE"]
          headers:
            type: object
          body:
            type: object
        required: ["endpoint", "method"]

      - id: api_response
        type: object
        properties:
          status_code:
            type: integer
            minimum: 100
            maximum: 599
          response_body:
            type: object
          error_message:
            type: string
        required: ["status_code"]

    agents:
      - id: api-orchestrator
        actions:
          - id: prepare-request
            prompt: |
              Generate an API request for: {{.input.operation}}
              Target system: {{.input.target_system}}
            output:
              $ref: "local::schemas.#(id==\"api_request\")"
              
          - id: process-response
            prompt: |
              Process the API response and extract key information:
              {{.input.api_response | toJson}}
            output:
              $ref: "local::schemas.#(id==\"api_response\")"
    ```
    
    This pattern enables robust [tool integration](/docs/core/tools/overview) and seamless connectivity with external services.
  </Tab>
</Tabs>

## Schema Validation Process

Understanding the validation lifecycle helps with debugging and building robust [AI-powered workflows](/docs/core/workflows/overview). Compozy validates schemas at multiple stages to ensure data integrity throughout the execution pipeline.

<Steps>
  <Step title="Pre-execution" description="Input schema validates incoming parameters. The input schema is applied to validate all incoming workflow parameters before execution begins, ensuring data integrity from the start. Failed validation prevents workflow execution and returns detailed error messages." />
  <Step title="Agent Processing" description="Agent generates response following the schema. The agent processes the request with awareness of the output schema requirements, structuring its response accordingly. JSON mode is automatically enabled when output schemas are defined." />
  <Step title="Post-execution" description="Output schema validates agent response. The generated response is validated against the defined output schema to ensure compliance with expected structure. This prevents malformed data from propagating to downstream tasks." />
  <Step title="Error Handling" description="Validation errors are returned with details. Any validation failures produce detailed error messages with specific paths and expected values for debugging. Use these error messages to refine prompts or adjust schema definitions." />
</Steps>

<Callout type="info">
  **Debugging Validation Issues**: When validation fails, examine the error path to identify which schema property caused the issue. Common problems include missing required fields, incorrect data types, or values outside defined ranges. See [Validation & Debugging](/docs/core/yaml-templates/validation-debugging) for troubleshooting techniques.
</Callout>

### Validation Error Examples

Common validation scenarios and their error messages:

```yaml
# Schema definition
output:
  type: object
  properties:
    score:
      type: number
      minimum: 0
      maximum: 100
  required: [score]

# Valid response ✅
{"score": 85}

# Invalid responses ❌
{"score": "high"}       # Error: expected number, got string
{"rating": 85}          # Error: missing required property 'score'
{"score": 150}          # Error: value exceeds maximum of 100
```

For advanced validation patterns and custom error handling, explore [YAML Template Advanced Patterns](/docs/core/yaml-templates/advanced-patterns) and [Error Handling in Workflows](/docs/core/workflows/overview#error-handling).

## Advanced Topics

<ReferenceCardList>
  <ReferenceCard
    title="YAML Template System"
    description="Master template expressions, variables, and advanced composition patterns for dynamic schemas"
    href="/docs/core/yaml-templates/overview"
    icon="Code"
  />
  <ReferenceCard
    title="Template Directives"
    description="Deep dive into $ref and $use directives for reusable schema patterns and resource composition"
    href="/docs/core/yaml-templates/directives"
    icon="Link"
  />
  <ReferenceCard
    title="Workflow Configuration"
    description="Learn about schemas property and input validation patterns in workflow definitions"
    href="/docs/core/configuration/workflows#schema-definitions"
    icon="Settings"
  />
  <ReferenceCard
    title="Validation & Debugging"
    description="Troubleshooting techniques for schema validation errors and complex debugging scenarios"
    href="/docs/core/yaml-templates/validation-debugging"
    icon="Bug"
  />
</ReferenceCardList>

## Integration Patterns

<ReferenceCardList>
  <ReferenceCard
    title="Multi-Agent Patterns"
    description="Design structured data flows between agents in complex orchestration scenarios"
    href="/docs/core/agents/multi-agent-patterns"
    icon="Users"
  />
  <ReferenceCard
    title="Parallel Tasks"
    description="Process structured data efficiently using parallel task execution patterns"
    href="/docs/core/tasks/parallel-tasks"
    icon="Zap"
  />
  <ReferenceCard
    title="Collection Tasks"
    description="Apply structured outputs to batch processing and data collection workflows"
    href="/docs/core/tasks/collection-tasks"
    icon="Database"
  />
  <ReferenceCard
    title="Tool Integration"
    description="Connect structured agent outputs to external tools and API integrations"
    href="/docs/core/tools/overview"
    icon="Wrench"
  />
</ReferenceCardList>

## Learning Path

<ReferenceCardList>
  <ReferenceCard
    title="Quick Start Guide"
    description="Begin with basic workflow concepts and simple structured output examples"
    href="/docs/core/getting-started/quick-start"
    icon="Rocket"
  />
  <ReferenceCard
    title="First Workflow Tutorial"
    description="Build a complete AI application with structured outputs and validation patterns"
    href="/docs/core/getting-started/first-workflow"
    icon="GraduationCap"
  />
  <ReferenceCard
    title="Agent Configuration"
    description="Master agent setup patterns and configuration best practices"
    href="/docs/core/agents/overview"
    icon="Cpu"
  />
  <ReferenceCard
    title="API Documentation"
    description="Execute workflows with structured outputs via CLI commands and REST APIs"
    href="/docs/api/workflows"
    icon="Terminal"
  />
</ReferenceCardList>
