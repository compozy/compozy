---
title: "Multi-Agent Patterns"
description: "Patterns and strategies for building collaborative multi-agent workflows"
---

## Overview

Multi-agent patterns enable complex workflows where multiple specialized agents collaborate to solve problems, process data, or complete tasks. These patterns leverage agent specialization, parallel processing, and intelligent coordination.

<Mermaid chart={`graph LR
    subgraph "Multi-Agent Patterns"
        A[Sequential Processing] --> B[Agents work in order]
        C[Parallel Processing] --> D[Agents work simultaneously]
        E[Hierarchical Delegation] --> F[Master delegates to specialists]
        G[Consensus Building] --> H[Multiple perspectives combined]
        I[Feedback Loop] --> J[Iterative refinement]
    end
    
    B --> K[Output feeds next agent]
    D --> L[Results aggregated]
    F --> M[Task breakdown & routing]
    H --> N[Synthesized decision]
    J --> O[Continuous improvement]`} />

## Core Multi-Agent Patterns

### Sequential Processing

Agents work in sequence, each building on the previous agent's output:

```yaml
agents:
  - id: researcher
    instructions: |
      You are a research specialist who gathers and analyzes information.
      Focus on finding relevant data and identifying key insights.

  - id: writer
    instructions: |
      You are a technical writer who creates clear, engaging content.
      Transform research into well-structured documents.

  - id: editor
    instructions: |
      You are an editor who ensures quality and consistency.
      Review and refine content for clarity and accuracy.

tasks:
  - id: research
    type: basic
    $use: agent(local::agents.#(id="researcher"))
    action: gather-info
    outputs:
      findings: "{{.output}}"

  - id: write
    type: basic
    $use: agent(local::agents.#(id="writer"))
    action: create-content
    with:
      research: "{{.tasks.research.output}}"

  - id: edit
    type: basic
    $use: agent(local::agents.#(id="editor"))
    action: review-content
    with:
      content: "{{.tasks.write.output}}"
```

### Parallel Processing

Multiple agents work simultaneously on different aspects:

```yaml
tasks:
  - id: parallel-analysis
    type: parallel
    tasks:
      - id: sentiment-analysis
        type: basic
        $use: agent(local::agents.#(id="sentiment-analyzer"))
        action: analyze
        with:
          text: "{{.workflow.input.text}}"

      - id: entity-extraction
        type: basic
        $use: agent(local::agents.#(id="entity-extractor"))
        action: extract
        with:
          text: "{{.workflow.input.text}}"

      - id: summary-generation
        type: basic
        $use: agent(local::agents.#(id="summarizer"))
        action: summarize
        with:
          text: "{{.workflow.input.text}}"

  - id: combine-results
    type: basic
    $use: agent(local::agents.#(id="aggregator"))
    action: combine
    with:
      sentiment: "{{.tasks.parallel-analysis.children.sentiment-analysis.output}}"
      entities: "{{.tasks.parallel-analysis.children.entity-extraction.output}}"
      summary: "{{.tasks.parallel-analysis.children.summary-generation.output}}"
```

### Hierarchical Delegation

Master agent delegates subtasks to specialized agents:

```yaml
agents:
  - id: project-manager
    instructions: |
      You are a project manager who breaks down complex tasks and delegates to specialists.
      Analyze requirements and create a task breakdown.
    actions:
      - id: plan
        prompt: |
          Create a task breakdown for: {{.input.project}}
          Output a list of subtasks with assigned specialists.
        output:
          type: object
          properties:
            tasks:
              type: array
              items:
                type: object
                properties:
                  id:
                    type: string
                  description:
                    type: string
                  specialist:
                    type: string
                    enum: ["developer", "designer", "analyst"]

tasks:
  - id: planning
    type: basic
    $use: agent(local::agents.#(id="project-manager"))
    action: plan
    with:
      project: "{{.workflow.input.project_description}}"

  - id: execution
    type: collection
    items: "{{.tasks.planning.output.tasks}}"
    task:
      type: router
      condition: "{{.item.specialist}}"
      routes:
        developer:
          type: basic
          $use: agent(local::agents.#(id="developer"))
          action: implement
          with:
            task: "{{.item}}"
        designer:
          type: basic
          $use: agent(local::agents.#(id="designer"))
          action: design
          with:
            task: "{{.item}}"
        analyst:
          type: basic
          $use: agent(local::agents.#(id="analyst"))
          action: analyze
          with:
            task: "{{.item}}"
```

### Consensus Building

Multiple agents provide input for collective decision-making:

```yaml
agents:
  - id: optimist
    instructions: |
      You analyze proposals from a positive perspective.
      Focus on opportunities and potential benefits.

  - id: pessimist
    instructions: |
      You analyze proposals from a critical perspective.
      Identify risks, challenges, and potential issues.

  - id: realist
    instructions: |
      You provide balanced, practical analysis.
      Consider feasibility and real-world constraints.

  - id: synthesizer
    instructions: |
      You synthesize multiple perspectives into actionable recommendations.
      Find common ground and create balanced solutions.

tasks:
  - id: gather-perspectives
    type: parallel
    tasks:
      - id: optimist-view
        type: basic
        $use: agent(local::agents.#(id="optimist"))
        action: analyze
        with:
          proposal: "{{.workflow.input.proposal}}"

      - id: pessimist-view
        type: basic
        $use: agent(local::agents.#(id="pessimist"))
        action: analyze
        with:
          proposal: "{{.workflow.input.proposal}}"

      - id: realist-view
        type: basic
        $use: agent(local::agents.#(id="realist"))
        action: analyze
        with:
          proposal: "{{.workflow.input.proposal}}"

  - id: synthesize
    type: basic
    $use: agent(local::agents.#(id="synthesizer"))
    action: create-recommendation
    with:
      perspectives:
        optimist: "{{.tasks.gather-perspectives.children.optimist-view.output}}"
        pessimist: "{{.tasks.gather-perspectives.children.pessimist-view.output}}"
        realist: "{{.tasks.gather-perspectives.children.realist-view.output}}"
```

### Feedback Loop

Agents iterate based on validation feedback:

```yaml
agents:
  - id: generator
    instructions: "You generate solutions based on requirements."

  - id: validator
    instructions: "You validate solutions against criteria and provide feedback."

tasks:
  - id: generate-solution
    type: basic
    $use: agent(local::agents.#(id="generator"))
    action: generate
    outputs:
      solution: "{{.output}}"
      iteration: 1

  - id: validation-loop
    type: composite
    strategy: best_effort
    tasks:
      - id: validate
        type: basic
        $use: agent(local::agents.#(id="validator"))
        action: validate
        with:
          solution: "{{.tasks.generate-solution.output.solution}}"
          criteria: "{{.workflow.input.criteria}}"
        outputs:
          valid: "{{.output.is_valid}}"
          feedback: "{{.output.feedback}}"

      - id: refine
        type: router
        condition: '{{.tasks.validate.output.valid | ternary "complete" "iterate"}}'
        routes:
          iterate:
            type: basic
            $use: agent(local::agents.#(id="generator"))
            action: refine
            with:
              previous: "{{.tasks.generate-solution.output.solution}}"
              feedback: "{{.tasks.validate.output.feedback}}"
          complete:
            type: aggregate
            outputs:
              final_solution: "{{.tasks.generate-solution.output.solution}}"
              validated: true
```

## Communication Patterns

<Tabs items={["Shared Memory", "Message Passing", "Event-Driven"]}>

<Tab>
### Shared Memory

Agents communicate through shared memory for persistent state:

```yaml
memory:
  - resource: memory
    id: project_context
    config:
      provider: redis
      ttl: 3600

agents:
  - id: analyst
    memory:
      - id: project_context
        key: "project:{{.workflow.input.project_id}}"
        mode: "read-write"
    actions:
      - id: analyze
        prompt: |
          Analyze the data and store findings in memory.
          Previous findings are available from memory.

  - id: reporter
    memory:
      - id: project_context
        key: "project:{{.workflow.input.project_id}}"
        mode: "read-only"
    actions:
      - id: report
        prompt: |
          Generate report based on analysis findings in memory.
```
</Tab>

<Tab>
### Message Passing

Direct message passing between agents:

```yaml
tasks:
  - id: agent-a
    type: basic
    outputs:
      message:
        to: "agent-b"
        subject: "Data processed"
        data: "{{.output}}"
        timestamp: "{{now}}"

  - id: agent-b
    type: basic
    with:
      received_message: "{{.tasks.agent-a.output.message}}"
    action: process-message
```
</Tab>

<Tab>
### Event-Driven Coordination

Agents respond to events:

```yaml
tasks:
  - id: monitor
    type: basic
    $use: agent(local::agents.#(id="monitor"))
    action: watch
    outputs:
      event_type: "{{.output.event_type}}"
      severity: "{{.output.severity}}"

  - id: response-router
    type: router
    condition: "{{.tasks.monitor.output.severity}}"
    routes:
      critical:
        type: parallel
        tasks:
          - type: basic
            $use: agent(local::agents.#(id="incident-handler"))
            action: respond
          - type: basic
            $use: agent(local::agents.#(id="notifier"))
            action: alert
      warning:
        type: basic
        $use: agent(local::agents.#(id="logger"))
        action: log
```
</Tab>
</Tabs>

## Specialization Strategies

### Role-Based Specialization

```yaml
agents:
  - id: legal-expert
    config:
      provider: anthropic
      model: claude-3-opus-20240229
    instructions: |
      You are a legal expert specializing in contract law.
      Analyze documents for legal compliance and risks.

  - id: financial-analyst
    config:
      provider: openai
      model: gpt-4-turbo-preview
    instructions: |
      You are a financial analyst specializing in risk assessment.
      Evaluate financial implications and ROI.

  - id: technical-architect
    config:
      provider: anthropic
      model: claude-3-opus-20240229
    instructions: |
      You are a solution architect specializing in system design.
      Assess technical feasibility and architecture.
```

### Domain-Specific Agents

```yaml
agents:
  - id: medical-coder
    instructions: |
      You are a medical coding specialist familiar with ICD-10, CPT, and HCPCS.
      Extract and assign appropriate medical codes from clinical notes.
    tools:
      - resource: tool
        id: medical-code-lookup

  - id: insurance-processor
    instructions: |
      You process insurance claims based on medical codes and policy rules.
      Determine coverage and calculate reimbursements.
    tools:
      - resource: tool
        id: policy-database
```

### Capability-Based Agents

```yaml
agents:
  - id: vision-analyzer
    config:
      provider: openai
      model: gpt-4-vision-preview
    instructions: "You analyze images and extract visual information."

  - id: code-generator
    config:
      provider: anthropic
      model: claude-3-opus-20240229
    instructions: "You generate high-quality code implementations."
    tools:
      - resource: tool
        id: code-executor

  - id: data-processor
    instructions: "You process and transform large datasets."
    tools:
      - resource: tool
        id: sql-engine
      - resource: tool
        id: data-transformer
```

## Coordination Mechanisms

### Orchestrator Pattern

```yaml
agents:
  - id: orchestrator
    instructions: |
      You coordinate multiple specialist agents to complete complex tasks.
      Break down requests, delegate to appropriate agents, and synthesize results.
    actions:
      - id: orchestrate
        prompt: |
          Task: {{.input.task}}
          Available agents: researcher, analyst, writer

          Create an execution plan and coordinate the agents.
        output:
          type: object
          properties:
            plan:
              type: array
              items:
                type: object
                properties:
                  step:
                    type: integer
                  agent:
                    type: string
                  action:
                    type: string
                  dependencies:
                    type: array
                    items:
                      type: integer
```

### Voting System

```yaml
tasks:
  - id: collect-votes
    type: parallel
    tasks:
      - id: agent-1-vote
        type: basic
        $use: agent(local::agents.#(id="reviewer-1"))
        action: review
        outputs:
          vote: "{{.output.decision}}"
          confidence: "{{.output.confidence}}"
      # ... more voting agents

  - id: tally-votes
    type: basic
    $use: agent(local::agents.#(id="vote-counter"))
    action: tally
    with:
      votes: "{{.tasks.collect-votes.children}}"
    outputs:
      decision: "{{.output.majority_decision}}"
      consensus_level: "{{.output.consensus_percentage}}"
```

### Iterative Refinement

Agents can work in loops to iteratively improve results through multiple rounds of feedback and refinement.

<Steps numbered size="sm">
<Step title="Initial Creation" description="First agent creates initial content based on requirements">

```yaml
agents:
  - id: writer
    instructions: "You create content based on requirements and feedback."

tasks:
  - id: initial-draft
    type: basic
    $use: agent(local::agents.#(id="writer"))
    action: create-content
    with:
      requirements: "{{.workflow.input.requirements}}"
```

</Step>

<Step title="Review and Feedback" description="Second agent reviews and provides structured feedback">

```yaml
agents:
  - id: reviewer
    instructions: "You review content for quality and provide specific feedback."

tasks:
  - id: review-cycle
    type: basic
    $use: agent(local::agents.#(id="reviewer"))
    action: review-content
    with:
      content: "{{.tasks.initial-draft.output}}"
      criteria: "{{.workflow.input.quality_criteria}}"
```

</Step>

<Step title="Refinement" description="Original agent refines based on feedback">

```yaml
tasks:
  - id: final-revision
    type: basic
    $use: agent(local::agents.#(id="writer"))
    action: revise-content
    with:
      original: "{{.tasks.initial-draft.output}}"
      feedback: "{{.tasks.review-cycle.output}}"
```

</Step>
</Steps>

**Implementation Details:**

To implement proper iterative refinement, you'll need:

```yaml
# Practical iterative refinement pattern
tasks:
  - id: create-initial-content
    type: basic
    $use: agent(local::agents.#(id="writer"))
    action: create-content
    with:
      requirements: "{{.workflow.input.requirements}}"

  - id: review-content
    type: basic
    $use: agent(local::agents.#(id="reviewer"))
    action: review-content
    with:
      content: "{{.tasks.create-initial-content.output}}"
      criteria: "{{.workflow.input.quality_criteria}}"

  - id: refine-content
    type: basic
    $use: agent(local::agents.#(id="writer"))
    action: revise-content
    with:
      original: "{{.tasks.create-initial-content.output}}"
      feedback: "{{.tasks.review-content.output.feedback}}"

  # Optional: Additional refinement cycle
  - id: final-review
    type: basic
    $use: agent(local::agents.#(id="reviewer"))
    action: final-review
    with:
      content: "{{.tasks.refine-content.output}}"

outputs:
  final_content: "{{.tasks.refine-content.output}}"
  review_feedback: "{{.tasks.final-review.output}}"
  quality_approved: "{{.tasks.final-review.output.approved}}"
```

**Key Implementation Considerations:**

<List>
  <ListItem title="Clear Agent Roles">
    Separate creation, review, and revision responsibilities to maintain focus
  </ListItem>
  <ListItem title="Structured Feedback">
    Ensure reviewers provide actionable feedback with specific improvement suggestions
  </ListItem>
  <ListItem title="Quality Criteria">
    Define clear evaluation standards upfront to guide the review process
  </ListItem>
  <ListItem title="Flexible Cycles">
    Add additional review/refinement cycles as needed for complex content
  </ListItem>
  <ListItem title="Error Handling">
    Gracefully handle cases where refinement fails or reaches maximum iterations
  </ListItem>
</List>

## Best Practices

### Agent Design

<List>
  <ListItem title="Single Responsibility">
    Each agent should have one clear purpose to ensure focused and predictable behavior
  </ListItem>
  <ListItem title="Clear Instructions">
    Provide specific, unambiguous instructions that guide the agent's decision-making
  </ListItem>
  <ListItem title="Appropriate Models">
    Match model capabilities to agent tasks - use powerful models for complex reasoning, efficient models for simple tasks
  </ListItem>
  <ListItem title="Tool Selection">
    Only provide relevant tools to each agent to avoid confusion and reduce token usage
  </ListItem>
</List>

### Communication

<List>
  <ListItem title="Structured Data">
    Use schemas for inter-agent communication to ensure data consistency and type safety
  </ListItem>
  <ListItem title="Context Preservation">
    Pass relevant context between agents to maintain workflow continuity
  </ListItem>
  <ListItem title="Error Propagation">
    Handle and communicate errors clearly so downstream agents can respond appropriately
  </ListItem>
  <ListItem title="Feedback Loops">
    Build in validation and refinement cycles for iterative improvement
  </ListItem>
</List>

### Performance

<List>
  <ListItem title="Parallelize When Possible">
    Use parallel tasks for independent operations to reduce total execution time
  </ListItem>
  <ListItem title="Minimize Handoffs">
    Reduce unnecessary agent transitions to lower latency and token consumption
  </ListItem>
  <ListItem title="Cache Results">
    Store and reuse expensive computations across agent interactions
  </ListItem>
  <ListItem title="Token Optimization">
    Share context efficiently between agents to manage costs and stay within limits
  </ListItem>
</List>

### Reliability

<List>
  <ListItem title="Graceful Degradation">
    Handle individual agent failures without crashing the entire workflow
  </ListItem>
  <ListItem title="Timeout Management">
    Set appropriate timeouts for each agent to prevent hanging workflows
  </ListItem>
  <ListItem title="Retry Logic">
    Implement smart retry for transient failures with exponential backoff
  </ListItem>
  <ListItem title="Result Validation">
    Verify outputs between agent handoffs to catch errors early
  </ListItem>
</List>

## Implementation Guidelines

### Pattern Selection

Choose the appropriate multi-agent pattern based on your specific use case:

<FeatureCardList cols={2}>
  <FeatureCard 
    title="Sequential Processing"
    description="Use when tasks must be completed in order and each step depends on the previous one"
    icon="GitCommit"
  />
  <FeatureCard 
    title="Parallel Processing"
    description="Use when tasks can be performed independently and you want to reduce total execution time"
    icon="GitBranch"
  />
  <FeatureCard 
    title="Hierarchical Delegation"
    description="Use when you need a coordinator to break down complex tasks and assign them to specialists"
    icon="Network"
  />
  <FeatureCard 
    title="Consensus Building"
    description="Use when you need multiple perspectives to make better decisions or validate results"
    icon="Users"
  />
</FeatureCardList>

### Performance Considerations

When implementing multi-agent patterns, consider these performance factors:

<List>
  <ListItem title="Token Usage">
    Multiple agents consume more tokens - optimize by sharing context efficiently and avoiding redundant information
  </ListItem>
  <ListItem title="Latency">
    Sequential patterns have higher latency than parallel ones - parallelize independent tasks when possible
  </ListItem>
  <ListItem title="Error Handling">
    Plan for individual agent failures and implement graceful degradation to maintain workflow resilience
  </ListItem>
  <ListItem title="Resource Limits">
    Monitor concurrent agent execution to avoid rate limiting and manage API quotas effectively
  </ListItem>
</List>

### Monitoring and Debugging

Multi-agent workflows can be complex to debug. Use these strategies:

<List>
  <ListItem title="Clear Naming">
    Use descriptive IDs for all agents and tasks to make debugging easier
  </ListItem>
  <ListItem title="Structured Logging">
    Log inputs and outputs at each agent handoff to trace data flow
  </ListItem>
  <ListItem title="Progress Tracking">
    Monitor task completion status across all agents for visibility
  </ListItem>
  <ListItem title="Error Propagation">
    Ensure errors are properly captured and reported through the workflow
  </ListItem>
</List>

## Next Steps

<ReferenceCardList>
  <ReferenceCard
    title="Workflow Patterns"
    description="Explore how multi-agent patterns fit into larger workflows"
    href="/docs/core/workflows/patterns"
    icon="GitBranch"
  />
  <ReferenceCard
    title="Performance Optimization"
    description="Learn to optimize multi-agent system performance"
    href="/docs/core/performance/agent-optimization"
    icon="Zap"
  />
</ReferenceCardList>
