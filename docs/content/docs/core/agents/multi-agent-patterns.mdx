---
title: "Multi-Agent Patterns"
description: "Patterns and strategies for building collaborative multi-agent workflows"
icon: "users"
---

## Overview

Multi-agent patterns enable complex workflows where multiple specialized agents collaborate to solve problems, process data, or complete tasks. These patterns leverage agent specialization, parallel processing, and intelligent coordination.

## Core Multi-Agent Patterns

### Sequential Processing

Agents work in sequence, each building on the previous agent's output:

```yaml
agents:
  - id: researcher
    instructions: |
      You are a research specialist who gathers and analyzes information.
      Focus on finding relevant data and identifying key insights.
    
  - id: writer
    instructions: |
      You are a technical writer who creates clear, engaging content.
      Transform research into well-structured documents.
    
  - id: editor
    instructions: |
      You are an editor who ensures quality and consistency.
      Review and refine content for clarity and accuracy.

tasks:
  - id: research
    type: basic
    $use: agent(local::agents.#(id="researcher"))
    action: gather-info
    outputs:
      findings: "{{.output}}"
  
  - id: write
    type: basic
    $use: agent(local::agents.#(id="writer"))
    action: create-content
    with:
      research: "{{.tasks.research.output}}"
  
  - id: edit
    type: basic
    $use: agent(local::agents.#(id="editor"))
    action: review-content
    with:
      content: "{{.tasks.write.output}}"
```

### Parallel Processing

Multiple agents work simultaneously on different aspects:

```yaml
tasks:
  - id: parallel-analysis
    type: parallel
    tasks:
      - id: sentiment-analysis
        type: basic
        $use: agent(local::agents.#(id="sentiment-analyzer"))
        action: analyze
        with:
          text: "{{.workflow.input.text}}"
      
      - id: entity-extraction
        type: basic
        $use: agent(local::agents.#(id="entity-extractor"))
        action: extract
        with:
          text: "{{.workflow.input.text}}"
      
      - id: summary-generation
        type: basic
        $use: agent(local::agents.#(id="summarizer"))
        action: summarize
        with:
          text: "{{.workflow.input.text}}"
  
  - id: combine-results
    type: basic
    $use: agent(local::agents.#(id="aggregator"))
    action: combine
    with:
      sentiment: "{{.tasks.parallel-analysis.children.sentiment-analysis.output}}"
      entities: "{{.tasks.parallel-analysis.children.entity-extraction.output}}"
      summary: "{{.tasks.parallel-analysis.children.summary-generation.output}}"
```

### Hierarchical Delegation

Master agent delegates subtasks to specialized agents:

```yaml
agents:
  - id: project-manager
    instructions: |
      You are a project manager who breaks down complex tasks and delegates to specialists.
      Analyze requirements and create a task breakdown.
    actions:
      - id: plan
        prompt: |
          Create a task breakdown for: {{.input.project}}
          Output a list of subtasks with assigned specialists.
        output:
          type: object
          properties:
            tasks:
              type: array
              items:
                type: object
                properties:
                  id:
                    type: string
                  description:
                    type: string
                  specialist:
                    type: string
                    enum: ["developer", "designer", "analyst"]

tasks:
  - id: planning
    type: basic
    $use: agent(local::agents.#(id="project-manager"))
    action: plan
    with:
      project: "{{.workflow.input.project_description}}"
  
  - id: execution
    type: collection
    items: "{{.tasks.planning.output.tasks}}"
    task:
      type: router
      condition: "{{.item.specialist}}"
      routes:
        developer:
          type: basic
          $use: agent(local::agents.#(id="developer"))
          action: implement
          with:
            task: "{{.item}}"
        designer:
          type: basic
          $use: agent(local::agents.#(id="designer"))
          action: design
          with:
            task: "{{.item}}"
        analyst:
          type: basic
          $use: agent(local::agents.#(id="analyst"))
          action: analyze
          with:
            task: "{{.item}}"
```

### Consensus Building

Multiple agents provide input for collective decision-making:

```yaml
agents:
  - id: optimist
    instructions: |
      You analyze proposals from a positive perspective.
      Focus on opportunities and potential benefits.
    
  - id: pessimist
    instructions: |
      You analyze proposals from a critical perspective.
      Identify risks, challenges, and potential issues.
    
  - id: realist
    instructions: |
      You provide balanced, practical analysis.
      Consider feasibility and real-world constraints.
    
  - id: synthesizer
    instructions: |
      You synthesize multiple perspectives into actionable recommendations.
      Find common ground and create balanced solutions.

tasks:
  - id: gather-perspectives
    type: parallel
    tasks:
      - id: optimist-view
        type: basic
        $use: agent(local::agents.#(id="optimist"))
        action: analyze
        with:
          proposal: "{{.workflow.input.proposal}}"
      
      - id: pessimist-view
        type: basic
        $use: agent(local::agents.#(id="pessimist"))
        action: analyze
        with:
          proposal: "{{.workflow.input.proposal}}"
      
      - id: realist-view
        type: basic
        $use: agent(local::agents.#(id="realist"))
        action: analyze
        with:
          proposal: "{{.workflow.input.proposal}}"
  
  - id: synthesize
    type: basic
    $use: agent(local::agents.#(id="synthesizer"))
    action: create-recommendation
    with:
      perspectives:
        optimist: "{{.tasks.gather-perspectives.children.optimist-view.output}}"
        pessimist: "{{.tasks.gather-perspectives.children.pessimist-view.output}}"
        realist: "{{.tasks.gather-perspectives.children.realist-view.output}}"
```

### Feedback Loop

Agents iterate based on validation feedback:

```yaml
agents:
  - id: generator
    instructions: "You generate solutions based on requirements."
    
  - id: validator
    instructions: "You validate solutions against criteria and provide feedback."

tasks:
  - id: generate-solution
    type: basic
    $use: agent(local::agents.#(id="generator"))
    action: generate
    outputs:
      solution: "{{.output}}"
      iteration: 1
  
  - id: validation-loop
    type: composite
    strategy: best_effort
    tasks:
      - id: validate
        type: basic
        $use: agent(local::agents.#(id="validator"))
        action: validate
        with:
          solution: "{{.tasks.generate-solution.output.solution}}"
          criteria: "{{.workflow.input.criteria}}"
        outputs:
          valid: "{{.output.is_valid}}"
          feedback: "{{.output.feedback}}"
      
      - id: refine
        type: router
        condition: '{{.tasks.validate.output.valid | ternary "complete" "iterate"}}'
        routes:
          iterate:
            type: basic
            $use: agent(local::agents.#(id="generator"))
            action: refine
            with:
              previous: "{{.tasks.generate-solution.output.solution}}"
              feedback: "{{.tasks.validate.output.feedback}}"
          complete:
            type: aggregate
            outputs:
              final_solution: "{{.tasks.generate-solution.output.solution}}"
              validated: true
```

## Communication Patterns

### Shared Memory

Agents communicate through shared memory:

```yaml
memory:
  - resource: memory
    id: project_context
    config:
      provider: redis
      ttl: 3600

agents:
  - id: analyst
    memory:
      - id: project_context
        key: "project:{{.workflow.input.project_id}}"
        mode: "read-write"
    actions:
      - id: analyze
        prompt: |
          Analyze the data and store findings in memory.
          Previous findings are available from memory.
  
  - id: reporter
    memory:
      - id: project_context
        key: "project:{{.workflow.input.project_id}}"
        mode: "read-only"
    actions:
      - id: report
        prompt: |
          Generate report based on analysis findings in memory.
```

### Message Passing

Direct message passing between agents:

```yaml
tasks:
  - id: agent-a
    type: basic
    outputs:
      message:
        to: "agent-b"
        subject: "Data processed"
        data: "{{.output}}"
        timestamp: "{{now}}"
  
  - id: agent-b
    type: basic
    with:
      received_message: "{{.tasks.agent-a.output.message}}"
    action: process-message
```

### Event-Driven Coordination

Agents respond to events:

```yaml
tasks:
  - id: monitor
    type: basic
    $use: agent(local::agents.#(id="monitor"))
    action: watch
    outputs:
      event_type: "{{.output.event_type}}"
      severity: "{{.output.severity}}"
  
  - id: response-router
    type: router
    condition: "{{.tasks.monitor.output.severity}}"
    routes:
      critical:
        type: parallel
        tasks:
          - type: basic
            $use: agent(local::agents.#(id="incident-handler"))
            action: respond
          - type: basic
            $use: agent(local::agents.#(id="notifier"))
            action: alert
      warning:
        type: basic
        $use: agent(local::agents.#(id="logger"))
        action: log
```

## Specialization Strategies

### Role-Based Specialization

```yaml
agents:
  - id: legal-expert
    config:
      provider: anthropic
      model: claude-3-opus-20240229
    instructions: |
      You are a legal expert specializing in contract law.
      Analyze documents for legal compliance and risks.
    
  - id: financial-analyst
    config:
      provider: openai
      model: gpt-4-turbo-preview
    instructions: |
      You are a financial analyst specializing in risk assessment.
      Evaluate financial implications and ROI.
    
  - id: technical-architect
    config:
      provider: anthropic
      model: claude-3-opus-20240229
    instructions: |
      You are a solution architect specializing in system design.
      Assess technical feasibility and architecture.
```

### Domain-Specific Agents

```yaml
agents:
  - id: medical-coder
    instructions: |
      You are a medical coding specialist familiar with ICD-10, CPT, and HCPCS.
      Extract and assign appropriate medical codes from clinical notes.
    tools:
      - resource: tool
        id: medical-code-lookup
    
  - id: insurance-processor
    instructions: |
      You process insurance claims based on medical codes and policy rules.
      Determine coverage and calculate reimbursements.
    tools:
      - resource: tool
        id: policy-database
```

### Capability-Based Agents

```yaml
agents:
  - id: vision-analyzer
    config:
      provider: openai
      model: gpt-4-vision-preview
    instructions: "You analyze images and extract visual information."
    
  - id: code-generator
    config:
      provider: anthropic
      model: claude-3-opus-20240229
    instructions: "You generate high-quality code implementations."
    tools:
      - resource: tool
        id: code-executor
  
  - id: data-processor
    instructions: "You process and transform large datasets."
    tools:
      - resource: tool
        id: sql-engine
      - resource: tool
        id: data-transformer
```

## Coordination Mechanisms

### Orchestrator Pattern

```yaml
agents:
  - id: orchestrator
    instructions: |
      You coordinate multiple specialist agents to complete complex tasks.
      Break down requests, delegate to appropriate agents, and synthesize results.
    actions:
      - id: orchestrate
        prompt: |
          Task: {{.input.task}}
          Available agents: researcher, analyst, writer
          
          Create an execution plan and coordinate the agents.
        output:
          type: object
          properties:
            plan:
              type: array
              items:
                type: object
                properties:
                  step:
                    type: integer
                  agent:
                    type: string
                  action:
                    type: string
                  dependencies:
                    type: array
                    items:
                      type: integer
```

### Voting System

```yaml
tasks:
  - id: collect-votes
    type: parallel
    tasks:
      - id: agent-1-vote
        type: basic
        $use: agent(local::agents.#(id="reviewer-1"))
        action: review
        outputs:
          vote: "{{.output.decision}}"
          confidence: "{{.output.confidence}}"
      # ... more voting agents
  
  - id: tally-votes
    type: basic
    $use: agent(local::agents.#(id="vote-counter"))
    action: tally
    with:
      votes: "{{.tasks.collect-votes.children}}"
    outputs:
      decision: "{{.output.majority_decision}}"
      consensus_level: "{{.output.consensus_percentage}}"
```

### Negotiation Pattern

```yaml
agents:
  - id: buyer
    instructions: "You negotiate to minimize cost while meeting requirements."
    
  - id: seller
    instructions: "You negotiate to maximize value while maintaining fairness."
    
  - id: mediator
    instructions: "You facilitate negotiations to reach mutually beneficial agreements."

tasks:
  - id: negotiation-rounds
    type: composite
    max_iterations: 5
    tasks:
      - id: buyer-offer
        type: basic
        $use: agent(local::agents.#(id="buyer"))
        action: make-offer
        
      - id: seller-response
        type: basic
        $use: agent(local::agents.#(id="seller"))
        action: respond-to-offer
        
      - id: mediate
        type: basic
        $use: agent(local::agents.#(id="mediator"))
        action: evaluate-progress
        outputs:
          agreement_reached: "{{.output.deal_closed}}"
          next_action: "{{.output.recommendation}}"
```

## Best Practices

<AccordionGroup>
  <Accordion title="Agent Design">
    - **Single Responsibility**: Each agent should have one clear purpose
    - **Clear Instructions**: Provide specific, unambiguous instructions
    - **Appropriate Models**: Match model capabilities to agent tasks
    - **Tool Selection**: Only provide relevant tools to each agent
  </Accordion>
  
  <Accordion title="Communication">
    - **Structured Data**: Use schemas for inter-agent communication
    - **Context Preservation**: Pass relevant context between agents
    - **Error Propagation**: Handle and communicate errors clearly
    - **Feedback Loops**: Build in validation and refinement cycles
  </Accordion>
  
  <Accordion title="Performance">
    - **Parallelize When Possible**: Use parallel tasks for independent operations
    - **Minimize Handoffs**: Reduce unnecessary agent transitions
    - **Cache Results**: Store and reuse expensive computations
    - **Token Optimization**: Share context efficiently between agents
  </Accordion>
  
  <Accordion title="Reliability">
    - **Graceful Degradation**: Handle individual agent failures
    - **Timeout Management**: Set appropriate timeouts for each agent
    - **Retry Logic**: Implement smart retry for transient failures
    - **Result Validation**: Verify outputs between agent handoffs
  </Accordion>
</AccordionGroup>

## Advanced Multi-Agent Patterns

### Self-Organizing Teams

```yaml
agents:
  - id: team-builder
    instructions: |
      You dynamically assemble teams based on task requirements.
      Select appropriate agents and define their collaboration structure.
    actions:
      - id: build-team
        prompt: |
          Task requirements: {{.input.requirements}}
          Available agents: {{.input.agent_pool | toJson}}
          
          Select team members and define their roles.
        output:
          type: object
          properties:
            team:
              type: array
              items:
                type: object
                properties:
                  agent_id:
                    type: string
                  role:
                    type: string
                  responsibilities:
                    type: array
                    items:
                      type: string
```

### Competitive Agents

```yaml
tasks:
  - id: solution-competition
    type: parallel
    tasks:
      - id: solution-a
        type: basic
        $use: agent(local::agents.#(id="solver-aggressive"))
        action: solve
      
      - id: solution-b
        type: basic
        $use: agent(local::agents.#(id="solver-conservative"))
        action: solve
  
  - id: evaluate-solutions
    type: basic
    $use: agent(local::agents.#(id="evaluator"))
    action: compare
    with:
      solutions:
        aggressive: "{{.tasks.solution-competition.children.solution-a.output}}"
        conservative: "{{.tasks.solution-competition.children.solution-b.output}}"
      criteria: "{{.workflow.input.evaluation_criteria}}"
```

### Learning Ensemble

```yaml
agents:
  - id: learner
    memory:
      - id: learning_history
        key: "learn:{{.workflow.input.domain}}"
    instructions: |
      You learn from past experiences and improve over time.
      Use memory to recall previous attempts and their outcomes.
    actions:
      - id: learn-and-adapt
        prompt: |
          Task: {{.input.task}}
          
          Review past attempts from memory.
          Apply lessons learned to improve performance.
          Store new insights for future use.
```

## Next Steps

<FeatureCardList cols={2}>
  <FeatureCard title="Workflow Patterns" href="/docs/core/workflows/patterns">
    Explore how multi-agent patterns fit into larger workflows
  </FeatureCard>
  <FeatureCard title="Performance Optimization" href="/docs/core/performance/agent-optimization">
    Learn to optimize multi-agent system performance
  </FeatureCard>
</FeatureCardList>
