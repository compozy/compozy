---
title: "Template Directives"
description: "Resource composition and references using $ref and $use directives"
---

# Template Directives

Template directives are special YAML keys that enable resource composition, references, and dynamic configuration in Compozy. They allow you to build modular, reusable configurations by referencing and composing other resources.

## Overview of Directives

Compozy provides two main directive types:

- **`$ref`**: Reference existing resources by path and filter criteria
- **`$use`**: Use and instantiate resources like tools and agents

These directives enable powerful composition patterns while maintaining clean, readable configurations.

## `$ref` Directive

The `$ref` directive creates references to existing resources using path-based queries with optional filtering.

### Basic Syntax

```yaml
$ref: scope::path.#(filter_expression)
```

- **scope**: `local`, `global`, or `resource`
- **path**: Dot-notation path to the resource collection
- **filter**: JSONPath-style filter expression

### Local References

Reference resources within the same file:

```yaml
# Reference a schema by ID
input:
  $ref: local::schemas.#(id=="user_input")

# Reference a tool by ID  
tools:
  - $ref: local::tools.#(id=="weather_tool")

# Reference a task by ID
on_success:
  next:
    $ref: local::tasks.#(id=="next_step")

# Reference multiple tools by type
tools:
  - $ref: local::tools.#(category=="data_processing")
```

### Global References

Reference project-level resources from `compozy.yaml`:

```yaml
# Reference a model configuration
model:
  $ref: global::models.#(provider=="openai")

# Reference environment configuration
env:
  $ref: global::environment.#(name=="production")
```

### Resource References

Reference resources from external files:

```yaml
# Reference an agent from another file
$use: agent(resource::agent::#(id=="classifier_agent"))

# Reference a workflow component
component:
  $ref: resource::workflow::#(id=="data_processor")

# Reference shared schemas
schema:
  $ref: resource::schema::#(type=="user_profile")
```

### Filter Expressions

Filter expressions use JSONPath-like syntax to select specific resources:

```yaml
# Exact match
$ref: local::tools.#(id=="weather_tool")

# Property equality
$ref: local::agents.#(type=="classifier")

# Multiple conditions (AND)
$ref: local::tools.#(category=="api" && version=="1.0")

# String matching
$ref: local::schemas.#(name matches "user_.*")

# Numeric comparisons
$ref: local::tasks.#(priority > 5)

# Array contains
$ref: local::tools.#(tags contains "nlp")
```

## `$use` Directive

The `$use` directive instantiates and configures tools, agents, and other executable resources.

### Using Tools

```yaml
# Basic tool usage
- id: weather_check
  type: basic
  $use: tool(local::tools.#(id=="weather_tool"))
  with:
    city: "{{ .workflow.input.city }}"

# Tool with specific version
- id: data_processor  
  type: basic
  $use: tool(local::tools.#(id=="processor" && version=="2.1"))
  with:
    input_data: "{{ .workflow.input.data }}"

# External tool usage
- id: external_api
  type: basic
  $use: tool(resource::tool::#(id=="external_service"))
  with:
    endpoint: "{{ .env.API_ENDPOINT }}"
    api_key: "{{ .env.API_KEY }}"
```

### Using Agents

```yaml
# Basic agent usage
- id: classify_intent
  type: basic
  $use: agent(local::agents.#(id=="intent_classifier"))

# Agent with specific capabilities
- id: nlp_processor
  type: basic  
  $use: agent(local::agents.#(type=="nlp" && capabilities contains "sentiment"))

# External agent usage
- id: specialized_agent
  type: basic
  $use: agent(resource::agent::#(id=="domain_expert"))
```

### Using with Configuration

You can pass configuration to used resources:

```yaml
- id: configurable_tool
  type: basic
  $use: tool(local::tools.#(id=="http_client"))
  with:
    # Tool-specific configuration
    base_url: "{{ .env.API_BASE_URL }}"
    timeout: 30
    headers:
      Content-Type: "application/json"
      Authorization: "Bearer {{ .env.API_TOKEN }}"
  config:
    # Override tool defaults
    retry_attempts: 5
    cache_enabled: true
```

## Composition Patterns

### Schema Composition

Build complex schemas from simpler ones:

```yaml
schemas:
  # Base user schema
  - id: base_user
    type: object
    properties:
      id:
        type: string
      name:
        type: string
      email:
        type: string

  # Extended user schema
  - id: full_user
    type: object
    allOf:
      - $ref: local::schemas.#(id=="base_user")
      - type: object
        properties:
          profile:
            $ref: local::schemas.#(id=="user_profile")
          preferences:
            $ref: local::schemas.#(id=="user_preferences")
```

### Tool Chain Composition

Chain multiple tools together:

```yaml
tasks:
  - id: data_pipeline
    type: composite
    tasks:
      # Step 1: Extract data
      - id: extract
        type: basic
        $use: tool(local::tools.#(id=="data_extractor"))
        with:
          source: "{{ .workflow.input.source_url }}"
          
      # Step 2: Transform data  
      - id: transform
        type: basic
        $use: tool(local::tools.#(id=="data_transformer"))
        with:
          input: "{{ .tasks.extract.output }}"
          rules: "{{ .workflow.input.transform_rules }}"
          
      # Step 3: Load data
      - id: load
        type: basic
        $use: tool(local::tools.#(id=="data_loader"))
        with:
          data: "{{ .tasks.transform.output }}"
          destination: "{{ .workflow.input.destination }}"
```

### Conditional Resource Usage

Use different resources based on conditions:

```yaml
# Router task with conditional tool usage
- id: processor_router
  type: router
  condition: "{{ .workflow.input.data_type }}"
  routes:
    text:
      - id: text_processor
        type: basic
        $use: tool(local::tools.#(id=="text_processor"))
        
    image:
      - id: image_processor
        type: basic
        $use: tool(local::tools.#(id=="image_processor"))
        
    video:
      - id: video_processor
        type: basic
        $use: tool(local::tools.#(id=="video_processor"))
```

## Advanced Reference Patterns

### Dynamic References

Use templates in reference expressions:

```yaml
# Dynamic tool selection
$use: tool(local::tools.#(id=="{{ .workflow.input.processor_type }}_tool"))

# Dynamic schema reference
schema:
  $ref: local::schemas.#(version=="{{ .config.schema_version }}")

# Environment-based references
model:
  $ref: global::models.#(environment=="{{ .env.DEPLOYMENT_ENV }}")
```

### Nested References

References can be nested within referenced resources:

```yaml
workflows:
  - id: complex_workflow
    tasks:
      - $ref: local::task_templates.#(id=="data_validation")
      - $ref: local::task_templates.#(id=="data_processing")  
      - $ref: local::task_templates.#(id=="result_storage")

task_templates:
  - id: data_validation
    type: composite
    tasks:
      - id: schema_validation
        type: basic
        $use: tool(local::tools.#(id=="schema_validator"))
        with:
          schema: 
            $ref: local::schemas.#(id=="input_schema")
```

### Collection References

Reference collections of resources:

```yaml
# Include all validation tools
validation_tools:
  $ref: local::tools.#(category=="validation")

# Include all NLP agents
nlp_agents:
  $ref: local::agents.#(type=="nlp")

# Include tools by tag
data_tools:
  $ref: local::tools.#(tags contains "data")
```

## Error Handling

### Reference Resolution Errors

When references cannot be resolved:

```yaml
# Provide fallback options
primary_tool:
  $ref: local::tools.#(id=="preferred_tool")
fallback_tool:
  $ref: local::tools.#(id=="backup_tool")

# Use conditional references
tool_ref: |
  {{- if .tools.advanced_tool -}}
  local::tools.#(id=="advanced_tool")
  {{- else -}}
  local::tools.#(id=="basic_tool")
  {{- end -}}
```

### Validation

Compozy validates references at configuration load time:

- **Missing references** generate clear error messages
- **Type mismatches** are caught early
- **Circular references** are detected and prevented

## Best Practices

### 1. Use Descriptive IDs

```yaml
# Good - descriptive IDs
- id: validate_user_input
- id: process_payment_data
- id: send_notification_email

# Avoid - generic IDs
- id: tool1
- id: step_a
- id: task_x
```

### 2. Organize by Scope

```yaml
# Keep local references in the same file
input:
  $ref: local::schemas.#(id=="user_input")

# Use global references for project-wide resources
model:
  $ref: global::models.#(provider=="openai")

# Use resource references for external components
agent:
  $ref: resource::agent::#(id=="specialized_processor")
```

### 3. Group Related References

```yaml
# Group related schemas
schemas:
  - id: user_input
    # ... definition
  - id: user_output  
    # ... definition
  - id: user_profile
    # ... definition

# Group related tools
tools:
  - id: user_validator
    # ... definition
  - id: user_processor
    # ... definition  
  - id: user_formatter
    # ... definition
```

### 4. Use Meaningful Filters

```yaml
# Good - specific, meaningful filters
$ref: local::tools.#(id=="weather_api" && version=="2.0")
$ref: local::agents.#(type=="classifier" && domain=="finance")

# Avoid - overly complex filters
$ref: local::tools.#(id matches ".*_tool" && (version > "1.0" || tags contains "legacy"))
```

### 5. Document Complex References

```yaml
# Document complex reference patterns
nlp_pipeline:
  description: "Multi-stage NLP processing pipeline"
  tasks:
    # Stage 1: Text preprocessing
    - $ref: local::nlp_tasks.#(stage=="preprocessing")
    # Stage 2: Entity extraction  
    - $ref: local::nlp_tasks.#(stage=="extraction")
    # Stage 3: Sentiment analysis
    - $ref: local::nlp_tasks.#(stage=="sentiment")
```

## Global Value References

The template engine supports global value sharing across templates using the `AddGlobalValue()` function. This enables cross-template and cross-workflow data sharing:

### Setting Global Values

```yaml
# Set global values from workflow context
tasks:
  - id: set_global_config
    type: basic
    $use: tool(local::tools.#(id="config_manager"))
    with:
      global_key: "app_config"
      config_data:
        version: "1.0.0"
        environment: "{{ .env.ENVIRONMENT }}"
        features:
          - authentication
          - logging
          - monitoring
```

### Using Global Values in References

```yaml
# Reference global values in directives
model:
  $ref: global::models.#(provider=="{{ .global.preferred_provider }}")
  
tools:
  - $ref: global::tools.#(environment=="{{ .global.environment }}")
  
agents:
  - $ref: global::agents.#(version=="{{ .global.agent_version }}")
```

### Global Value Patterns

```yaml
# Global configuration management
global_config:
  # System-wide settings
  system:
    timeout: "{{ .global.system_timeout | default 30 }}"
    retries: "{{ .global.system_retries | default 3 }}"
    
  # Environment-specific settings
  environment:
    database_url: "{{ .global.db_config[.env.ENVIRONMENT].url }}"
    cache_ttl: "{{ .global.cache_config[.env.ENVIRONMENT].ttl }}"
    
  # Feature flags
  features:
    new_ui: "{{ .global.feature_flags.new_ui | default false }}"
    advanced_analytics: "{{ .global.feature_flags.advanced_analytics | default false }}"
```

## Dynamic Directives

Directives can be dynamically constructed using template expressions:

### Dynamic Reference Construction

```yaml
# Dynamic tool selection based on input
tasks:
  - id: dynamic_processing
    type: basic
    $use: tool(local::tools.#(id=="{{ .workflow.input.tool_type }}_processor"))
    with:
      data: "{{ .workflow.input.data }}"
      mode: "{{ .workflow.input.processing_mode }}"
      
  # Dynamic agent selection based on user role
  - id: role_based_agent
    type: basic
    $use: agent(local::agents.#(role=="{{ .workflow.input.user_role }}"))
    with:
      user_context: "{{ .workflow.input.user_context }}"
```

### Dynamic Schema References

```yaml
# Dynamic schema selection
schemas:
  - id: dynamic_input
    $ref: local::schemas.#(type=="{{ .workflow.input.data_type }}_input")
  - id: dynamic_output
    $ref: local::schemas.#(type=="{{ .workflow.input.data_type }}_output")
    
# Dynamic validation rules
validation:
  input_schema:
    $ref: local::schemas.#(version=="{{ .global.schema_version }}" && type=="input")
  output_schema:
    $ref: local::schemas.#(version=="{{ .global.schema_version }}" && type=="output")
```

### Environment-Based References

```yaml
# Environment-specific resource selection
model:
  $ref: global::models.#(environment=="{{ .env.DEPLOYMENT_ENV }}")
  
tools:
  - $ref: global::tools.#(environment=="{{ .env.DEPLOYMENT_ENV }}" && type=="database")
  - $ref: global::tools.#(environment=="{{ .env.DEPLOYMENT_ENV }}" && type=="cache")
  
agents:
  - $ref: global::agents.#(environment=="{{ .env.DEPLOYMENT_ENV }}" && capability=="nlp")
```

## Advanced Resource Referencing

### Conditional Resource Loading

```yaml
# Load resources conditionally
tools:
  # Always load core tools
  - $ref: local::tools.#(category=="core")
  
  # Load optional tools based on feature flags
  - $ref: |
      {{- if .global.feature_flags.advanced_processing -}}
      local::tools.#(category=="advanced")
      {{- else -}}
      local::tools.#(category=="basic")
      {{- end -}}
      
  # Load environment-specific tools
  - $ref: |
      {{- if eq .env.ENVIRONMENT "production" -}}
      local::tools.#(category=="production" && verified=="true")
      {{- else -}}
      local::tools.#(category=="development")
      {{- end -}}
```

### Resource Composition Patterns

```yaml
# Compose resources from multiple sources
composed_config:
  # Base configuration
  base:
    $ref: local::configs.#(type=="base")
    
  # Environment overrides
  environment:
    $ref: global::configs.#(environment=="{{ .env.ENVIRONMENT }}")
    
  # Feature-specific additions
  features:
    $ref: local::configs.#(features contains "{{ .workflow.input.feature }}")
    
  # Final merged configuration
  merged: |
    {{- $base := .refs.base -}}
    {{- $env := .refs.environment -}}
    {{- $features := .refs.features -}}
    {{- merge $base $env $features | toJson -}}
```

### Multi-Level Resource References

```yaml
# Reference resources at different levels
resource_hierarchy:
  # System-level resources
  system:
    - $ref: global::system.#(type=="core")
    - $ref: global::system.#(type=="monitoring")
    
  # Application-level resources
  application:
    - $ref: local::application.#(module=="auth")
    - $ref: local::application.#(module=="data")
    
  # User-level resources
  user:
    - $ref: resource::user::#(id=="{{ .workflow.input.user_id }}")
    
  # Context-specific resources
  context:
    - $ref: |
        {{- $context := .workflow.input.context -}}
        {{- range $key, $value := $context -}}
        resource::context::#(key=="{{ $key }}" && value=="{{ $value }}")
        {{- end -}}
```

## Error Handling for Missing References

### Graceful Reference Fallbacks

```yaml
# Provide multiple fallback options
primary_tool:
  $ref: local::tools.#(id=="preferred_tool" && version=="latest")
  
# Fallback chain
fallback_tools:
  - $ref: local::tools.#(id=="preferred_tool" && version=="latest")
  - $ref: local::tools.#(id=="preferred_tool" && version=="stable")
  - $ref: local::tools.#(id=="backup_tool" && version=="latest")
  - $ref: local::tools.#(id=="default_tool")
```

### Error-Resilient References

```yaml
# Handle missing references gracefully
tasks:
  - id: resilient_task
    type: basic
    $use: |
      {{- if .tools.advanced_processor -}}
      tool(local::tools.#(id=="advanced_processor"))
      {{- else if .tools.standard_processor -}}
      tool(local::tools.#(id=="standard_processor"))
      {{- else -}}
      tool(local::tools.#(id=="basic_processor"))
      {{- end -}}
    with:
      data: "{{ .workflow.input.data }}"
      mode: "{{ .workflow.input.mode | default 'safe' }}"
```

### Reference Validation

```yaml
# Validate references before use
validation:
  required_tools:
    - name: "data_processor"
      reference: "local::tools.#(id=='data_processor')"
      required: true
    - name: "backup_processor"
      reference: "local::tools.#(id=='backup_processor')"
      required: false
      
  validation_task:
    type: basic
    $use: tool(local::tools.#(id=="validator"))
    with:
      references: "{{ .validation.required_tools | toJson }}"
      context: "{{ . | toJson }}"
```

### Reference Debugging

```yaml
# Debug reference resolution
debug_references:
  # List all available references
  available_tools: "{{ keys .tools | sort | join ', ' }}"
  available_agents: "{{ keys .agents | sort | join ', ' }}"
  available_schemas: "{{ keys .schemas | sort | join ', ' }}"
  
  # Test reference resolution
  test_references:
    - reference: "local::tools.#(id=='test_tool')"
      resolved: "{{ hasKey .tools 'test_tool' }}"
    - reference: "global::models.#(provider=='openai')"
      resolved: "{{ hasKey .global.models 'openai' }}"
      
  # Debug reference filters
  filter_debug:
    all_tools: "{{ .tools | toPrettyJson }}"
    filtered_tools: "{{ .tools | selectKeys (list 'category' 'nlp') | toPrettyJson }}"
```

Template directives enable powerful composition and modularity in Compozy configurations. Next, explore [Sprig Functions](./sprig-functions) to learn about data transformation capabilities.
