---
title: "Template Directives"
description: "Resource composition and references using $ref and $use directives"
---

Template directives are special YAML keys that enable resource composition, references, and dynamic configuration in Compozy. They allow you to build modular, reusable configurations by referencing and composing other resources.

## Overview

Compozy provides two main directive types that enable powerful composition patterns:

<FeatureCardList cols={2} size="default">
  <FeatureCard
    title="$ref Directive"
    description="Reference existing resources by path and filter criteria"
    icon="Link"
  />
  <FeatureCard
    title="$use Directive"
    description="Use and instantiate resources like tools and agents"
    icon="Play"
  />
</FeatureCardList>

<Callout type="info">
  **Composition Benefits**: Directives enable clean, readable configurations while promoting reusability and modularity across your Compozy resources.
</Callout>

## `$ref` Directive

The `$ref` directive creates references to existing resources using path-based queries with optional filtering.

### Basic Syntax

```yaml title="Reference Syntax"
$ref: scope::path.#(filter_expression)
```

**Components:**
- **scope**: `local`, `global`, or `resource`
- **path**: Dot-notation path to the resource collection
- **filter**: JSONPath-style filter expression

### Reference Types

<Tabs items={["Local", "Global", "Resource", "Filters"]}>
<Tab>
**Local References** point to resources within the same file:

```yaml title="Local References"
# Reference a schema by ID
input:
  $ref: local::schemas.#(id=="user_input")

# Reference a tool by ID
tools:
  - $ref: local::tools.#(id=="weather_tool")

# Reference a task by ID
on_success:
  next:
    $ref: local::tasks.#(id=="next_step")

# Reference multiple tools by type
tools:
  - $ref: local::tools.#(category=="data_processing")
```

**Local reference patterns:**
- Use for resources defined in the same file
- Ideal for task chaining and schema reuse
- Keeps related resources together
</Tab>

<Tab>
**Global References** point to project-level resources from `compozy.yaml`:

```yaml title="Global References"
# Reference a model configuration
model:
  $ref: global::models.#(provider=="openai")

# Reference environment configuration
env:
  $ref: global::environment.#(name=="production")
```

**Global reference patterns:**
- Use for project-wide configurations
- Ideal for models, environments, and shared settings
- Promotes consistency across workflows
</Tab>

<Tab>
**Resource References** point to resources from external files:

```yaml title="Resource References"
# Reference an agent from another file
$use: agent(resource::agent::#(id=="classifier_agent"))

# Reference a workflow component
component:
  $ref: resource::workflow::#(id=="data_processor")

# Reference shared schemas
schema:
  $ref: resource::schema::#(type=="user_profile")
```

**Resource reference patterns:**
- Use for external file resources
- Ideal for shared components and libraries
- Enables modularity across projects
</Tab>

<Tab>
**Filter Expressions** use JSONPath-like syntax to select specific resources:

```yaml title="Filter Expressions"
# Exact match
$ref: local::tools.#(id=="weather_tool")

# Property equality
$ref: local::agents.#(type=="classifier")

# Multiple conditions (AND)
$ref: local::tools.#(category=="api" && version=="1.0")

# String matching
$ref: local::schemas.#(name matches "user_.*")

# Numeric comparisons
$ref: local::tasks.#(priority > 5)

# Array contains
$ref: local::tools.#(tags contains "nlp")
```

**Filter operators:**
- `==` for exact matches
- `!=` for not equal
- `>`, `>=`, `<`, `<=` for numeric comparisons
- `matches` for regex patterns
- `contains` for array membership
- `&&` for logical AND
- `||` for logical OR
</Tab>
</Tabs>

## `$use` Directive

The `$use` directive instantiates and configures tools, agents, and other executable resources.

<Tabs items={["Using Tools", "Using Agents", "With Configuration"]}>
<Tab>
**Using Tools** enables tool execution within tasks:

```yaml title="Tool Usage"
# Basic tool usage
- id: weather_check
  type: basic
  $use: tool(local::tools.#(id=="weather_tool"))
  with:
    city: "{{ .workflow.input.city }}"

# Tool with specific version
- id: data_processor
  type: basic
  $use: tool(local::tools.#(id=="processor" && version=="2.1"))
  with:
    input_data: "{{ .workflow.input.data }}"

# External tool usage
- id: external_api
  type: basic
  $use: tool(resource::tool::#(id=="external_service"))
  with:
    endpoint: "{{ .env.API_ENDPOINT }}"
    api_key: "{{ .env.API_KEY }}"
```

**Tool usage patterns:**
- Use `tool(reference)` syntax for tool instantiation
- Pass parameters via `with` section
- Filter tools by version, capabilities, or other criteria
</Tab>

<Tab>
**Using Agents** enables AI agent execution within tasks:

```yaml title="Agent Usage"
# Basic agent usage
- id: classify_intent
  type: basic
  $use: agent(local::agents.#(id=="intent_classifier"))

# Agent with specific capabilities
- id: nlp_processor
  type: basic
  $use: agent(local::agents.#(type=="nlp" && capabilities contains "sentiment"))

# External agent usage
- id: specialized_agent
  type: basic
  $use: agent(resource::agent::#(id=="domain_expert"))
```

**Agent usage patterns:**
- Use `agent(reference)` syntax for agent instantiation
- Filter agents by type, capabilities, or domain
- Combine with actions for specific behavior
</Tab>

<Tab>
**Configuration** allows customization of used resources:

```yaml title="Configuration Usage"
- id: configurable_tool
  type: basic
  $use: tool(local::tools.#(id=="http_client"))
  with:
    # Tool-specific configuration
    base_url: "{{ .env.API_BASE_URL }}"
    timeout: 30
    headers:
      Content-Type: "application/json"
      Authorization: "Bearer {{ .env.API_TOKEN }}"
  config:
    # Override tool defaults
    retry_attempts: 5
    cache_enabled: true
```

**Configuration patterns:**
- Use `with` for runtime parameters
- Use `config` for tool/agent overrides
- Combine templates for dynamic configuration
</Tab>
</Tabs>

## Composition Patterns

<Tabs items={["Schema Composition", "Tool Chains", "Conditional Usage"]}>
<Tab>
**Schema Composition** builds complex schemas from simpler ones:

```yaml title="Schema Composition"
schemas:
  # Base user schema
  - id: base_user
    type: object
    properties:
      id:
        type: string
      name:
        type: string
      email:
        type: string

  # Extended user schema
  - id: full_user
    type: object
    allOf:
      - $ref: local::schemas.#(id=="base_user")
      - type: object
        properties:
          profile:
            $ref: local::schemas.#(id=="user_profile")
          preferences:
            $ref: local::schemas.#(id=="user_preferences")
```

**Schema composition benefits:**
- Reuse common schema definitions
- Build complex structures incrementally
- Maintain consistency across schemas
</Tab>

<Tab>
**Tool Chains** connect multiple tools in sequence:

```yaml title="Tool Chain Composition"
tasks:
  - id: data_pipeline
    type: composite
    tasks:
      # Step 1: Extract data
      - id: extract
        type: basic
        $use: tool(local::tools.#(id=="data_extractor"))
        with:
          source: "{{ .workflow.input.source_url }}"

      # Step 2: Transform data
      - id: transform
        type: basic
        $use: tool(local::tools.#(id=="data_transformer"))
        with:
          input: "{{ .tasks.extract.output }}"
          rules: "{{ .workflow.input.transform_rules }}"

      # Step 3: Load data
      - id: load
        type: basic
        $use: tool(local::tools.#(id=="data_loader"))
        with:
          data: "{{ .tasks.transform.output }}"
          destination: "{{ .workflow.input.destination }}"
```

**Tool chain patterns:**
- Use composite tasks for sequences
- Chain outputs between tools
- Build reusable processing pipelines
</Tab>

<Tab>
**Conditional Usage** selects resources based on conditions:

```yaml title="Conditional Resource Usage"
# Router task with conditional tool usage
- id: processor_router
  type: router
  condition: "{{ .workflow.input.data_type }}"
  routes:
    text:
      - id: text_processor
        type: basic
        $use: tool(local::tools.#(id=="text_processor"))

    image:
      - id: image_processor
        type: basic
        $use: tool(local::tools.#(id=="image_processor"))

    video:
      - id: video_processor
        type: basic
        $use: tool(local::tools.#(id=="video_processor"))
```

**Conditional patterns:**
- Use router tasks for branching logic
- Select tools based on input data
- Adapt behavior dynamically
</Tab>
</Tabs>

## Advanced Patterns

<Tabs items={["Dynamic References", "Nested References", "Collection References"]}>
<Tab>
**Dynamic References** use templates in reference expressions:

```yaml title="Dynamic References"
# Dynamic tool selection
$use: tool(local::tools.#(id=="{{ .workflow.input.processor_type }}_tool"))

# Dynamic schema reference
schema:
  $ref: local::schemas.#(version=="{{ .config.schema_version }}")

# Environment-based references
model:
  $ref: global::models.#(environment=="{{ .env.DEPLOYMENT_ENV }}")
```

**Dynamic reference benefits:**
- Adapt references based on runtime data
- Support environment-specific configurations
- Enable flexible resource selection
</Tab>

<Tab>
**Nested References** allow references within referenced resources:

```yaml title="Nested References"
workflows:
  - id: complex_workflow
    tasks:
      - $ref: local::task_templates.#(id=="data_validation")
      - $ref: local::task_templates.#(id=="data_processing")
      - $ref: local::task_templates.#(id=="result_storage")

task_templates:
  - id: data_validation
    type: composite
    tasks:
      - id: schema_validation
        type: basic
        $use: tool(local::tools.#(id=="schema_validator"))
        with:
          schema:
            $ref: local::schemas.#(id=="input_schema")
```

**Nested reference patterns:**
- Create hierarchical compositions
- Build complex resource structures
- Enable deep modularity
</Tab>

<Tab>
**Collection References** reference groups of resources:

```yaml title="Collection References"
# Include all validation tools
validation_tools:
  $ref: local::tools.#(category=="validation")

# Include all NLP agents
nlp_agents:
  $ref: local::agents.#(type=="nlp")

# Include tools by tag
data_tools:
  $ref: local::tools.#(tags contains "data")
```

**Collection reference benefits:**
- Include multiple resources at once
- Group related resources
- Simplify configuration management
</Tab>
</Tabs>

## Error Handling

<Tabs items={["Reference Fallbacks", "Validation", "Best Practices"]}>
<Tab>
**Reference Fallbacks** handle missing references gracefully:

```yaml title="Reference Fallbacks"
# Provide fallback options
primary_tool:
  $ref: local::tools.#(id=="preferred_tool")
fallback_tool:
  $ref: local::tools.#(id=="backup_tool")

# Use conditional references
tool_ref: |
  {{- if .tools.advanced_tool -}}
  local::tools.#(id=="advanced_tool")
  {{- else -}}
  local::tools.#(id=="basic_tool")
  {{- end -}}
```

**Fallback strategies:**
- Provide multiple fallback options
- Use conditional logic for resource selection
- Implement graceful degradation
</Tab>

<Tab>
**Validation** ensures reference integrity:

Compozy validates references at configuration load time:

- **Missing references** generate clear error messages
- **Type mismatches** are caught early
- **Circular references** are detected and prevented

**Validation features:**
- Early error detection
- Clear error messages
- Circular reference detection
- Type safety verification
</Tab>

<Tab>
**Best Practices** for reliable directive usage:

```yaml title="Best Practices"
# ✅ Good - descriptive IDs
- id: validate_user_input
- id: process_payment_data
- id: send_notification_email

# ❌ Avoid - generic IDs
- id: tool1
- id: step_a
- id: task_x
```

**Best practice guidelines:**
- Use descriptive, meaningful IDs
- Organize references by scope
- Group related references together
- Use meaningful filter expressions
- Document complex reference patterns
</Tab>
</Tabs>

## References

<ReferenceCardList>
  <ReferenceCard
    title="Sprig Functions"
    description="Learn about data transformation capabilities with template functions"
    href="/docs/core/yaml-templates/sprig-functions"
    icon="Zap"
  />
  <ReferenceCard
    title="Context Variables"
    description="Understand how to access and use context data in directives"
    href="/docs/core/yaml-templates/context-variables"
    icon="Database"
  />
  <ReferenceCard
    title="Basic Tasks"
    description="See how directives work in basic task configuration"
    href="/docs/core/tasks/basic-tasks"
    icon="Play"
  />
</ReferenceCardList>

Template directives enable powerful composition and modularity in Compozy configurations, allowing you to build reusable, maintainable workflow configurations.
