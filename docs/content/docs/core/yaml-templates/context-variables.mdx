---
title: "Context Variables"
description: "Accessing workflow data, task outputs, and environment variables in templates"
---

# Context Variables

Context variables provide access to data from various sources throughout your Compozy workflows. Understanding the context structure and data access patterns is essential for building dynamic, data-driven configurations.

## Default Context Fields

Compozy's template engine automatically initializes default context fields through the `preprocessContext()` function. These fields are always available in your templates, even if not explicitly provided:

```yaml
# Default context structure (automatically added)
context:
  env: {}        # Environment variables map
  input: {}      # Workflow input data
  output: null   # Current task output (null by default)
  trigger: {}    # Workflow trigger context
  tools: {}      # Available tools registry
  tasks: {}      # Task execution results
  agents: {}     # Agent execution state
```

### Default Field Behavior

- **env**: Empty map if no environment variables are provided
- **input**: Empty map if no workflow input is specified
- **output**: `null` by default, populated during task execution
- **trigger**: Empty map for signal-based workflows
- **tools**: Registry of available tools and their state
- **tasks**: Task execution results, populated as tasks complete
- **agents**: Agent state and execution context

### Context Preprocessing

The template engine processes context through several stages:

1. **Default Field Initialization**: Missing fields are added with default values
2. **Global Value Merging**: Global values from `AddGlobalValue()` are merged in
3. **Template Rendering**: Final context is passed to Go templates

```go
// Example of context preprocessing
processedContext := templateEngine.preprocessContext(originalContext)
// processedContext now has all default fields + global values
```

## Context Structure

The template context is a hierarchical data structure that provides access to:

- **Workflow data**: Input, state, and metadata
- **Task outputs**: Results from executed tasks
- **Environment variables**: System and runtime configuration
- **Collection context**: Iteration variables for collection tasks
- **Tool and agent data**: Available resources and their state

## Core Context Variables

### Workflow Context

Access workflow-level data and metadata:

```yaml
# Workflow input data
user_id: "{{ .workflow.input.user_id }}"
search_query: "{{ .workflow.input.query }}"
preferences: "{{ .workflow.input.user_preferences }}"

# Workflow metadata
workflow_id: "{{ .workflow.id }}"
workflow_version: "{{ .workflow.version }}"
started_at: "{{ .workflow.started_at }}"

# Workflow configuration
timeout: "{{ .workflow.config.timeout }}"
retry_policy: "{{ .workflow.config.retry_policy }}"
```

### Task Context

Access outputs and state from other tasks:

```yaml
# Task outputs
weather_data: "{{ .tasks.weather_check.output.temperature }}"
user_profile: "{{ .tasks.get_user.output }}"
validation_result: "{{ .tasks.validate_input.output.is_valid }}"

# Task metadata
task_duration: "{{ .tasks.weather_check.duration }}"
task_status: "{{ .tasks.weather_check.status }}"
task_attempt: "{{ .tasks.weather_check.attempt }}"

# Complex output access
nested_data: "{{ .tasks.api_call.output.data.results.0.name }}"
array_length: "{{ len .tasks.fetch_items.output.items }}"
```

### Environment Variables

Access system and runtime environment data:

```yaml
# Environment variables
api_key: "{{ .env.OPENAI_API_KEY }}"
database_url: "{{ .env.DATABASE_URL }}"
debug_mode: "{{ .env.DEBUG | default 'false' | bool }}"

# Environment with defaults
port: "{{ .env.PORT | default '3000' | int }}"
timeout: "{{ .env.TIMEOUT | default '30' | int }}"
log_level: "{{ .env.LOG_LEVEL | default 'info' | lower }}"

# Environment-based configuration
is_production: "{{ eq .env.NODE_ENV 'production' }}"
base_url: "{{ .env.API_BASE_URL | default 'http://localhost:3000' }}"
```

### Collection Context

Special variables available within collection tasks:

```yaml
# Collection iteration
- id: process_items
  type: collection
  items: "{{ .workflow.input.data_items }}"
  task:
    id: "process-{{ .index }}"
    type: basic
    with:
      # Current item data
      item_id: "{{ .item.id }}"
      item_name: "{{ .item.name }}"
      item_data: "{{ .item }}"
      
      # Iteration context
      current_index: "{{ .index }}"
      is_first: "{{ eq .index 0 }}"
      is_last: "{{ eq .index (sub (len .items) 1) }}"
      
      # Collection metadata
      total_items: "{{ len .items }}"
      batch_id: "{{ printf '%s_batch_%d' .workflow.id .index }}"
```

### Tool and Agent Context

Access available tools and agents:

```yaml
# Tool availability
has_weather_tool: "{{ hasKey .tools 'weather_tool' }}"
available_tools: "{{ keys .tools | join ', ' }}"

# Agent information
current_agent: "{{ .agents.current.id }}"
agent_model: "{{ .agents.current.model }}"

# Tool outputs (when used in task context)
tool_result: "{{ .tool.output }}"
tool_error: "{{ .tool.error }}"
```

## Advanced Context Patterns

### Nested Data Access

Navigate complex nested data structures:

```yaml
# Deep object access
user_email: "{{ .tasks.get_user.output.profile.contact.email }}"
first_tag: "{{ .tasks.get_metadata.output.tags.0 }}"

# Safe nested access with defaults
city: "{{ .tasks.get_location.output.address.city | default 'Unknown' }}"
phone: "{{ coalesce .user.contact.phone .user.profile.phone 'No phone' }}"

# Array element access
first_result: "{{ index .tasks.search.output.results 0 }}"
last_item: "{{ index .tasks.fetch.output.items (sub (len .tasks.fetch.output.items) 1) }}"
```

### Conditional Context Access

Handle optional or conditional data:

```yaml
# Check if data exists before using
user_name: |
  {{- if .tasks.get_user.output -}}
    {{ .tasks.get_user.output.name }}
  {{- else -}}
    Anonymous
  {{- end -}}

# Safe access with error handling
safe_value: "{{ .tasks.risky_operation.output.value | default 'fallback' }}"

# Multiple fallback options
notification_email: |
  {{- coalesce 
      .tasks.get_user.output.notification_email 
      .tasks.get_user.output.primary_email 
      .workflow.input.default_email 
      'noreply@example.com' -}}
```

### Dynamic Context Building

Build dynamic context data:

```yaml
# Create custom context objects
user_context:
  id: "{{ .workflow.input.user_id }}"
  profile: "{{ .tasks.get_user.output }}"
  preferences: "{{ .tasks.get_preferences.output }}"
  session_id: "{{ .workflow.id }}"
  timestamp: "{{ now | date '2006-01-02T15:04:05Z' }}"

# Merge multiple contexts
combined_data: |
  {{- $base := .tasks.base_data.output -}}
  {{- $extra := .tasks.extra_data.output -}}
  {{- merge $base $extra | toJson -}}
```

## Context in Different Task Types

### Basic Tasks

```yaml
- id: api_request
  type: basic
  $use: tool(local::tools.#(id=="http_client"))
  with:
    # Workflow input
    url: "{{ .workflow.input.api_endpoint }}"
    
    # Environment configuration
    api_key: "{{ .env.API_KEY }}"
    
    # Previous task output
    user_id: "{{ .tasks.authenticate.output.user_id }}"
    
    # Dynamic headers
    headers:
      Authorization: "Bearer {{ .tasks.authenticate.output.token }}"
      Content-Type: "application/json"
      X-Request-ID: "{{ .workflow.id }}"
```

### Composite Tasks

```yaml
- id: user_onboarding
  type: composite
  tasks:
    - id: create_account
      type: basic
      with:
        email: "{{ .workflow.input.email }}"
        name: "{{ .workflow.input.name }}"
        
    - id: setup_profile
      type: basic
      with:
        user_id: "{{ .tasks.create_account.output.user_id }}"
        preferences: "{{ .workflow.input.preferences }}"
        
    - id: send_welcome
      type: basic
      with:
        recipient: "{{ .tasks.create_account.output.email }}"
        user_name: "{{ .tasks.create_account.output.name }}"
        profile_url: "{{ printf '%s/profile/%s' .env.BASE_URL .tasks.create_account.output.user_id }}"
```

### Parallel Tasks

```yaml
- id: parallel_processing
  type: parallel
  strategy: wait_all
  tasks:
    - id: process_images
      type: basic
      with:
        images: "{{ .workflow.input.images }}"
        quality: "{{ .workflow.input.quality | default 'medium' }}"
        
    - id: process_videos
      type: basic
      with:
        videos: "{{ .workflow.input.videos }}"
        resolution: "{{ .workflow.input.resolution | default '720p' }}"
        
    - id: process_documents
      type: basic
      with:
        documents: "{{ .workflow.input.documents }}"
        format: "{{ .workflow.input.output_format | default 'pdf' }}"
```

### Router Tasks

```yaml
- id: routing_logic
  type: router
  condition: |
    {{- $user_type := .tasks.classify_user.output.type -}}
    {{- $priority := .tasks.classify_user.output.priority -}}
    {{- if and (eq $user_type "premium") (gt $priority 8) -}}
      premium_fast
    {{- else if eq $user_type "premium" -}}
      premium_standard
    {{- else -}}
      standard
    {{- end -}}
  routes:
    premium_fast:
      - id: fast_processing
        with:
          user_data: "{{ .tasks.classify_user.output }}"
          priority: 10
    premium_standard:
      - id: standard_processing
        with:
          user_data: "{{ .tasks.classify_user.output }}"
          priority: 5
    standard:
      - id: basic_processing
        with:
          user_data: "{{ .tasks.classify_user.output }}"
          priority: 1
```

## Context Debugging

### Inspect Available Context

```yaml
# Debug: Print entire context
debug_context: "{{ . | toPrettyJson }}"

# Debug: Print specific sections
debug_workflow: "{{ .workflow | toPrettyJson }}"
debug_tasks: "{{ .tasks | toPrettyJson }}"
debug_env: "{{ .env | toPrettyJson }}"

# Debug: List available keys
available_tasks: "{{ keys .tasks | join ', ' }}"
available_env: "{{ keys .env | join ', ' }}"
```

### Context Validation

```yaml
# Validate required context
validation:
  has_user_id: "{{ hasKey .workflow.input 'user_id' }}"
  has_auth_token: "{{ hasKey .tasks.authenticate.output 'token' }}"
  has_api_key: "{{ hasKey .env 'API_KEY' }}"
  
# Conditional execution based on context
process_data: |
  {{- if and 
      (hasKey .workflow.input "data") 
      (not (empty .workflow.input.data)) -}}
    {{ .workflow.input.data | toJson }}
  {{- else -}}
    {}
  {{- end -}}
```

## Best Practices

### 1. Use Meaningful Variable Names

```yaml
# Good - descriptive access
user_email: "{{ .tasks.get_user_profile.output.email }}"
auth_token: "{{ .tasks.authenticate_user.output.access_token }}"

# Avoid - unclear references
data: "{{ .tasks.task1.output.data }}"
result: "{{ .tasks.step2.output }}"
```

### 2. Provide Fallback Values

```yaml
# Always provide sensible defaults
timeout: "{{ .workflow.config.timeout | default 30 }}"
retries: "{{ .env.MAX_RETRIES | default 3 | int }}"
user_name: "{{ .tasks.get_user.output.name | default 'Guest' }}"
```

### 3. Validate Context Before Use

```yaml
# Check existence before accessing nested data
safe_access: |
  {{- if and .tasks.api_call.output (hasKey .tasks.api_call.output "data") -}}
    {{ .tasks.api_call.output.data.result }}
  {{- else -}}
    null
  {{- end -}}
```

### 4. Use Type-Appropriate Conversions

```yaml
# Convert types as needed
port_number: "{{ .env.PORT | default '3000' | int }}"
debug_flag: "{{ .env.DEBUG | default 'false' | bool }}"
timeout_float: "{{ .config.timeout | default '30.5' | float64 }}"
```

### 5. Document Complex Context Usage

```yaml
# Document complex context access patterns
user_notification_config:
  # User's preferred notification method from profile
  method: "{{ .tasks.get_user_profile.output.notifications.method | default 'email' }}"
  
  # Fallback to workflow input if profile incomplete
  email: "{{ coalesce .tasks.get_user_profile.output.email .workflow.input.email }}"
  
  # Environment-based configuration
  service_url: "{{ .env.NOTIFICATION_SERVICE_URL }}"
  
  # Dynamic content based on user type
  template: |
    {{- if eq .tasks.get_user_profile.output.type "premium" -}}
      premium_notification
    {{- else -}}
      standard_notification
    {{- end -}}
```

## Integration Patterns

### MCP Context Integration

MCP (Model Context Protocol) servers provide external context that can be integrated into workflows:

```yaml
# MCP context variables
agents:
  - id: file_agent
    config:
      $ref: global::models.#(provider=="groq")
    mcps:
      - id: file_server
        transport: stdio
        command: docker mcp gateway run
        proto: "2025-03-26"
        start_timeout: 15s
    actions:
      - id: list_files
        prompt: |
          Use MCP tools to list files in {{ .workflow.input.directory }}.
          Current context: {{ .workflow | toJson }}
          Available tools: {{ keys .tools | join ", " }}
```

### Memory Context Integration

Memory references provide persistent context across workflow executions:

```yaml
# Memory-backed context
agents:
  - id: personalized_agent
    config:
      $ref: global::models.#(provider=="groq")
    memory:
      - id: user_memory
        key: "user:{{.workflow.input.user_id}}"
        mode: read-write
    instructions: |
      You are a personalized assistant for user {{.workflow.input.user_id}}.
      Use your memory to provide contextual responses.
      Current session: {{.workflow.id}}
      User preferences: {{.workflow.input.preferences | default "none"}}
```

### Multi-Agent Context Sharing

Share context between multiple agents in complex workflows:

```yaml
# Shared context across agents
tasks:
  - id: analyze_data
    type: basic
    $use: agent(local::agents.#(id="analyzer"))
    with:
      data: "{{ .workflow.input.data }}"
      context: "{{ .workflow.input.context }}"
    outputs:
      analysis: "{{ .output.analysis }}"
      confidence: "{{ .output.confidence }}"
      
  - id: generate_report
    type: basic
    $use: agent(local::agents.#(id="reporter"))
    with:
      # Share context from previous task
      analysis: "{{ .tasks.analyze_data.output.analysis }}"
      confidence: "{{ .tasks.analyze_data.output.confidence }}"
      # Add global context
      report_template: "{{ .global.report_template }}"
      user_preferences: "{{ .workflow.input.preferences }}"
```

### Cross-Workflow Context Management

Manage context across different workflows using global values:

```yaml
# Global context sharing
tasks:
  - id: set_global_context
    type: basic
    $use: tool(local::tools.#(id="context_manager"))
    with:
      # Set global values for other workflows
      global_key: "session_{{ .workflow.id }}"
      context_data:
        user_id: "{{ .workflow.input.user_id }}"
        session_start: "{{ now }}"
        preferences: "{{ .workflow.input.preferences }}"
        
  - id: use_global_context
    type: basic
    $use: agent(local::agents.#(id="context_aware_agent"))
    with:
      # Access global context from other workflows
      session_context: "{{ .global.session_context }}"
      shared_data: "{{ .global.shared_data }}"
      # Combine with local context
      local_data: "{{ .workflow.input.data }}"
```

### Enterprise Context Patterns

#### Tenant-Aware Context

```yaml
# Multi-tenant context management
context_patterns:
  tenant_context:
    tenant_id: "{{ .workflow.input.tenant_id }}"
    tenant_config: "{{ .global.tenant_configs[.workflow.input.tenant_id] }}"
    user_context: "{{ .workflow.input.user_context }}"
    
tasks:
  - id: tenant_aware_processing
    type: basic
    $use: agent(local::agents.#(id="tenant_agent"))
    with:
      tenant_id: "{{ .workflow.input.tenant_id }}"
      tenant_config: "{{ .global.tenant_configs[.workflow.input.tenant_id] }}"
      user_permissions: "{{ .global.user_permissions[.workflow.input.user_id] }}"
      data_isolation: "{{ .global.data_isolation[.workflow.input.tenant_id] }}"
```

#### Audit Context Tracking

```yaml
# Audit and compliance context
audit_context:
  request_id: "{{ .workflow.id }}"
  user_id: "{{ .workflow.input.user_id }}"
  timestamp: "{{ now }}"
  source_ip: "{{ .workflow.input.source_ip }}"
  user_agent: "{{ .workflow.input.user_agent }}"
  
tasks:
  - id: audited_operation
    type: basic
    $use: agent(local::agents.#(id="secure_agent"))
    with:
      # Include audit context in all operations
      audit_trail:
        request_id: "{{ .workflow.id }}"
        user_id: "{{ .workflow.input.user_id }}"
        timestamp: "{{ now }}"
        operation: "data_processing"
        compliance_level: "{{ .global.compliance_config.level }}"
```

#### Configuration Context Hierarchies

```yaml
# Hierarchical configuration context
config_hierarchy:
  # System-level defaults
  system_config: "{{ .global.system_config }}"
  
  # Environment-specific overrides
  env_config: "{{ .global.env_configs[.env.ENVIRONMENT] }}"
  
  # Tenant-specific settings
  tenant_config: "{{ .global.tenant_configs[.workflow.input.tenant_id] }}"
  
  # User-specific preferences
  user_config: "{{ .workflow.input.user_preferences }}"
  
  # Final merged configuration
  effective_config: |
    {{- $base := .global.system_config -}}
    {{- $env := .global.env_configs[.env.ENVIRONMENT] -}}
    {{- $tenant := .global.tenant_configs[.workflow.input.tenant_id] -}}
    {{- $user := .workflow.input.user_preferences -}}
    {{- merge $base $env $tenant $user | toJson -}}
```

### Context Performance Optimization

#### Context Caching Patterns

```yaml
# Cache frequently accessed context
tasks:
  - id: cache_context
    type: basic
    $use: tool(local::tools.#(id="context_cache"))
    with:
      cache_key: "user_context_{{ .workflow.input.user_id }}"
      cache_ttl: 300  # 5 minutes
      context_data:
        user_profile: "{{ .tasks.get_user_profile.output }}"
        preferences: "{{ .tasks.get_preferences.output }}"
        permissions: "{{ .tasks.get_permissions.output }}"
        
  - id: use_cached_context
    type: basic
    $use: agent(local::agents.#(id="fast_agent"))
    with:
      # Use cached context for better performance
      cached_context: "{{ .global.context_cache[printf "user_context_%s" .workflow.input.user_id] }}"
      fresh_data: "{{ .workflow.input.data }}"
```

#### Lazy Context Loading

```yaml
# Load context only when needed
tasks:
  - id: conditional_context
    type: router
    condition: "{{ .workflow.input.requires_profile }}"
    routes:
      "true":
        - id: load_full_context
          type: basic
          $use: tool(local::tools.#(id="profile_loader"))
          with:
            user_id: "{{ .workflow.input.user_id }}"
            include_history: true
            include_preferences: true
      "false":
        - id: minimal_context
          type: basic
          $use: tool(local::tools.#(id="minimal_loader"))
          with:
            user_id: "{{ .workflow.input.user_id }}"
            minimal: true
```

### Context Security Patterns

#### Sensitive Data Masking

```yaml
# Mask sensitive data in context
tasks:
  - id: secure_context
    type: basic
    $use: agent(local::agents.#(id="secure_agent"))
    with:
      # Mask sensitive fields
      user_data:
        id: "{{ .workflow.input.user_id }}"
        email: "{{ .workflow.input.email | mask }}"
        phone: "{{ .workflow.input.phone | mask }}"
        # Keep non-sensitive data
        name: "{{ .workflow.input.name }}"
        timezone: "{{ .workflow.input.timezone }}"
      # Sanitize for logging
      log_context: |
        {{- $sanitized := dict "user_id" .workflow.input.user_id "action" "processing" -}}
        {{- $sanitized | toJson -}}
```

#### Context Access Control

```yaml
# Role-based context access
tasks:
  - id: role_based_context
    type: basic
    $use: agent(local::agents.#(id="rbac_agent"))
    with:
      # Context varies by user role
      user_role: "{{ .workflow.input.user_role }}"
      accessible_data: |
        {{- if eq .workflow.input.user_role "admin" -}}
          {{- .global.admin_context | toJson -}}
        {{- else if eq .workflow.input.user_role "manager" -}}
          {{- .global.manager_context | toJson -}}
        {{- else -}}
          {{- .global.user_context | toJson -}}
        {{- end -}}
      permissions: "{{ .global.role_permissions[.workflow.input.user_role] }}"
```

Context variables are the foundation of dynamic Compozy workflows. Understanding how to access and manipulate this data is essential for building dynamic templates.

## Related Documentation

- **[Sprig Functions](./sprig-functions)**: Transform and manipulate context data with powerful functions
- **[Advanced Patterns](./advanced-patterns)**: Complex template techniques using context variables  
- **[Security Functions](./sprig-functions#compozy-specific-security-functions)**: Safely handle user input and untrusted data
- **[Performance Optimization](./sprig-functions#performance-optimization)**: Optimize template performance when working with large contexts
- **[Validation and Debugging](./validation-debugging)**: Troubleshoot template issues and ensure data quality
