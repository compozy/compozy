---
title: "Context Variables"
description: "Accessing workflow data, task outputs, and environment variables in templates"
---

Context variables provide access to data from various sources throughout your Compozy workflows. Understanding the context structure and data access patterns is essential for building dynamic, data-driven configurations.

## Overview

Compozy's template engine automatically provides a hierarchical context structure that gives you access to:

<FeatureCardList cols={3} size="sm">
  <FeatureCard
    title="Workflow Data"
    description="Access input parameters, metadata, and execution state"
    icon="Workflow"
  />
  <FeatureCard
    title="Task Outputs"
    description="Use results from previously executed tasks"
    icon="CheckCircle"
  />
  <FeatureCard
    title="Environment Variables"
    description="System configuration and runtime settings"
    icon="Settings"
  />
  <FeatureCard
    title="Collection Context"
    description="Iteration variables for collection tasks"
    icon="List"
  />
  <FeatureCard
    title="Tool & Agent Data"
    description="Available resources and their execution state"
    icon="Package"
  />
  <FeatureCard
    title="Global Values"
    description="Shared data across workflows and tasks"
    icon="Globe"
  />
</FeatureCardList>

## Default Context Structure

Compozy automatically initializes these context fields, ensuring they're always available in your templates:

```yaml title="Default Context Structure"
context:
  env: {}        # Environment variables map
  input: {}      # Workflow input data
  output: null   # Current task output (null by default)
  trigger: {}    # Workflow trigger context
  tools: {}      # Available tools registry
  tasks: {}      # Task execution results
  agents: {}     # Agent execution state
```

<Callout type="info">
  **Context Preprocessing**: The template engine processes context through default field initialization, global value merging, and template rendering stages.
</Callout>

## Core Context Variables

<Tabs items={["Workflow", "Tasks", "Environment", "Collections", "Tools & Agents"]}>
<Tab>
**Workflow Context** provides access to workflow-level data and metadata:

```yaml title="Workflow Context"
# Workflow input data
user_id: "{{ .workflow.input.user_id }}"
search_query: "{{ .workflow.input.query }}"
preferences: "{{ .workflow.input.user_preferences }}"

# Workflow metadata
workflow_id: "{{ .workflow.id }}"
workflow_version: "{{ .workflow.version }}"
started_at: "{{ .workflow.started_at }}"

# Workflow configuration
timeout: "{{ .workflow.config.timeout }}"
retry_policy: "{{ .workflow.config.retry_policy }}"
```

**Common workflow patterns:**
- Use `.workflow.input` for user-provided data
- Use `.workflow.id` for unique workflow identification
- Use `.workflow.config` for execution parameters
</Tab>

<Tab>
**Task Context** provides access to outputs and state from other tasks:

```yaml title="Task Context"
# Task outputs
weather_data: "{{ .tasks.weather_check.output.temperature }}"
user_profile: "{{ .tasks.get_user.output }}"
validation_result: "{{ .tasks.validate_input.output.is_valid }}"

# Task metadata
task_duration: "{{ .tasks.weather_check.duration }}"
task_status: "{{ .tasks.weather_check.status }}"
task_attempt: "{{ .tasks.weather_check.attempt }}"

# Complex output access
nested_data: "{{ .tasks.api_call.output.data.results.0.name }}"
array_length: "{{ len .tasks.fetch_items.output.items }}"
```

**Task context patterns:**
- Use `.tasks.{task_id}.output` for task results
- Use `.tasks.{task_id}.status` for execution state
- Chain tasks by referencing previous outputs
</Tab>

<Tab>
**Environment Variables** provide access to system and runtime configuration:

```yaml title="Environment Variables"
# Environment variables
api_key: "{{ .env.OPENAI_API_KEY }}"
database_url: "{{ .env.DATABASE_URL }}"
debug_mode: "{{ .env.DEBUG | default 'false' | bool }}"

# Environment with defaults
port: "{{ .env.PORT | default '3000' | int }}"
timeout: "{{ .env.TIMEOUT | default '30' | int }}"
log_level: "{{ .env.LOG_LEVEL | default 'info' | lower }}"

# Environment-based configuration
is_production: "{{ eq .env.NODE_ENV 'production' }}"
base_url: "{{ .env.API_BASE_URL | default 'http://localhost:3000' }}"
```

**Environment best practices:**
- Always provide defaults for optional environment variables
- Use type conversion functions (`int`, `bool`, `float64`)
- Use environment variables for secrets and configuration
</Tab>

<Tab>
**Collection Context** provides special variables for iteration tasks:

```yaml title="Collection Context"
# Collection iteration
- id: process_items
  type: collection
  items: "{{ .workflow.input.data_items }}"
  task:
    id: "process-{{ .index }}"
    type: basic
    with:
      # Current item data
      item_id: "{{ .item.id }}"
      item_name: "{{ .item.name }}"
      item_data: "{{ .item }}"
      
      # Iteration context
      current_index: "{{ .index }}"
      is_first: "{{ eq .index 0 }}"
      is_last: "{{ eq .index (sub (len .items) 1) }}"
      
      # Collection metadata
      total_items: "{{ len .items }}"
      batch_id: "{{ printf '%s_batch_%d' .workflow.id .index }}"
```

**Collection variables:**
- `.item` - Current item being processed
- `.index` - Zero-based index of current item
- `.items` - Full collection being processed
</Tab>

<Tab>
**Tool and Agent Context** provides access to available resources:

```yaml title="Tools & Agents"
# Tool availability
has_weather_tool: "{{ hasKey .tools 'weather_tool' }}"
available_tools: "{{ keys .tools | join ', ' }}"

# Agent information
current_agent: "{{ .agents.current.id }}"
agent_model: "{{ .agents.current.model }}"

# Tool outputs (when used in task context)
tool_result: "{{ .tool.output }}"
tool_error: "{{ .tool.error }}"
```

**Tool and agent patterns:**
- Use `hasKey` to check tool availability
- Use `keys` to list available resources
- Access tool outputs through `.tool.output`
</Tab>
</Tabs>

## Advanced Context Patterns

<Tabs items={["Nested Data", "Conditional Access", "Dynamic Context", "Context Debugging"]}>
<Tab>
**Nested Data Access** enables navigation of complex data structures:

```yaml title="Nested Data Access"
# Deep object access
user_email: "{{ .tasks.get_user.output.profile.contact.email }}"
first_tag: "{{ .tasks.get_metadata.output.tags.0 }}"

# Safe nested access with defaults
city: "{{ .tasks.get_location.output.address.city | default 'Unknown' }}"
phone: "{{ coalesce .user.contact.phone .user.profile.phone 'No phone' }}"

# Array element access
first_result: "{{ index .tasks.search.output.results 0 }}"
last_item: "{{ index .tasks.fetch.output.items (sub (len .tasks.fetch.output.items) 1) }}"
```

**Navigation techniques:**
- Use dot notation for nested objects
- Use `.0` or `index` for array access
- Use `default` for safe fallbacks
- Use `coalesce` for multiple fallback options
</Tab>

<Tab>
**Conditional Context Access** handles optional or conditional data:

```yaml title="Conditional Access"
# Check if data exists before using
user_name: |
  {{- if .tasks.get_user.output -}}
    {{ .tasks.get_user.output.name }}
  {{- else -}}
    Anonymous
  {{- end -}}

# Safe access with error handling
safe_value: "{{ .tasks.risky_operation.output.value | default 'fallback' }}"

# Multiple fallback options
notification_email: |
  {{- coalesce 
      .tasks.get_user.output.notification_email 
      .tasks.get_user.output.primary_email 
      .workflow.input.default_email 
      'noreply@example.com' -}}
```

**Conditional patterns:**
- Use `if` statements for existence checks
- Use `default` for single fallbacks
- Use `coalesce` for multiple fallback options
- Use `hasKey` to check for map keys
</Tab>

<Tab>
**Dynamic Context Building** creates custom context objects:

```yaml title="Dynamic Context"
# Create custom context objects
user_context:
  id: "{{ .workflow.input.user_id }}"
  profile: "{{ .tasks.get_user.output }}"
  preferences: "{{ .tasks.get_preferences.output }}"
  session_id: "{{ .workflow.id }}"
  timestamp: "{{ now | date '2006-01-02T15:04:05Z' }}"

# Merge multiple contexts
combined_data: |
  {{- $base := .tasks.base_data.output -}}
  {{- $extra := .tasks.extra_data.output -}}
  {{- merge $base $extra | toJson -}}
```

**Context building techniques:**
- Create structured context objects
- Use variables with `$` prefix
- Use `merge` to combine contexts
- Use `toJson` for serialization
</Tab>

<Tab>
**Context Debugging** helps troubleshoot context issues:

```yaml title="Context Debugging"
# Debug: Print entire context
debug_context: "{{ . | toPrettyJson }}"

# Debug: Print specific sections
debug_workflow: "{{ .workflow | toPrettyJson }}"
debug_tasks: "{{ .tasks | toPrettyJson }}"
debug_env: "{{ .env | toPrettyJson }}"

# Debug: List available keys
available_tasks: "{{ keys .tasks | join ', ' }}"
available_env: "{{ keys .env | join ', ' }}"
```

**Debugging techniques:**
- Use `toPrettyJson` to inspect context
- Use `keys` to list available fields
- Use `join` to format lists
- Use validation checks for required data
</Tab>
</Tabs>

## Context in Task Types

<Tabs items={["Basic Tasks", "Composite Tasks", "Parallel Tasks", "Router Tasks"]}>
<Tab>
**Basic Tasks** use context for simple operations:

```yaml title="Basic Task Context"
- id: api_request
  type: basic
  $use: tool(local::tools.#(id=="http_client"))
  with:
    # Workflow input
    url: "{{ .workflow.input.api_endpoint }}"
    
    # Environment configuration
    api_key: "{{ .env.API_KEY }}"
    
    # Previous task output
    user_id: "{{ .tasks.authenticate.output.user_id }}"
    
    # Dynamic headers
    headers:
      Authorization: "Bearer {{ .tasks.authenticate.output.token }}"
      Content-Type: "application/json"
      X-Request-ID: "{{ .workflow.id }}"
```
</Tab>

<Tab>
**Composite Tasks** chain context across multiple sub-tasks:

```yaml title="Composite Task Context"
- id: user_onboarding
  type: composite
  tasks:
    - id: create_account
      type: basic
      with:
        email: "{{ .workflow.input.email }}"
        name: "{{ .workflow.input.name }}"
        
    - id: setup_profile
      type: basic
      with:
        user_id: "{{ .tasks.create_account.output.user_id }}"
        preferences: "{{ .workflow.input.preferences }}"
        
    - id: send_welcome
      type: basic
      with:
        recipient: "{{ .tasks.create_account.output.email }}"
        user_name: "{{ .tasks.create_account.output.name }}"
        profile_url: "{{ printf '%s/profile/%s' .env.BASE_URL .tasks.create_account.output.user_id }}"
```
</Tab>

<Tab>
**Parallel Tasks** distribute context across concurrent operations:

```yaml title="Parallel Task Context"
- id: parallel_processing
  type: parallel
  strategy: wait_all
  tasks:
    - id: process_images
      type: basic
      with:
        images: "{{ .workflow.input.images }}"
        quality: "{{ .workflow.input.quality | default 'medium' }}"
        
    - id: process_videos
      type: basic
      with:
        videos: "{{ .workflow.input.videos }}"
        resolution: "{{ .workflow.input.resolution | default '720p' }}"
        
    - id: process_documents
      type: basic
      with:
        documents: "{{ .workflow.input.documents }}"
        format: "{{ .workflow.input.output_format | default 'pdf' }}"
```
</Tab>

<Tab>
**Router Tasks** use context for conditional logic:

```yaml title="Router Task Context"
- id: routing_logic
  type: router
  condition: |
    {{- $user_type := .tasks.classify_user.output.type -}}
    {{- $priority := .tasks.classify_user.output.priority -}}
    {{- if and (eq $user_type "premium") (gt $priority 8) -}}
      premium_fast
    {{- else if eq $user_type "premium" -}}
      premium_standard
    {{- else -}}
      standard
    {{- end -}}
  routes:
    premium_fast:
      - id: fast_processing
        with:
          user_data: "{{ .tasks.classify_user.output }}"
          priority: 10
    premium_standard:
      - id: standard_processing
        with:
          user_data: "{{ .tasks.classify_user.output }}"
          priority: 5
    standard:
      - id: basic_processing
        with:
          user_data: "{{ .tasks.classify_user.output }}"
          priority: 1
```
</Tab>
</Tabs>

## Best Practices

<Steps>
  <Step title="Use Meaningful Variable Names">
    Always use descriptive names that clearly indicate what data you're accessing:
    
    ```yaml
    # ✅ Good - descriptive access
    user_email: "{{ .tasks.get_user_profile.output.email }}"
    auth_token: "{{ .tasks.authenticate_user.output.access_token }}"
    
    # ❌ Avoid - unclear references
    data: "{{ .tasks.task1.output.data }}"
    result: "{{ .tasks.step2.output }}"
    ```
  </Step>
  
  <Step title="Provide Fallback Values">
    Always provide sensible defaults to prevent template errors:
    
    ```yaml
    # Always provide sensible defaults
    timeout: "{{ .workflow.config.timeout | default 30 }}"
    retries: "{{ .env.MAX_RETRIES | default 3 | int }}"
    user_name: "{{ .tasks.get_user.output.name | default 'Guest' }}"
    ```
  </Step>
  
  <Step title="Validate Context Before Use">
    Check data existence before accessing nested structures:
    
    ```yaml
    # Check existence before accessing nested data
    safe_access: |
      {{- if and .tasks.api_call.output (hasKey .tasks.api_call.output "data") -}}
        {{ .tasks.api_call.output.data.result }}
      {{- else -}}
        null
      {{- end -}}
    ```
  </Step>
  
  <Step title="Use Type-Appropriate Conversions">
    Convert data types as needed for proper processing:
    
    ```yaml
    # Convert types as needed
    port_number: "{{ .env.PORT | default '3000' | int }}"
    debug_flag: "{{ .env.DEBUG | default 'false' | bool }}"
    timeout_float: "{{ .config.timeout | default '30.5' | float64 }}"
    ```
  </Step>
  
  <Step title="Document Complex Context Usage">
    Add comments to explain complex context access patterns:
    
    ```yaml
    # Document complex context access patterns
    user_notification_config:
      # User's preferred notification method from profile
      method: "{{ .tasks.get_user_profile.output.notifications.method | default 'email' }}"
      
      # Fallback to workflow input if profile incomplete
      email: "{{ coalesce .tasks.get_user_profile.output.email .workflow.input.email }}"
      
      # Environment-based configuration
      service_url: "{{ .env.NOTIFICATION_SERVICE_URL }}"
      
      # Dynamic content based on user type
      template: |
        {{- if eq .tasks.get_user_profile.output.type "premium" -}}
          premium_notification
        {{- else -}}
          standard_notification
        {{- end -}}
    ```
  </Step>
</Steps>

## Integration Patterns

<Tabs items={["MCP Integration", "Memory Integration", "Multi-Agent Context", "Enterprise Patterns"]}>
<Tab>
**MCP (Model Context Protocol)** servers provide external context integration:

```yaml title="MCP Context Integration"
# MCP context variables
agents:
  - id: file_agent
    config:
      $ref: global::models.#(provider=="groq")
    mcps:
      - id: file_server
        transport: stdio
        command: docker mcp gateway run
        proto: "2025-03-26"
        start_timeout: 15s
    actions:
      - id: list_files
        prompt: |
          Use MCP tools to list files in {{ .workflow.input.directory }}.
          Current context: {{ .workflow | toJson }}
          Available tools: {{ keys .tools | join ", " }}
```

**MCP context patterns:**
- Use MCP servers for external tool integration
- Access MCP context through `.workflow` and `.tools`
- Configure MCP transports and protocols
</Tab>

<Tab>
**Memory Integration** provides persistent context across workflow executions:

```yaml title="Memory Context Integration"
# Memory-backed context
agents:
  - id: personalized_agent
    config:
      $ref: global::models.#(provider=="groq")
    memory:
      - id: user_memory
        key: "user:{{.workflow.input.user_id}}"
        mode: read-write
    instructions: |
      You are a personalized assistant for user {{.workflow.input.user_id}}.
      Use your memory to provide contextual responses.
      Current session: {{.workflow.id}}
      User preferences: {{.workflow.input.preferences | default "none"}}
```

**Memory context patterns:**
- Use memory for persistent user context
- Key memory with user or session identifiers
- Configure read-write or read-only memory access
</Tab>

<Tab>
**Multi-Agent Context** enables sharing context between multiple agents:

```yaml title="Multi-Agent Context Sharing"
# Shared context across agents
tasks:
  - id: analyze_data
    type: basic
    $use: agent(local::agents.#(id="analyzer"))
    with:
      data: "{{ .workflow.input.data }}"
      context: "{{ .workflow.input.context }}"
    outputs:
      analysis: "{{ .output.analysis }}"
      confidence: "{{ .output.confidence }}"
      
  - id: generate_report
    type: basic
    $use: agent(local::agents.#(id="reporter"))
    with:
      # Share context from previous task
      analysis: "{{ .tasks.analyze_data.output.analysis }}"
      confidence: "{{ .tasks.analyze_data.output.confidence }}"
      # Add global context
      report_template: "{{ .global.report_template }}"
      user_preferences: "{{ .workflow.input.preferences }}"
```

**Multi-agent patterns:**
- Pass context between agents via task outputs
- Use global context for shared configuration
- Structure context for different agent specializations
</Tab>

<Tab>
**Enterprise Patterns** handle complex organizational context:

```yaml title="Enterprise Context Patterns"
# Multi-tenant context management
context_patterns:
  tenant_context:
    tenant_id: "{{ .workflow.input.tenant_id }}"
    tenant_config: "{{ .global.tenant_configs[.workflow.input.tenant_id] }}"
    user_context: "{{ .workflow.input.user_context }}"
    
tasks:
  - id: tenant_aware_processing
    type: basic
    $use: agent(local::agents.#(id="tenant_agent"))
    with:
      tenant_id: "{{ .workflow.input.tenant_id }}"
      tenant_config: "{{ .global.tenant_configs[.workflow.input.tenant_id] }}"
      user_permissions: "{{ .global.user_permissions[.workflow.input.user_id] }}"
      data_isolation: "{{ .global.data_isolation[.workflow.input.tenant_id] }}"
```

**Enterprise context features:**
- Multi-tenant context isolation
- Hierarchical configuration management
- Audit and compliance context tracking
- Role-based context access control
</Tab>
</Tabs>

## References

<ReferenceCardList>
  <ReferenceCard
    title="Sprig Functions"
    description="Transform and manipulate context data with powerful template functions"
    href="/docs/core/yaml-templates/sprig-functions"
    icon="Zap"
  />
  <ReferenceCard
    title="Advanced Patterns"
    description="Complex template techniques using context variables and advanced logic"
    href="/docs/core/yaml-templates/advanced-patterns"
    icon="Code"
  />
  <ReferenceCard
    title="Validation & Debugging"
    description="Troubleshoot template issues and ensure data quality"
    href="/docs/core/yaml-templates/validation-debugging"
    icon="Bug"
  />
  <ReferenceCard
    title="Basic Tasks"
    description="Learn how context variables work in basic task execution"
    href="/docs/core/tasks/basic-tasks"
    icon="Play"
  />
</ReferenceCardList>

Context variables are the foundation of dynamic Compozy workflows. Understanding how to access and manipulate this data is essential for building powerful, data-driven templates.
