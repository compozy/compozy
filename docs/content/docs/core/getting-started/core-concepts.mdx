---
title: Core Concepts
description: Understanding Compozy's fundamental concepts and architecture
---

## Overview

Compozy is built on a straightforward philosophy: **focus on describing your goals, not the implementation details**. By defining your workflows, agents, and tools in easy-to-read YAML configuration files, you let Compozy take care of execution, coordination, and state management behind the scenes.

This is made possible by several core components:

<List>
  <ListItem title="Workflows" icon="Workflow">
    Define a sequence of tasks to accomplish a goal
  </ListItem>
  <ListItem title="Tasks" icon="CheckSquare">
    The building blocks of workflows
  </ListItem>
  <ListItem title="Agents" icon="Bot">
    AI-powered components that can understand natural language instructions and execute actions
  </ListItem>
  <ListItem title="Tools" icon="Wrench">
    TypeScript/JavaScript functions that perform specific operations like API calls, data processing, or file operations
  </ListItem>
  <ListItem title= "Memory" icon="Database">
    Persistent memory systems that can store and retrieve data across workflow executions
  </ListItem>
  <ListItem title="Signals" icon="Signal">
    Communication channels between workflows and agents
  </ListItem>
  <ListItem title="MCP" icon="Link2">
    Model Context Protocol integration for external tooling
  </ListItem>
</List>

## Workflows

**Workflows** are the top-level orchestration units that define a sequence of tasks to accomplish a goal. [Learn more about workflow configuration →](/docs/core/configuration/workflows)

```yaml title="customer-support.yaml"
id: customer-support
version: 0.1.0
description: Handle customer inquiries with AI agents

config:
  input:
    type: object
    properties:
      customer_message:
        type: string
      customer_id:
        type: string

tasks:
  - id: classify_intent
    type: basic
    # ... task definition

  - id: generate_response
    type: basic
    # ... task definition
```

**Key characteristics:**

<List>
  <ListItem title="Declarative" icon="FileText">
    Describe the desired outcome, not implementation details
  </ListItem>
  <ListItem title="Stateful" icon="Database">
    Compozy tracks execution state and handles failures
  </ListItem>
  <ListItem title="Composable" icon="Package">
    Workflows can call other workflows or be called by external systems
  </ListItem>
  <ListItem title="Observable" icon="Eye">
    Built-in monitoring, logging, and debugging capabilities
  </ListItem>
</List>

## Tasks

**Tasks** are the building blocks of workflows. Each task represents a single unit of work. [Explore all task types →](/docs/core/tasks/basic-tasks)

<Tabs items={["Basic", "Composite", "Parallel", "Collection", "Router", "Memory", "Signal"]}>
<Tab>
Execute a single tool or agent action

```yaml title="Basic Task"
- id: fetch_data
  type: basic
  tool: api_client
  with:
    endpoint: "/users/{{ .workflow.input.user_id }}"
```
</Tab>

<Tab>
Group multiple sub-tasks with shared strategy

```yaml title="Composite Task"
- id: data_processing
  type: composite
  strategy: fail_fast  # or best_effort
  tasks:
    - id: validate_data
      type: basic
      # ... validation task
    - id: transform_data
      type: basic
      # ... transformation task
```
</Tab>

<Tab>
Execute multiple tasks concurrently

```yaml title="Parallel Task"
- id: gather_info
  type: parallel
  strategy: wait_all  # or race
  tasks:
    - id: get_weather
      type: basic
      # ... weather task
    - id: get_traffic
      type: basic
      # ... traffic task
```

[Learn more about parallel processing →](/docs/core/tasks/parallel-processing)
</Tab>

<Tab>
Process arrays of data

```yaml title="Collection Task"
- id: process_emails
  type: collection
  items: "{{ .workflow.input.emails }}"
  mode: parallel  # or sequential
  task:
    id: "process-email-{{ .index }}"
    type: basic
    agent: email_processor
    with:
      email: "{{ .item }}"
```

[Learn more about collection tasks →](/docs/core/tasks/collection-tasks)
</Tab>

<Tab>
Conditional branching based on data

```yaml title="Router Task"
- id: route_by_priority
  type: router
  condition: 'tasks.classify.output.priority'
  routes:
    high:
      id: urgent_handler
      type: basic
      tool: incident_notifier
      with:
        priority: high
        payload: "{{ .tasks.classify.output }}"
    low:
      id: standard_handler
      type: basic
      tool: task_logger
      with:
        level: info
        payload: "{{ .tasks.classify.output }}"
```
</Tab>

<Tab>
Interact with persistent memory systems

```yaml title="Memory Task"
- id: remember_conversation
  type: memory
  operation: append
  key: "conversation:{{ .workflow.input.user_id }}"
  content: "{{ .tasks.generate_response.output }}"
```

[Learn more about memory tasks →](/docs/core/tasks/memory-tasks)
</Tab>

<Tab>
Send or wait for cross-workflow communication

```yaml title="Signal Task"
- id: notify_completion
  type: signal
  signal:
    id: workflow-completed
    payload:
      workflow_id: "{{ .workflow.id }}"
      result: "{{ .tasks.final_step.output }}"
```
</Tab>
</Tabs>

**Key characteristics:**

<List>
  <ListItem title="Atomic operations" icon="Atom">
    Each task represents a single, indivisible unit of work
  </ListItem>
  <ListItem title="State management" icon="Activity">
    Automatic tracking of task execution state and outputs
  </ListItem>
  <ListItem title="Error handling" icon="Shield">
    Built-in retry policies and failure recovery mechanisms
  </ListItem>
  <ListItem title="Data flow" icon="ArrowRightLeft">
    Seamless output passing between tasks using template expressions
  </ListItem>
  <ListItem title="Flexible execution" icon="Layers">
    Support for sequential, parallel, conditional, and collection-based patterns
  </ListItem>
</List>

## Agents

**Agents** are AI-powered components that can understand natural language instructions and execute actions. [Learn more about agents →](/docs/core/agents/overview)

```yaml title="customer_service_agent.yaml"
resource: agent
id: customer_service_agent
version: 0.1.0

config:
  provider: groq
  model: llama-3.3-70b-versatile
  api_key: "{{ .env.GROQ_API_KEY }}"

instructions: |
  You are a helpful customer service agent. Your role is to:
  - Understand customer inquiries and classify their intent
  - Provide accurate, helpful responses
  - Escalate complex issues when necessary
  Always maintain a professional, friendly tone.

tools:
  - knowledge_base
  - ticket_system

actions:
  - id: classify_intent
    prompt: |
      Analyze this customer message: "{{ .input.message }}"
      Classify the intent as: question, complaint, request, or compliment.
    output:
      type: object
      properties:
        intent:
          type: string
          enum: [question, complaint, request, compliment]
        confidence:
          type: number
        reasoning:
          type: string

  - id: generate_response
    prompt: |
      Based on the customer's message and intent:
      Message: {{ .input.message }}
      Intent: {{ .input.intent }}

      Generate an appropriate response that addresses their needs.
    output:
      type: object
      properties:
        response:
          type: string
          description: Final reply sent to the customer
        escalation_required:
          type: boolean
          description: Flag set when human follow-up is suggested
      required:
        - response
```

**Key features:**

<List>
  <ListItem title="Multi-model support" icon="Cpu">
    OpenAI, Groq, Ollama, and more. [See all providers →](/docs/core/configuration/providers)
  </ListItem>
  <ListItem title="Tool integration" icon="Zap">
    Agents can call external tools and APIs
  </ListItem>
  <ListItem title="Structured outputs" icon="Target">
    Define JSON schemas for reliable data extraction. [Learn more →](/docs/core/agents/structured-outputs)
  </ListItem>
  <ListItem title="Context awareness" icon="BrainCircuit">
    Access workflow data and previous task outputs
  </ListItem>
  <ListItem title="Memory integration" icon="Database">
    Persistent conversation and context memory
  </ListItem>
</List>

## Tools

**Tools** are TypeScript/JavaScript functions that perform specific operations like API calls, data processing, or file operations. [Learn more about tool development →](/docs/core/tools/overview)

```typescript title="weather_tool.ts"
interface WeatherInput {
  location: string;
  units?: "metric" | "imperial";
}

interface WeatherOutput {
  temperature: number;
  description: string;
  humidity: number;
  location: string;
  success: boolean;
}

export async function weatherTool({ input }: { input: WeatherInput }): Promise<WeatherOutput> {
  const { location, units = "metric" } = input;

  try {
    // Use OpenWeatherMap API (requires API key in environment)
    const apiKey = process.env.OPENWEATHER_API_KEY;
    if (!apiKey) {
      throw new Error("OpenWeatherMap API key not found in environment");
    }

    const response = await fetch(
      `https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(location)}&appid=${apiKey}&units=${units}`
    );

    if (!response.ok) {
      throw new Error(`Weather API request failed: ${response.status}`);
    }

    const data = await response.json();

    return {
      temperature: Math.round(data.main.temp),
      description: data.weather[0].description,
      humidity: data.main.humidity,
      location: data.name,
      success: true,
    };
  } catch (error: any) {
    throw new Error(`Weather lookup failed: ${error.message}`);
  }
}
```

**What this tool does:** The weather tool demonstrates how to create a TypeScript tool that makes external API calls. It fetches current weather data for a given location using the OpenWeatherMap API, handles errors gracefully, and returns structured data that agents can use.

**Tool configuration:**
```yaml title="Tool Configuration"
tools:
  - id: weather_tool
    description: Fetches current weather data for a given location
    input:
      type: object
      properties:
        location:
          type: string
          description: City name or location to get weather for
        units:
          type: string
          enum: ["metric", "imperial"]
          description: Temperature units (metric or imperial)
          default: metric
      required:
        - location
```

**Key characteristics:**

<List>
  <ListItem title="TypeScript/JavaScript execution" icon="Code">
    Run in secure Bun runtime with configurable permissions. [Learn more →](/docs/core/tools/runtime-environment)
  </ListItem>
  <ListItem title="JSON I/O communication" icon="ArrowRightLeft">
    Standardized input/output protocol for reliable data exchange
  </ListItem>
  <ListItem title="External API integration" icon="Globe">
    Connect to databases, web services, and third-party systems
  </ListItem>
  <ListItem title="Schema validation" icon="CheckCircle">
    Define input/output schemas for type safety and validation
  </ListItem>
  <ListItem title="Sandboxed execution" icon="Lock">
    Isolated runtime environment with controlled access to system resources
  </ListItem>
</List>

## Memory Systems

**Memory** enables persistent context and conversation history across workflow executions. [Learn more about memory systems →](/docs/core/memory/overview)

```yaml title="memory-config.yaml"
# Configure memory in your project
memory:
  provider: redis
  config:
    url: "{{ .env.REDIS_URL }}"
  strategies:
    conversation:
      type: token_lru
      max_tokens: 4000
      eviction_policy: lru
    facts:
      type: fifo
      max_entries: 100
```

**Using memory in workflows:**

<Tabs items={["Memory Tasks", "Agent Integration", "HTTP API"]}>
<Tab>
Dedicated memory tasks for explicit memory operations

```yaml title="Memory Tasks"
tasks:
  - id: recall_context
    type: memory # [!code highlight]
    operation: read # [!code highlight]
    key: "user:{{ .workflow.input.user_id }}:context" # [!code highlight]
    on_success:
      next: process_with_context

  - id: process_with_context
    type: basic
    agent: assistant
    action: respond
    with:
      message: "{{ .workflow.input.message }}"
      context: "{{ .tasks.recall_context.output }}"
    on_success:
      next: update_memory

  - id: update_memory
    final: true
    type: memory # [!code highlight]
    operation: append # [!code highlight]
    key: "user:{{ .workflow.input.user_id }}:context" # [!code highlight]
    content: |
      Human: {{ .workflow.input.message }}
      Assistant: {{ .tasks.process_with_context.output }}
```
</Tab>

<Tab>
Agents with built-in memory integration for automatic context management

```yaml title="Agent with Memory"
agents:
  - id: memory_agent
    model: groq-llama-3.3-70b
    instructions: |
      You are a helpful assistant with persistent memory.
      Use conversation history to provide contextual responses.
    memory: # [!code highlight]
      id: conversation-memory # [!code highlight]
      key: "user:{{ .workflow.input.user_id }}:conversation" # [!code highlight]
    actions:
      - id: chat_with_memory
        prompt: |
          Respond to: {{ .workflow.input.message }}
          Consider previous conversation context.

tasks:
  - id: conversational_response
    type: basic
    agent: memory_agent
    action: chat_with_memory
    with:
      message: "{{ .workflow.input.message }}"
```
</Tab>

<Tab>
HTTP API calls for external memory management integration

```http title="memory-operations.http"
@baseUrl = http://localhost:5001/api/v0
@memoryRef = user_memory
@userId = user123
@memoryKey = user:{{userId}}:conversation

### Read memory content
GET {{baseUrl}}/memory/{{memoryRef}}/read?key={{memoryKey}}
Accept: application/json

### Write new memory content
POST {{baseUrl}}/memory/{{memoryRef}}/write
Content-Type: application/json

{
  "key": "{{memoryKey}}",
  "messages": [
    {
      "role": "user",
      "content": "Hello, I need help with my account."
    },
    {
      "role": "assistant",
      "content": "I can help you with your account. What do you need?"
    }
  ]
}

### Append to existing memory
POST {{baseUrl}}/memory/{{memoryRef}}/append
Content-Type: application/json

{
  "key": "{{memoryKey}}",
  "messages": [
    {
      "role": "user",
      "content": "What's my current balance?"
    },
    {
      "role": "assistant",
      "content": "Let me check your current account balance for you."
    }
  ]
}

### Clear memory content
POST {{baseUrl}}/memory/{{memoryRef}}/clear
Content-Type: application/json

{
  "key": "{{memoryKey}}",
  "confirm": true,
  "backup": true
}

### Get memory statistics
GET {{baseUrl}}/memory/{{memoryRef}}/stats?key={{memoryKey}}
Accept: application/json

### Get memory health
GET {{baseUrl}}/memory/{{memoryRef}}/health?key={{memoryKey}}
Accept: application/json
```
</Tab>
</Tabs>

**Key characteristics:**

<List>
  <ListItem title="Persistent storage" icon="HardDrive">
    Context and conversation history survives across workflow executions with Redis
  </ListItem>
  <ListItem title="Flexible strategies" icon="Settings">
    Token-based LRU, FIFO, and custom eviction policies
  </ListItem>
  <ListItem title="Hierarchical keys" icon="Key">
    Organize memory with user-specific, session-based, or global scopes
  </ListItem>
  <ListItem title="Seamless integration" icon="Workflow">
    Access memory through simple read, write, append, and delete operations
  </ListItem>
</List>

## Signals

**Signals** enable event-driven communication between workflows and agents through lightweight messages. They provide a publish-subscribe mechanism for asynchronous coordination and decoupled architectures. [Learn more about signals →](/docs/core/signals/overview)

```yaml title="signal-workflow.yaml"
# Emitting a signal in a workflow
tasks:
  - id: process_order
    type: basic
    agent: order_processor
    with:
      order: "{{ .workflow.input.order }}"
    on_success:
      next: notify_completion

  - id: notify_completion
    type: signal
    signal:
      id: order-processed
      payload:
        order_id: "{{ .workflow.input.order.id }}"
        status: "completed"
        timestamp: "{{ now }}"

# Receiving signals in another workflow
  - id: wait_for_order
    type: wait
    wait_for: "order-processed"
    timeout: 300s
    condition: 'signal.payload.status == "completed"'
    on_success:
      next: send_notification
```

**Common use cases:**

<List>
  <ListItem title="Workflow Coordination" icon="GitBranch">
    Synchronize execution between multiple workflows
  </ListItem>
  <ListItem title="Event-Driven Processing" icon="Activity">
    Trigger actions based on business events or external signals
  </ListItem>
  <ListItem title="Human Approval Flows" icon="Users">
    Pause workflows until manual approval or input is received
  </ListItem>
  <ListItem title="Service Integration" icon="Link">
    Enable communication between different services and systems
  </ListItem>
</List>

## MCP (Model Context Protocol)

**MCP** enables AI agents to connect with external tools and services through a standardized protocol. It acts as a universal adapter between agents and external capabilities, providing dynamic tool discovery and seamless integration. [Learn more about MCP integration →](/docs/core/mcp/overview)

```yaml title="mcp-integration.yaml"
# Configure MCP servers in your project
mcps:
  - id: filesystem
    transport: stdio
    command: "mcp-server-filesystem"
    args: ["--root", "/workspace"]

  - id: github
    transport: http
    endpoint: "http://localhost:3000/mcp"
    headers:
      Authorization: "Bearer {{ .env.GITHUB_TOKEN }}"

# Use MCP tools in agents
agents:
  - id: developer_agent
    config:
      provider: groq
      model: llama-3.3-70b-versatile
    instructions: |
      You are a developer assistant with access to filesystem and GitHub tools.
      Use the available MCP tools to read files, make changes, and interact with repositories.

    # MCP tools are automatically discovered and available
    actions:
      - id: analyze_codebase
        prompt: |
          Analyze the project structure in /workspace and provide insights.
          Use filesystem tools to explore the codebase.
```

**Integration with Compozy components:**

<List>
  <ListItem title="Automatic Tool Discovery" icon="Search">
    MCP servers expose tools that agents can use immediately without manual registration
  </ListItem>
  <ListItem title="Multiple Transport Types" icon="Network">
    Support for stdio (local processes), HTTP, and Server-Sent Events (SSE)
  </ListItem>
  <ListItem title="Central Proxy Architecture" icon="Server">
    MCP Proxy (port 6001) manages all connections and provides unified access
  </ListItem>
  <ListItem title="Security & Isolation" icon="Shield">
    Built-in token authentication and environment isolation for safe tool execution
  </ListItem>
</List>

## Template Engine

Our powerful **template engine** enable modular, reusable configurations using a powerful query syntax. [Learn more about YAML templates →](/docs/core/yaml-templates/overview)

### Reference Types

<Tabs items={["Local References", "Global References", "Resource References"]}>
<Tab>
References within the same YAML file using local scope

```yaml title="Local References"
# Reference tools defined in the same file
weather_tool

# Reference agents in the current workflow
assistant

# Reference schemas for validation
user_input

# Reference tasks for routing
save_results
```
</Tab>

<Tab>
Project-level references that span across the entire project

```yaml title="Global References"
# Reference models by ID (defined in compozy.yaml)
model: groq-llama-3.3-70b

# Reference global configuration values via template variables
runtime: "{{ .project.runtime }}"

# Access project-wide settings using IDs and template variables
build:
  toolchain: bun
```
</Tab>

<Tab>
External file references for modular configurations

```yaml title="Resource References"
# Reference agents from external files
specialist

# Reference tools from tool files
data_processor

# Reference workflows from other files
preprocessing
```
</Tab>
</Tabs>

### Template Expressions

**[Sprig template engine](https://github.com/Masterminds/sprig)** with custom functions for dynamic values. [See all template functions →](/docs/core/yaml-templates/sprig-functions)

```yaml title="Template Expressions"
# Access workflow input
with:
  message: "{{ .workflow.input.message }}"

# Access previous task outputs
condition: 'tasks.classify.output.category'

# Transform data
formatted_data: "{{ .tasks.process.output | toJson }}"

# Conditional logic
status: |
  {{ if eq .tasks.validate.output.valid true }}
  approved
  {{ else }}
  rejected
  {{ end }}

# Current timestamp
timestamp: "{{ now }}"

# Array operations
count: "{{ len .tasks.collection.output }}"
first_item: "{{ index .tasks.collection.output 0 }}"

# Collection item access
item_value: "{{ .item }}"
item_index: "{{ .index }}"
```

## State Management

State management in workflows allows you to pass data between tasks seamlessly. Each task's outputs are automatically made available to subsequent tasks, enabling dynamic and context-aware processing. You can reference previous task outputs using template expressions, making it easy to build complex, data-driven workflows without manual data passing. [Learn more about context variables →](/docs/core/yaml-templates/context-variables)

```yaml title="State Management"
# Task outputs are automatically available to subsequent tasks
tasks:
  - id: step1
    type: basic
    outputs:
      result: "{{ .output.data }}"
      metadata:
        processed_at: "{{ now }}"

  - id: step2
    type: basic
    with:
      # Access step1's outputs
      previous_result: "{{ .tasks.step1.output.result }}" # [!code highlight]
      timestamp: "{{ .tasks.step1.output.metadata.processed_at }}" # [!code highlight]
```

## Error Handling

Handle errors in workflows using `retry`, `on_error`, and `on_success` to control what happens when tasks fail or succeed. This makes your workflows more reliable.

```yaml title="Error Handling" {5-9}
tasks:
  - id: risky_operation
    type: basic
    agent: sophisticated_agent
    retry: # [!code highlight]
      max_attempts: 3 # [!code highlight]
      backoff: exponential # [!code highlight]
    on_error: # [!code highlight]
      next: handle_error # [!code highlight]
    on_success:
      next: continue_workflow

  - id: handle_error
    type: basic
    tool: error_handler
    with:
      error: "{{ .tasks.risky_operation.error }}" # [!code highlight]
```

## Best Practices

<Steps numbered>
  <Step
    title="Design Principles"
    description="Foundation principles for building maintainable workflows"
  >
    - **Single Responsibility**: Each task should have one clear purpose
    - **Idempotency**: Tasks should produce the same result when re-run
    - **Loose Coupling**: Minimize dependencies between components
    - **Observable**: Include logging and monitoring in your workflows
  </Step>

  <Step
    title="Configuration Organization"
    description="Structure your YAML configurations for maintainability"
  >
    ```yaml title="Configuration Organization"
    # Use schemas for input validation
    schemas:
      - id: user_request
        type: object
        properties:
          message: { type: string }
          priority: { type: string, enum: [low, medium, high] }
        required: [message]

    config:
      input:
        user_request
    ```
  </Step>

  <Step
    title="Error Handling Strategy"
    description="Implement robust error handling and recovery patterns"
  >
    ```yaml title="Error Handling Strategy"
    # Define error handling at the workflow level
    error_handling:
      default_retry:
        max_attempts: 3
        backoff: exponential
      critical_tasks:
        - validate_input
        - save_results
    ```
  </Step>

  <Step
    title="Security Considerations"
    description="Apply minimal permissions and secure runtime configuration"
  >
    ```yaml title="Security Considerations"
    # Minimal runtime permissions
    runtime:
      permissions:
        - --allow-read=./data  # Only specific directories
        - --allow-net=api.example.com  # Only specific hosts
        - --allow-env=API_KEY,DB_URL  # Only required env vars
    ```
  </Step>
</Steps>

## Next Steps

Choose your learning path based on your needs:

### Quick Start

<ReferenceCardList>
  <ReferenceCard
    title="First Workflow Tutorial"
    description="Build your first complete workflow step-by-step with guided examples"
    href="/docs/core/getting-started/first-workflow"
    icon="Rocket"
  />
  <ReferenceCard
    title="Quick Start Guide"
    description="Get up and running in 15 minutes with a working weather advisory system"
    href="/docs/core/getting-started/quick-start"
    icon="Zap"
  />
  <ReferenceCard
    title="Project Configuration"
    description="Learn how to configure projects, models, and runtime settings"
    href="/docs/core/configuration/project-setup"
    icon="Settings"
  />
  <ReferenceCard
    title="Basic Tasks"
    description="Master the fundamental building blocks of all workflows"
    href="/docs/core/tasks/basic-tasks"
    icon="Package"
  />
</ReferenceCardList>

### Agent Development

<ReferenceCardList>
  <ReferenceCard
    title="Agent Overview"
    description="Master AI agents with structured outputs, tools, and memory integration"
    href="/docs/core/agents/overview"
    icon="BrainCircuit"
  />
  <ReferenceCard
    title="Agent Configuration"
    description="Define agent behavior with instructions, actions, and tool integration"
    href="/docs/core/agents/instructions-actions"
    icon="Users"
  />
  <ReferenceCard
    title="Agent Memory"
    description="Persistent conversation and context memory for intelligent agents"
    href="/docs/core/agents/memory"
    icon="Database"
  />
</ReferenceCardList>

### Advanced Implementation

<ReferenceCardList>
  <ReferenceCard
    title="Task Types Reference"
    description="Deep dive into parallel, collection, router, and composite task patterns"
    href="/docs/core/tasks/basic-tasks"
    icon="Layers"
  />
  <ReferenceCard
    title="Tool Development"
    description="Create custom TypeScript tools for specialized operations and integrations"
    href="/docs/core/tools/overview"
    icon="Code"
  />
  <ReferenceCard
    title="MCP Integration"
    description="Connect external tools and services using Model Context Protocol"
    href="/docs/core/mcp/overview"
    icon="Link2"
  />
  <ReferenceCard
    title="Memory Systems"
    description="Implement persistent, stateful memory across workflow executions"
    href="/docs/core/memory/overview"
    icon="HardDrive"
  />
</ReferenceCardList>

### Complete Reference

<ReferenceCardList>
  <ReferenceCard
    title="YAML Templates"
    description="Dynamic configuration with template expressions and functions"
    href="/docs/core/yaml-templates/overview"
    icon="FileCode"
  />
  <ReferenceCard
    title="CLI Commands"
    description="Command-line interface reference and usage patterns"
    href="/docs/core/configuration/cli"
    icon="Terminal"
  />
</ReferenceCardList>

The power of Compozy lies in combining these concepts to create sophisticated AI-powered workflows that are both maintainable and scalable.
