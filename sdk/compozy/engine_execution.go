// Code generated by compozygen. DO NOT EDIT.
package compozy

import (
	"context"
	"fmt"
	core "github.com/compozy/compozy/engine/core"
	client "github.com/compozy/compozy/sdk/v2/client"
	"strconv"
	"strings"
	"time"
)

// ExecuteWorkflow triggers asynchronous workflow execution via the client.
func (e *Engine) ExecuteWorkflow(ctx context.Context, workflowID string, req *ExecuteRequest) (*ExecuteResponse, error) {
	cli, err := ensureClient(e)
	if err != nil {
		return nil, err
	}
	payload := buildWorkflowExecuteRequest(req)
	resp, err := cli.ExecuteWorkflow(ctx, workflowID, payload)
	if err != nil {
		return nil, err
	}
	return newExecuteResponse(resp.ExecID, resp.ExecURL), nil
}

// ExecuteWorkflowSync performs synchronous workflow execution and returns the result.
func (e *Engine) ExecuteWorkflowSync(ctx context.Context, workflowID string, req *ExecuteSyncRequest) (*ExecuteSyncResponse, error) {
	cli, err := ensureClient(e)
	if err != nil {
		return nil, err
	}
	payload := buildWorkflowSyncRequest(req)
	resp, err := cli.ExecuteWorkflowSync(ctx, workflowID, payload)
	if err != nil {
		return nil, err
	}
	return buildSyncResponse(resp.ExecID, resp.Output), nil
}

// ExecuteWorkflowStream starts workflow execution and returns a stream session.
func (e *Engine) ExecuteWorkflowStream(ctx context.Context, workflowID string, req *ExecuteRequest, opts *client.StreamOptions) (*client.StreamSession, error) {
	cli, err := ensureClient(e)
	if err != nil {
		return nil, err
	}
	payload := buildWorkflowExecuteRequest(req)
	return cli.ExecuteWorkflowStream(ctx, workflowID, payload, opts)
}

// ExecuteTask triggers asynchronous task execution via the client.
func (e *Engine) ExecuteTask(ctx context.Context, taskID string, req *ExecuteRequest) (*ExecuteResponse, error) {
	cli, err := ensureClient(e)
	if err != nil {
		return nil, err
	}
	payload := buildTaskExecuteRequest(req)
	resp, err := cli.ExecuteTask(ctx, taskID, payload)
	if err != nil {
		return nil, err
	}
	return newExecuteResponse(resp.ExecID, resp.ExecURL), nil
}

// ExecuteTaskSync performs synchronous task execution and returns the result.
func (e *Engine) ExecuteTaskSync(ctx context.Context, taskID string, req *ExecuteSyncRequest) (*ExecuteSyncResponse, error) {
	cli, err := ensureClient(e)
	if err != nil {
		return nil, err
	}
	payload := buildTaskSyncRequest(req)
	resp, err := cli.ExecuteTaskSync(ctx, taskID, payload)
	if err != nil {
		return nil, err
	}
	return buildSyncResponse(resp.ExecID, resp.Output), nil
}

// ExecuteTaskStream starts task execution and returns a stream session.
func (e *Engine) ExecuteTaskStream(ctx context.Context, taskID string, req *ExecuteRequest, opts *client.StreamOptions) (*client.StreamSession, error) {
	cli, err := ensureClient(e)
	if err != nil {
		return nil, err
	}
	payload := buildTaskExecuteRequest(req)
	return cli.ExecuteTaskStream(ctx, taskID, payload, opts)
}

// ExecuteAgent triggers asynchronous agent execution via the client.
func (e *Engine) ExecuteAgent(ctx context.Context, agentID string, req *ExecuteRequest) (*ExecuteResponse, error) {
	cli, err := ensureClient(e)
	if err != nil {
		return nil, err
	}
	payload := buildAgentExecuteRequest(req)
	resp, err := cli.ExecuteAgent(ctx, agentID, payload)
	if err != nil {
		return nil, err
	}
	return newExecuteResponse(resp.ExecID, resp.ExecURL), nil
}

// ExecuteAgentSync performs synchronous agent execution and returns the result.
func (e *Engine) ExecuteAgentSync(ctx context.Context, agentID string, req *ExecuteSyncRequest) (*ExecuteSyncResponse, error) {
	cli, err := ensureClient(e)
	if err != nil {
		return nil, err
	}
	payload := buildAgentSyncRequest(req)
	resp, err := cli.ExecuteAgentSync(ctx, agentID, payload)
	if err != nil {
		return nil, err
	}
	return buildSyncResponse(resp.ExecID, resp.Output), nil
}

// ExecuteAgentStream starts agent execution and returns a stream session.
func (e *Engine) ExecuteAgentStream(ctx context.Context, agentID string, req *ExecuteRequest, opts *client.StreamOptions) (*client.StreamSession, error) {
	cli, err := ensureClient(e)
	if err != nil {
		return nil, err
	}
	payload := buildAgentExecuteRequest(req)
	return cli.ExecuteAgentStream(ctx, agentID, payload, opts)
}
func ensureClient(e *Engine) (*client.Client, error) {
	if e == nil {
		return nil, fmt.Errorf("engine is nil")
	}
	if e.client == nil {
		return nil, fmt.Errorf("engine client is not initialized")
	}
	return e.client, nil
}
func newExecuteResponse(execID string, execURL string) *ExecuteResponse {
	return &ExecuteResponse{
		ExecID:  execID,
		ExecURL: execURL,
	}
}
func buildSyncResponse(execID string, output *core.Output) *ExecuteSyncResponse {
	return &ExecuteSyncResponse{
		ExecID: execID,
		Output: copyOutput(output),
	}
}
func copyInput(values map[string]any) core.Input {
	if len(values) == 0 {
		return nil
	}
	cloned := core.CopyMaps(values)
	if len(cloned) == 0 {
		return nil
	}
	return core.Input(cloned)
}
func copyOutput(output *core.Output) map[string]any {
	if output == nil {
		return nil
	}
	return output.AsMap()
}
func stringFromOptions(options map[string]any, key string) string {
	if options == nil {
		return ""
	}
	raw, ok := options[key]
	if !ok {
		return ""
	}
	str, isString := raw.(string)
	if isString {
		return strings.TrimSpace(str)
	}
	stringer, isStringer := raw.(fmt.Stringer)
	if isStringer {
		return strings.TrimSpace(stringer.String())
	}
	return ""
}
func intFromOptions(options map[string]any, key string) *int {
	if options == nil {
		return nil
	}
	raw, ok := options[key]
	if !ok {
		return nil
	}
	var value int
	intValue, isInt := raw.(int)
	if isInt {
		value = intValue
	} else {
		strValue, isString := raw.(string)
		if !isString {
			return nil
		}
		parsed, err := strconv.Atoi(strings.TrimSpace(strValue))
		if err != nil {
			return nil
		}
		value = parsed
	}
	if value <= 0 {
		return nil
	}
	return &value
}
func durationSeconds(value *time.Duration) *int {
	if value == nil {
		return nil
	}
	secs := int(value.Seconds())
	if secs <= 0 {
		return nil
	}
	return &secs
}
func buildWorkflowExecuteRequest(req *ExecuteRequest) *client.WorkflowExecuteRequest {
	payload := &client.WorkflowExecuteRequest{}
	if req == nil {
		return payload
	}
	inputCopy := copyInput(req.Input)
	if inputCopy != nil {
		payload.Input = inputCopy
	}
	task := stringFromOptions(req.Options, "task_id")
	if task != "" {
		payload.TaskID = task
	}
	return payload
}
func buildWorkflowSyncRequest(req *ExecuteSyncRequest) *client.WorkflowSyncRequest {
	payload := &client.WorkflowSyncRequest{}
	if req == nil {
		return payload
	}
	inputCopy := copyInput(req.Input)
	if inputCopy != nil {
		payload.Input = inputCopy
	}
	secs := durationSeconds(req.Timeout)
	if secs != nil {
		payload.Timeout = *secs
	}
	task := stringFromOptions(req.Options, "task_id")
	if task != "" {
		payload.TaskID = task
	}
	return payload
}
func buildTaskExecuteRequest(req *ExecuteRequest) *client.TaskExecuteRequest {
	payload := &client.TaskExecuteRequest{}
	if req == nil {
		return payload
	}
	payload.With = copyInput(req.Input)
	timeoutOpt := intFromOptions(req.Options, "timeout")
	if timeoutOpt != nil {
		payload.Timeout = timeoutOpt
	}
	return payload
}
func buildTaskSyncRequest(req *ExecuteSyncRequest) *client.TaskExecuteRequest {
	payload := &client.TaskExecuteRequest{}
	if req == nil {
		return payload
	}
	payload.With = copyInput(req.Input)
	secs := durationSeconds(req.Timeout)
	if secs != nil {
		payload.Timeout = secs
		return payload
	}
	timeoutOpt := intFromOptions(req.Options, "timeout")
	if timeoutOpt != nil {
		payload.Timeout = timeoutOpt
	}
	return payload
}
func buildAgentExecuteRequest(req *ExecuteRequest) *client.AgentExecuteRequest {
	payload := &client.AgentExecuteRequest{}
	if req == nil {
		return payload
	}
	payload.With = copyInput(req.Input)
	action := stringFromOptions(req.Options, "action")
	if action != "" {
		payload.Action = action
	}
	prompt := stringFromOptions(req.Options, "prompt")
	if prompt != "" {
		payload.Prompt = prompt
	}
	timeoutOpt := intFromOptions(req.Options, "timeout")
	if timeoutOpt != nil {
		payload.Timeout = *timeoutOpt
	}
	return payload
}
func buildAgentSyncRequest(req *ExecuteSyncRequest) *client.AgentExecuteRequest {
	payload := &client.AgentExecuteRequest{}
	if req == nil {
		return payload
	}
	payload.With = copyInput(req.Input)
	action := stringFromOptions(req.Options, "action")
	if action != "" {
		payload.Action = action
	}
	prompt := stringFromOptions(req.Options, "prompt")
	if prompt != "" {
		payload.Prompt = prompt
	}
	secs := durationSeconds(req.Timeout)
	if secs != nil {
		payload.Timeout = *secs
		return payload
	}
	timeoutOpt := intFromOptions(req.Options, "timeout")
	if timeoutOpt != nil {
		payload.Timeout = *timeoutOpt
	}
	return payload
}
