// Code generated by compozygen. DO NOT EDIT.
package compozy

import (
	"context"
	"errors"
	"fmt"
	"strings"

	engineagent "github.com/compozy/compozy/engine/agent"
	enginecore "github.com/compozy/compozy/engine/core"
	engineknowledge "github.com/compozy/compozy/engine/knowledge"
	enginemcp "github.com/compozy/compozy/engine/mcp"
	enginememory "github.com/compozy/compozy/engine/memory"
	engineproject "github.com/compozy/compozy/engine/project"
	projectschedule "github.com/compozy/compozy/engine/project/schedule"
	"github.com/compozy/compozy/engine/resources"
	engineschema "github.com/compozy/compozy/engine/schema"
	enginetool "github.com/compozy/compozy/engine/tool"
	enginewebhook "github.com/compozy/compozy/engine/webhook"
	engineworkflow "github.com/compozy/compozy/engine/workflow"
)

type registrationSource string

const (
	registrationSourceProgrammatic registrationSource = registrationSource(resourceSourceProgrammatic)
	registrationSourceYAML         registrationSource = registrationSource(resourceSourceYAML)
)

func (s registrationSource) metaSource() string {
	if s == "" {
		return resourceSourceProgrammatic
	}
	return string(s)
}

func (e *Engine) RegisterProject(cfg *engineproject.Config) error {
	return e.registerProject(cfg, registrationSourceProgrammatic)
}

func (e *Engine) registerProject(cfg *engineproject.Config, source registrationSource) error {
	if e == nil {
		return fmt.Errorf("engine is nil")
	}
	if cfg == nil {
		return fmt.Errorf("project config is required")
	}
	name := strings.TrimSpace(cfg.Name)
	if name == "" {
		return fmt.Errorf("project name is required")
	}
	e.stateMu.Lock()
	if e.project != nil {
		existing := strings.TrimSpace(e.project.Name)
		e.stateMu.Unlock()
		return fmt.Errorf("project %s already registered", existing)
	}
	e.project = cfg
	store := e.resourceStore
	e.stateMu.Unlock()
	if err := e.persistResource(e.ctx, store, name, resources.ResourceProject, name, cfg, source); err != nil {
		e.stateMu.Lock()
		if e.project == cfg {
			e.project = nil
		}
		e.stateMu.Unlock()
		return err
	}
	return nil
}

func (e *Engine) RegisterWorkflow(cfg *engineworkflow.Config) error {
	return e.registerWorkflow(cfg, registrationSourceProgrammatic)
}

func (e *Engine) registerWorkflow(cfg *engineworkflow.Config, source registrationSource) error {
	if e == nil {
		return fmt.Errorf("engine is nil")
	}
	if cfg == nil {
		return fmt.Errorf("workflow config is required")
	}
	id := strings.TrimSpace(cfg.ID)
	if id == "" {
		return fmt.Errorf("workflow id is required")
	}
	e.stateMu.Lock()
	if containsConfig(e.workflows, func(existing *engineworkflow.Config) bool {
		return strings.TrimSpace(existing.ID) == id
	}) {
		e.stateMu.Unlock()
		return fmt.Errorf("workflow %s already registered", id)
	}
	e.workflows = append(e.workflows, cfg)
	store := e.resourceStore
	projectName := projectNameOf(e.project)
	e.stateMu.Unlock()
	if err := e.persistResource(e.ctx, store, projectName, resources.ResourceWorkflow, id, cfg, source); err != nil {
		e.stateMu.Lock()
		e.workflows = removeConfig(e.workflows, func(value *engineworkflow.Config) bool {
			return value == cfg
		})
		e.stateMu.Unlock()
		return err
	}
	return nil
}

func (e *Engine) RegisterAgent(cfg *engineagent.Config) error {
	return e.registerAgent(cfg, registrationSourceProgrammatic)
}

func (e *Engine) registerAgent(cfg *engineagent.Config, source registrationSource) error {
	if e == nil {
		return fmt.Errorf("engine is nil")
	}
	if cfg == nil {
		return fmt.Errorf("agent config is required")
	}
	id := strings.TrimSpace(cfg.ID)
	if id == "" {
		return fmt.Errorf("agent id is required")
	}
	e.stateMu.Lock()
	if containsConfig(e.agents, func(existing *engineagent.Config) bool {
		return strings.TrimSpace(existing.ID) == id
	}) {
		e.stateMu.Unlock()
		return fmt.Errorf("agent %s already registered", id)
	}
	e.agents = append(e.agents, cfg)
	store := e.resourceStore
	projectName := projectNameOf(e.project)
	e.stateMu.Unlock()
	if err := e.persistResource(e.ctx, store, projectName, resources.ResourceAgent, id, cfg, source); err != nil {
		e.stateMu.Lock()
		e.agents = removeConfig(e.agents, func(value *engineagent.Config) bool {
			return value == cfg
		})
		e.stateMu.Unlock()
		return err
	}
	return nil
}

func (e *Engine) RegisterTool(cfg *enginetool.Config) error {
	return e.registerTool(cfg, registrationSourceProgrammatic)
}

func (e *Engine) registerTool(cfg *enginetool.Config, source registrationSource) error {
	if e == nil {
		return fmt.Errorf("engine is nil")
	}
	if cfg == nil {
		return fmt.Errorf("tool config is required")
	}
	id := strings.TrimSpace(cfg.ID)
	if id == "" {
		return fmt.Errorf("tool id is required")
	}
	e.stateMu.Lock()
	if containsConfig(e.tools, func(existing *enginetool.Config) bool {
		return strings.TrimSpace(existing.ID) == id
	}) {
		e.stateMu.Unlock()
		return fmt.Errorf("tool %s already registered", id)
	}
	e.tools = append(e.tools, cfg)
	store := e.resourceStore
	projectName := projectNameOf(e.project)
	e.stateMu.Unlock()
	if err := e.persistResource(e.ctx, store, projectName, resources.ResourceTool, id, cfg, source); err != nil {
		e.stateMu.Lock()
		e.tools = removeConfig(e.tools, func(value *enginetool.Config) bool {
			return value == cfg
		})
		e.stateMu.Unlock()
		return err
	}
	return nil
}

func (e *Engine) RegisterKnowledge(cfg *engineknowledge.BaseConfig) error {
	return e.registerKnowledge(cfg, registrationSourceProgrammatic)
}

func (e *Engine) registerKnowledge(cfg *engineknowledge.BaseConfig, source registrationSource) error {
	if e == nil {
		return fmt.Errorf("engine is nil")
	}
	if cfg == nil {
		return fmt.Errorf("knowledge config is required")
	}
	id := strings.TrimSpace(cfg.ID)
	if id == "" {
		return fmt.Errorf("knowledge base id is required")
	}
	e.stateMu.Lock()
	if containsConfig(e.knowledgeBases, func(existing *engineknowledge.BaseConfig) bool {
		return strings.TrimSpace(existing.ID) == id
	}) {
		e.stateMu.Unlock()
		return fmt.Errorf("knowledge base %s already registered", id)
	}
	e.knowledgeBases = append(e.knowledgeBases, cfg)
	store := e.resourceStore
	projectName := projectNameOf(e.project)
	e.stateMu.Unlock()
	if err := e.persistResource(e.ctx, store, projectName, resources.ResourceKnowledgeBase, id, cfg, source); err != nil {
		e.stateMu.Lock()
		e.knowledgeBases = removeConfig(e.knowledgeBases, func(value *engineknowledge.BaseConfig) bool {
			return value == cfg
		})
		e.stateMu.Unlock()
		return err
	}
	return nil
}

func (e *Engine) RegisterMemory(cfg *enginememory.Config) error {
	return e.registerMemory(cfg, registrationSourceProgrammatic)
}

func (e *Engine) registerMemory(cfg *enginememory.Config, source registrationSource) error {
	if e == nil {
		return fmt.Errorf("engine is nil")
	}
	if cfg == nil {
		return fmt.Errorf("memory config is required")
	}
	id := strings.TrimSpace(cfg.ID)
	if id == "" {
		return fmt.Errorf("memory id is required")
	}
	e.stateMu.Lock()
	if containsConfig(e.memories, func(existing *enginememory.Config) bool {
		return strings.TrimSpace(existing.ID) == id
	}) {
		e.stateMu.Unlock()
		return fmt.Errorf("memory %s already registered", id)
	}
	e.memories = append(e.memories, cfg)
	store := e.resourceStore
	projectName := projectNameOf(e.project)
	e.stateMu.Unlock()
	if err := e.persistResource(e.ctx, store, projectName, resources.ResourceMemory, id, cfg, source); err != nil {
		e.stateMu.Lock()
		e.memories = removeConfig(e.memories, func(value *enginememory.Config) bool {
			return value == cfg
		})
		e.stateMu.Unlock()
		return err
	}
	return nil
}

func (e *Engine) RegisterMCP(cfg *enginemcp.Config) error {
	return e.registerMCP(cfg, registrationSourceProgrammatic)
}

func (e *Engine) registerMCP(cfg *enginemcp.Config, source registrationSource) error {
	if e == nil {
		return fmt.Errorf("engine is nil")
	}
	if cfg == nil {
		return fmt.Errorf("mcp config is required")
	}
	id := strings.TrimSpace(cfg.ID)
	if id == "" {
		return fmt.Errorf("mcp id is required")
	}
	e.stateMu.Lock()
	if containsConfig(e.mcps, func(existing *enginemcp.Config) bool {
		return strings.TrimSpace(existing.ID) == id
	}) {
		e.stateMu.Unlock()
		return fmt.Errorf("mcp %s already registered", id)
	}
	e.mcps = append(e.mcps, cfg)
	store := e.resourceStore
	projectName := projectNameOf(e.project)
	e.stateMu.Unlock()
	if err := e.persistResource(e.ctx, store, projectName, resources.ResourceMCP, id, cfg, source); err != nil {
		e.stateMu.Lock()
		e.mcps = removeConfig(e.mcps, func(value *enginemcp.Config) bool {
			return value == cfg
		})
		e.stateMu.Unlock()
		return err
	}
	return nil
}

func (e *Engine) RegisterSchema(cfg *engineschema.Schema) error {
	return e.registerSchema(cfg, registrationSourceProgrammatic)
}

func (e *Engine) registerSchema(cfg *engineschema.Schema, source registrationSource) error {
	if e == nil {
		return fmt.Errorf("engine is nil")
	}
	if cfg == nil {
		return fmt.Errorf("schema config is required")
	}
	id := strings.TrimSpace(engineschema.GetID(cfg))
	if id == "" {
		return fmt.Errorf("schema id is required")
	}
	e.stateMu.Lock()
	if containsConfig(e.schemas, func(existing *engineschema.Schema) bool {
		return strings.TrimSpace(engineschema.GetID(existing)) == id
	}) {
		e.stateMu.Unlock()
		return fmt.Errorf("schema %s already registered", id)
	}
	e.schemas = append(e.schemas, cfg)
	store := e.resourceStore
	projectName := projectNameOf(e.project)
	e.stateMu.Unlock()
	if err := e.persistResource(e.ctx, store, projectName, resources.ResourceSchema, id, cfg, source); err != nil {
		e.stateMu.Lock()
		e.schemas = removeConfig(e.schemas, func(value *engineschema.Schema) bool {
			return value == cfg
		})
		e.stateMu.Unlock()
		return err
	}
	return nil
}

func (e *Engine) RegisterModel(cfg *enginecore.ProviderConfig) error {
	return e.registerModel(cfg, registrationSourceProgrammatic)
}

func (e *Engine) registerModel(cfg *enginecore.ProviderConfig, source registrationSource) error {
	if e == nil {
		return fmt.Errorf("engine is nil")
	}
	if cfg == nil {
		return fmt.Errorf("model config is required")
	}
	provider := strings.TrimSpace(string(cfg.Provider))
	model := strings.TrimSpace(cfg.Model)
	id := provider + ":" + model
	if provider == "" || model == "" {
		return fmt.Errorf("model identifier is required")
	}
	e.stateMu.Lock()
	if containsConfig(e.models, func(existing *enginecore.ProviderConfig) bool {
		key := strings.TrimSpace(string(existing.Provider)) + ":" + strings.TrimSpace(existing.Model)
		return key == id
	}) {
		e.stateMu.Unlock()
		return fmt.Errorf("model %s already registered", id)
	}
	e.models = append(e.models, cfg)
	store := e.resourceStore
	projectName := projectNameOf(e.project)
	e.stateMu.Unlock()
	if err := e.persistResource(e.ctx, store, projectName, resources.ResourceModel, id, cfg, source); err != nil {
		e.stateMu.Lock()
		e.models = removeConfig(e.models, func(value *enginecore.ProviderConfig) bool {
			return value == cfg
		})
		e.stateMu.Unlock()
		return err
	}
	return nil
}

func (e *Engine) RegisterSchedule(cfg *projectschedule.Config) error {
	return e.registerSchedule(cfg, registrationSourceProgrammatic)
}

func (e *Engine) registerSchedule(cfg *projectschedule.Config, source registrationSource) error {
	if e == nil {
		return fmt.Errorf("engine is nil")
	}
	if cfg == nil {
		return fmt.Errorf("schedule config is required")
	}
	id := strings.TrimSpace(cfg.ID)
	if id == "" {
		return fmt.Errorf("schedule id is required")
	}
	e.stateMu.Lock()
	if containsConfig(e.schedules, func(existing *projectschedule.Config) bool {
		return strings.TrimSpace(existing.ID) == id
	}) {
		e.stateMu.Unlock()
		return fmt.Errorf("schedule %s already registered", id)
	}
	e.schedules = append(e.schedules, cfg)
	store := e.resourceStore
	projectName := projectNameOf(e.project)
	e.stateMu.Unlock()
	if err := e.persistResource(e.ctx, store, projectName, resources.ResourceSchedule, id, cfg, source); err != nil {
		e.stateMu.Lock()
		e.schedules = removeConfig(e.schedules, func(value *projectschedule.Config) bool {
			return value == cfg
		})
		e.stateMu.Unlock()
		return err
	}
	return nil
}

func (e *Engine) RegisterWebhook(cfg *enginewebhook.Config) error {
	return e.registerWebhook(cfg, registrationSourceProgrammatic)
}

func (e *Engine) registerWebhook(cfg *enginewebhook.Config, source registrationSource) error {
	if e == nil {
		return fmt.Errorf("engine is nil")
	}
	if cfg == nil {
		return fmt.Errorf("webhook config is required")
	}
	slug := strings.TrimSpace(cfg.Slug)
	if slug == "" {
		return fmt.Errorf("webhook slug is required")
	}
	e.stateMu.Lock()
	if containsConfig(e.webhooks, func(existing *enginewebhook.Config) bool {
		return strings.TrimSpace(existing.Slug) == slug
	}) {
		e.stateMu.Unlock()
		return fmt.Errorf("webhook %s already registered", slug)
	}
	e.webhooks = append(e.webhooks, cfg)
	store := e.resourceStore
	projectName := projectNameOf(e.project)
	e.stateMu.Unlock()
	if err := e.persistResource(e.ctx, store, projectName, resources.ResourceWebhook, slug, cfg, source); err != nil {
		e.stateMu.Lock()
		e.webhooks = removeConfig(e.webhooks, func(value *enginewebhook.Config) bool {
			return value == cfg
		})
		e.stateMu.Unlock()
		return err
	}
	return nil
}

func (e *Engine) persistResource(
	ctx context.Context,
	store resources.ResourceStore,
	projectName string,
	typ resources.ResourceType,
	id string,
	value any,
	source registrationSource,
) error {
	if ctx == nil || store == nil {
		return nil
	}
	keyProject := strings.TrimSpace(projectName)
	resourceID := strings.TrimSpace(id)
	if typ == resources.ResourceProject {
		keyProject = resourceID
	} else if keyProject == "" {
		return nil
	}
	if resourceID == "" {
		return fmt.Errorf("%s id is required", string(typ))
	}
	key := resources.ResourceKey{Project: keyProject, Type: typ, ID: resourceID}
	if _, _, err := store.Get(ctx, key); err == nil {
		return fmt.Errorf("%s %s already registered", string(typ), resourceID)
	} else if err != nil && !errors.Is(err, resources.ErrNotFound) {
		return fmt.Errorf("inspect %s %s registration state: %w", string(typ), resourceID, err)
	}
	if _, err := store.Put(ctx, key, value); err != nil {
		return fmt.Errorf("store %s %s: %w", string(typ), resourceID, err)
	}
	if err := resources.WriteMeta(ctx, store, key.Project, typ, resourceID, source.metaSource(), registrationUpdatedBy); err != nil {
		return fmt.Errorf("write %s %s metadata: %w", string(typ), resourceID, err)
	}
	return nil
}

func projectNameOf(cfg *engineproject.Config) string {
	if cfg == nil {
		return ""
	}
	return strings.TrimSpace(cfg.Name)
}

func containsConfig[T any](values []*T, predicate func(*T) bool) bool {
	for _, value := range values {
		if value == nil {
			continue
		}
		if predicate(value) {
			return true
		}
	}
	return false
}

func removeConfig[T any](values []*T, predicate func(*T) bool) []*T {
	for i, value := range values {
		if value == nil {
			continue
		}
		if predicate(value) {
			return append(values[:i], values[i+1:]...)
		}
	}
	return values
}
