// Code generated by optionsgen. DO NOT EDIT.

package workflow

import (
	agent "github.com/compozy/compozy/engine/agent"
	core "github.com/compozy/compozy/engine/core"
	knowledge "github.com/compozy/compozy/engine/knowledge"
	mcp "github.com/compozy/compozy/engine/mcp"
	schema "github.com/compozy/compozy/engine/schema"
	task "github.com/compozy/compozy/engine/task"
	tool "github.com/compozy/compozy/engine/tool"
	workflow "github.com/compozy/compozy/engine/workflow"
)

type Option func(*workflow.Config)

// WithResource sets the Resource field
//
// Resource reference for external workflow definitions
// Format: "compozy:workflow:<name>" - allows referencing pre-built workflows
func WithResource(resource string) Option {
	return func(cfg *workflow.Config) {
		cfg.Resource = resource
	}
}

// WithID sets the ID field
//
// Unique identifier for the workflow (required)
// Must be unique within the project scope. Used for referencing and execution.
// - **Example**: "customer-support", "data-processing", "content-generation"
func WithID(id string) Option {
	return func(cfg *workflow.Config) {
		cfg.ID = id
	}
}

// WithVersion sets the Version field
//
// Version of the workflow for tracking changes
// Follows semantic versioning (e.g., "1.0.0", "2.1.3")
// Useful for managing workflow evolution and backwards compatibility
func WithVersion(version string) Option {
	return func(cfg *workflow.Config) {
		cfg.Version = version
	}
}

// WithDescription sets the Description field
//
// Human-readable description of the workflow's purpose
// Should clearly explain what the workflow does and when to use it
func WithDescription(description string) Option {
	return func(cfg *workflow.Config) {
		cfg.Description = description
	}
}

// WithSchemas sets the Schemas field
//
// JSON schemas for validating data structures used in the workflow
// Define reusable schemas that can be referenced throughout the workflow
// using $ref syntax (e.g., $ref: local::schemas.#(id="user_schema"))
func WithSchemas(schemas []schema.Schema) Option {
	return func(cfg *workflow.Config) {
		cfg.Schemas = schemas
	}
}

// WithOpts sets the Opts field
//
// Configuration options including input schema and environment variables
// Controls workflow behavior, validation, and runtime environment
func WithOpts(opts workflow.Opts) Option {
	return func(cfg *workflow.Config) {
		cfg.Opts = opts
	}
}

// WithAuthor sets the Author field
//
// Author information for workflow attribution
// Helps track ownership and responsibility for workflow maintenance
func WithAuthor(author *core.Author) Option {
	return func(cfg *workflow.Config) {
		cfg.Author = author
	}
}

// WithTools sets the Tools field
//
// External tools that can be invoked by agents or tasks
// Define executable scripts or programs that perform specific operations
// Tools provide deterministic, non-AI functionality like API calls or data processing
// $ref: schema://tools
func WithTools(tools []tool.Config) Option {
	return func(cfg *workflow.Config) {
		cfg.Tools = tools
	}
}

// WithAgents sets the Agents field
//
// AI agents with specific instructions and capabilities
// Configure LLM-powered agents with custom prompts, tools access, and behavior
// Agents can be referenced by tasks using $use: agent(...) syntax
// $ref: schema://agents
func WithAgents(agents []agent.Config) Option {
	return func(cfg *workflow.Config) {
		cfg.Agents = agents
	}
}

// WithKnowledgeBases sets the KnowledgeBases field
//
// KnowledgeBases declares workflow-scoped knowledge definitions.
func WithKnowledgeBases(knowledgeBases []knowledge.BaseConfig) Option {
	return func(cfg *workflow.Config) {
		cfg.KnowledgeBases = knowledgeBases
	}
}

// WithKnowledge sets the Knowledge field
//
// Knowledge defines the default knowledge binding for the workflow context.
func WithKnowledge(knowledge []core.KnowledgeBinding) Option {
	return func(cfg *workflow.Config) {
		cfg.Knowledge = knowledge
	}
}

// WithMCPs sets the MCPs field
//
// Model Context Protocol servers for extending AI capabilities
// MCP servers provide specialized tools and knowledge to agents
// Enable integration with external services and domain-specific functionality
// $ref: schema://mcp
func WithMCPs(mCPs []mcp.Config) Option {
	return func(cfg *workflow.Config) {
		cfg.MCPs = mCPs
	}
}

// WithTriggers sets the Triggers field
//
// Event triggers that can initiate workflow execution
// Define external events (webhooks, signals) that can start the workflow
// Each trigger can have its own input schema for validation
func WithTriggers(triggers []workflow.Trigger) Option {
	return func(cfg *workflow.Config) {
		cfg.Triggers = triggers
	}
}

// WithTasks sets the Tasks field
//
// Sequential tasks that define the workflow execution plan (required)
// Tasks are the core execution units, processed in order with conditional branching
// Each task uses either an agent or tool to perform its operation
// $ref: schema://tasks
func WithTasks(tasks []task.Config) Option {
	return func(cfg *workflow.Config) {
		cfg.Tasks = tasks
	}
}

// WithOutputs sets the Outputs field
//
// Output mappings to structure the final workflow results
// Use template expressions to extract and transform task outputs
// - **Example**: ticket_id: "{{ .tasks.create-ticket.output.id }}"
func WithOutputs(outputs *core.Output) Option {
	return func(cfg *workflow.Config) {
		cfg.Outputs = outputs
	}
}

// WithSchedule sets the Schedule field
//
// Schedule configuration for automated workflow execution
// Enable cron-based scheduling with timezone support and overlap policies
func WithSchedule(schedule *workflow.Schedule) Option {
	return func(cfg *workflow.Config) {
		cfg.Schedule = schedule
	}
}
