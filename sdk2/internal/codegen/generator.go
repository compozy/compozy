package codegen

import (
	"fmt"
	"strings"

	"github.com/dave/jennifer/jen"
)

const engineBaseImport = "github.com/compozy/compozy/engine"

// GenerateOptions creates functional options for all discovered fields
func GenerateOptions(info *StructInfo, outputPath string, targetPackage string) error {
	f := jen.NewFile(targetPackage)
	f.HeaderComment("Code generated by optionsgen. DO NOT EDIT.")
	f.Line()
	enginePkg := fmt.Sprintf("%s/%s", engineBaseImport, info.PackageName)
	f.Type().Id("Option").Func().Params(
		jen.Op("*").Qual(enginePkg, info.StructName),
	)
	f.Line()
	for i := range info.Fields {
		if shouldSkipField(&info.Fields[i]) {
			continue
		}
		generateOptionFunc(f, info, &info.Fields[i], enginePkg)
	}
	return f.Save(outputPath)
}

func shouldSkipField(field *FieldInfo) bool {
	unexported := []string{"filePath", "CWD"}
	for _, skip := range unexported {
		if field.Name == skip {
			return true
		}
	}
	return false
}

func generateOptionFunc(f *jen.File, info *StructInfo, field *FieldInfo, enginePkg string) {
	funcName := "With" + field.Name
	paramName := toParamName(field.Name)
	if field.Comment != "" {
		commentLines := strings.Split(field.Comment, "\n")
		f.Comment(fmt.Sprintf("%s sets the %s field", funcName, field.Name))
		if len(commentLines) > 0 && commentLines[0] != "" {
			f.Comment("")
			for _, line := range commentLines {
				if line = strings.TrimSpace(line); line != "" {
					f.Comment(line)
				}
			}
		}
	} else {
		f.Comment(fmt.Sprintf("%s sets the %s field", funcName, field.Name))
	}
	paramType := buildParameterType(field, info.PackageName)
	f.Func().Id(funcName).Params(
		jen.Id(paramName).Add(paramType),
	).Id("Option").Block(
		jen.Return(jen.Func().Params(
			jen.Id("cfg").Op("*").Qual(enginePkg, info.StructName),
		).Block(
			jen.Id("cfg").Dot(field.Name).Op("=").Id(paramName),
		)),
	)
	f.Line()
}

func buildParameterType(field *FieldInfo, currentPkg string) *jen.Statement {
	var stmt *jen.Statement
	switch {
	case field.IsMap:
		keyType := jen.Id(field.KeyType)
		valueType := buildSimpleType(field.ValueType, field.PackagePath, currentPkg)
		stmt = jen.Map(keyType).Add(valueType)
	case field.IsSlice:
		elemType := buildSimpleType(field.ValueType, field.PackagePath, currentPkg)
		stmt = jen.Index().Add(elemType)
	default:
		stmt = buildSimpleType(field.Type, field.PackagePath, currentPkg)
	}
	if field.IsPtr && !field.IsSlice {
		stmt = jen.Op("*").Add(stmt)
	}
	return stmt
}

func buildSimpleType(typeName string, packagePath string, currentPkg string) *jen.Statement {
	if strings.HasPrefix(typeName, "*") {
		inner := buildSimpleType(strings.TrimPrefix(typeName, "*"), packagePath, currentPkg)
		return jen.Op("*").Add(inner)
	}
	if strings.HasPrefix(typeName, "[]") {
		inner := buildSimpleType(strings.TrimPrefix(typeName, "[]"), packagePath, currentPkg)
		return jen.Index().Add(inner)
	}
	if isBuiltinType(typeName) {
		return jen.Id(typeName)
	}
	if strings.Contains(typeName, ".") {
		parts := strings.Split(typeName, ".")
		pkgName := parts[0]
		typeName := parts[1]
		enginePkg := fmt.Sprintf("%s/%s", engineBaseImport, pkgName)
		return jen.Qual(enginePkg, typeName)
	}
	if packagePath == "" || packagePath == currentPkg {
		enginePkg := fmt.Sprintf("%s/%s", engineBaseImport, currentPkg)
		return jen.Qual(enginePkg, typeName)
	}
	enginePkg := fmt.Sprintf("%s/%s", engineBaseImport, packagePath)
	return jen.Qual(enginePkg, typeName)
}

func isBuiltinType(typeName string) bool {
	builtins := map[string]bool{
		"string": true, "int": true, "int8": true, "int16": true, "int32": true, "int64": true,
		"uint": true, "uint8": true, "uint16": true, "uint32": true, "uint64": true,
		"float32": true, "float64": true, "bool": true, "byte": true, "rune": true,
		"error": true, "interface{}": true, "any": true,
	}
	return builtins[typeName]
}

func toParamName(fieldName string) string {
	if fieldName == "" {
		return fieldName
	}
	if len(fieldName) == 1 {
		return strings.ToLower(fieldName)
	}
	if fieldName == "ID" {
		return "id"
	}
	if len(fieldName) > 1 && isAllCaps(fieldName) {
		return strings.ToLower(fieldName)
	}
	return strings.ToLower(fieldName[:1]) + fieldName[1:]
}

func isAllCaps(s string) bool {
	for _, r := range s {
		if r >= 'a' && r <= 'z' {
			return false
		}
	}
	return true
}
