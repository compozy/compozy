// Code generated by optionsgen. DO NOT EDIT.

package agent

import (
	agent "github.com/compozy/compozy/engine/agent"
	attachment "github.com/compozy/compozy/engine/attachment"
	core "github.com/compozy/compozy/engine/core"
	mcp "github.com/compozy/compozy/engine/mcp"
	tool "github.com/compozy/compozy/engine/tool"
)

type Option func(*agent.Config)

// WithTools sets the Tools field
//
// Tools available to the agent for extending its capabilities.
// When tools are defined, the agent automatically has `toolChoice` set to `"auto"`,
// enabling autonomous tool selection and invocation during task execution.
// **Tool types supported:**
// - File system operations (read, write, list)
// - API integrations (HTTP requests, webhooks)
// - Data processing utilities (parsing, transformation)
// - Custom business logic (TypeScript/JavaScript execution)
// Tools are referenced by ID and can be shared across multiple agents.
func WithTools(tools []tool.Config) Option {
	return func(cfg *agent.Config) {
		cfg.Tools = tools
	}
}

// WithMCPs sets the MCPs field
//
// Model Context Protocol (MCP) server configurations.
// MCPs provide standardized interfaces for extending agent capabilities
// with external services and data sources through protocol-based communication.
// **Common MCP integrations:**
// - Database connectors (PostgreSQL, Redis, MongoDB)
// - Search engines (Elasticsearch, Solr)
// - Knowledge bases (vector databases, documentation systems)
// - External APIs (REST, GraphQL, gRPC services)
// MCPs support both stdio and HTTP transport protocols.
func WithMCPs(mCPs []mcp.Config) Option {
	return func(cfg *agent.Config) {
		cfg.MCPs = mCPs
	}
}

// WithMaxIterations sets the MaxIterations field
//
// Maximum number of reasoning iterations the agent can perform.
// The agent may self-correct and refine its response across multiple iterations
// to improve accuracy and address complex multi-step problems.
// **Default:** `5` iterations
// **Trade-offs:**
// - Higher values enable more thorough problem-solving and self-correction
// - Each iteration consumes additional tokens and increases response latency
// - Configure based on task complexity, accuracy requirements, and cost constraints
func WithMaxIterations(maxIterations int) Option {
	return func(cfg *agent.Config) {
		cfg.MaxIterations = maxIterations
	}
}

// WithMemory sets the Memory field
//
// Memory references enabling the agent to access persistent context.
// Memory provides stateful interactions across workflow steps and sessions.
// **Configuration format:**
// ```yaml
// memory:
// - id: "user_context"           # Memory resource ID
// key: "user:{{.user_id}}"     # Dynamic key with template
// mode: "read-write"           # Access mode (default: "read-write")
// ```
// **Access modes:**
// - `"read-write"`: Full access to read and modify memory
// - `"read-only"`: Can only read existing memory entries
func WithMemory(memory []core.MemoryReference) Option {
	return func(cfg *agent.Config) {
		cfg.Memory = memory
	}
}

// WithModel sets the Model field
//
// Model selects which LLM model to use.
// Supports two forms:
// - string: a model ID to be resolved via the ResourceStore (e.g. "openai-gpt-4o-mini")
// - object: an inline core.ProviderConfig with provider/model/params
// During compile/link, string refs are resolved and merged with inline
// fields following project precedence rules. Defaults are filled from the
// project when neither ref nor inline identity is provided.
func WithModel(model agent.Model) Option {
	return func(cfg *agent.Config) {
		cfg.Model = model
	}
}

// WithAttachments sets the Attachments field
//
// Attachments declared at the agent scope.
func WithAttachments(attachments attachment.Attachments) Option {
	return func(cfg *agent.Config) {
		cfg.Attachments = attachments
	}
}

// WithResource sets the Resource field
//
// Resource identifier for the autoloader system (must be `"agent"`).
// This field enables automatic discovery and registration of agent configurations.
func WithResource(resource string) Option {
	return func(cfg *agent.Config) {
		cfg.Resource = resource
	}
}

// WithID sets the ID field
//
// Unique identifier for the agent within the project scope.
// Used for referencing the agent in workflows and other configurations.
// - **Examples:** `"code-assistant"`, `"data-analyst"`, `"customer-support"`
func WithID(id string) Option {
	return func(cfg *agent.Config) {
		cfg.ID = id
	}
}

// WithInstructions sets the Instructions field
//
// Provider configuration is now expressed through the polymorphic `Model` field.
// The previous `Config core.ProviderConfig` field has been removed.
// System instructions that define the agent's personality, behavior, and constraints.
// These instructions guide how the agent interprets tasks and generates responses.
// **Best practices:**
// - Be clear and specific about the agent's role
// - Define boundaries and ethical guidelines
// - Include domain-specific knowledge or constraints
// - Use markdown formatting for better structure
func WithInstructions(instructions string) Option {
	return func(cfg *agent.Config) {
		cfg.Instructions = instructions
	}
}

// WithActions sets the Actions field
//
// Structured actions the agent can perform with defined input/output schemas.
// Actions provide type-safe interfaces for specific agent capabilities.
// **Example:**
// ```yaml
// actions:
// - id: "review-code"
// prompt: |
// Analyze code {{.input.code}} for quality and improvements
// input:
// type: "object"
// properties:
// code:
// type: "string"
// description: "The code to review"
// output:
// type: "object"
// properties:
// quality:
// type: "string"
// description: "The quality of the code"
// ```
// $ref: inline:#action-configuration
func WithActions(actions []*agent.ActionConfig) Option {
	return func(cfg *agent.Config) {
		cfg.Actions = actions
	}
}

// WithWith sets the With field
//
// Default input parameters passed to the agent on every invocation.
// These values are merged with runtime inputs, with runtime values taking precedence.
// **Use cases:**
// - Setting default configuration values
// - Providing constant context or settings
// - Injecting workflow-level parameters
func WithWith(with *core.Input) Option {
	return func(cfg *agent.Config) {
		cfg.With = with
	}
}

// WithEnv sets the Env field
//
// Environment variables available during agent execution.
// Used for configuration, secrets, and runtime settings.
// **Example:**
// ```yaml
// env:
// API_KEY: "{{.env.OPENAI_API_KEY}}"
// DEBUG_MODE: "true"
// ```
func WithEnv(env *core.EnvMap) Option {
	return func(cfg *agent.Config) {
		cfg.Env = env
	}
}

// WithKnowledge sets the Knowledge field
//
// Knowledge declares knowledge bindings scoped to this agent.
func WithKnowledge(knowledge []core.KnowledgeBinding) Option {
	return func(cfg *agent.Config) {
		cfg.Knowledge = knowledge
	}
}
