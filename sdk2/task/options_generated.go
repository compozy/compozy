// Code generated by optionsgen. DO NOT EDIT.

package task

import (
	agent "github.com/compozy/compozy/engine/agent"
	attachment "github.com/compozy/compozy/engine/attachment"
	core "github.com/compozy/compozy/engine/core"
	schema "github.com/compozy/compozy/engine/schema"
	enginetask "github.com/compozy/compozy/engine/task"
	tool "github.com/compozy/compozy/engine/tool"
)

type Option func(*enginetask.Config)

// WithModelConfig sets the ModelConfig field
//
// LLM provider configuration defining which AI model to use and its parameters.
// Supports multiple providers including OpenAI, Anthropic, Google, Groq, and local models.
// **Required fields:** provider, model
// **Optional fields:** api_key, api_url, params (temperature, max_tokens, etc.)
func WithModelConfig(modelConfig core.ProviderConfig) Option {
	return func(cfg *enginetask.Config) {
		cfg.ModelConfig = modelConfig
	}
}

// WithAction sets the Action field
//
// Action identifier that describes what this task does
// Used for logging and debugging purposes
// - **Example**: "process-user-data", "send-notification"
func WithAction(action string) Option {
	return func(cfg *enginetask.Config) {
		cfg.Action = action
	}
}

// WithPrompt sets the Prompt field
//
// Prompt provides direct instruction to agents when no specific action is needed
// Used for ad-hoc agent interactions without predefined action definitions
// - **Example**: "Analyze this code for security issues", "Summarize the following text"
func WithPrompt(prompt string) Option {
	return func(cfg *enginetask.Config) {
		cfg.Prompt = prompt
	}
}

// WithRoutes sets the Routes field
//
// Routes maps condition values to task IDs or inline task configurations
// The condition field in BaseConfig is evaluated, and its result is used
// as the key to select the appropriate route
// Values can be:
// - Task ID (string): References an existing task
// - Inline task config (object): Defines task configuration directly
// - **Example**:
// routes:
// approved: "process-payment"  # Task ID reference
// rejected:                    # Inline task config
// type: basic
// agent: { id: rejection-handler }
// pending: "wait-for-approval"
func WithRoutes(routes map[string]any) Option {
	return func(cfg *enginetask.Config) {
		cfg.Routes = routes
	}
}

// WithStrategy sets the Strategy field
//
// Strategy determines how the parallel execution handles task completion
// Defaults to "wait_all" if not specified
// Options: wait_all, fail_fast, best_effort, race
func WithStrategy(strategy enginetask.ParallelStrategy) Option {
	return func(cfg *enginetask.Config) {
		cfg.Strategy = strategy
	}
}

// WithMaxWorkers sets the MaxWorkers field
//
// MaxWorkers limits the number of concurrent task executions
// 0 means no limit (all tasks run concurrently)
// - **Example**: 5 means at most 5 tasks run at the same time
func WithMaxWorkers(maxWorkers int) Option {
	return func(cfg *enginetask.Config) {
		cfg.MaxWorkers = maxWorkers
	}
}

// WithItems sets the Items field
//
// Items is a template expression that evaluates to an array
// The expression should resolve to a list of items to iterate over
// - **Example**: "{{ .workflow.input.users }}" or "{{ range(1, 10) }}"
func WithItems(items string) Option {
	return func(cfg *enginetask.Config) {
		cfg.Items = items
	}
}

// WithFilter sets the Filter field
//
// Filter is an optional CEL expression to filter items before processing
// Each item is available as 'item' in the expression
// - **Example**: "item.status != 'inactive'" or "item.age > 18"
func WithFilter(filter string) Option {
	return func(cfg *enginetask.Config) {
		cfg.Filter = filter
	}
}

// WithItemVar sets the ItemVar field
//
// ItemVar is the variable name for the current item (default: "item")
// Available in task templates as {{ .item }} or custom name
// - **Example**: Set to "user" to access as {{ .user }} in templates
func WithItemVar(itemVar string) Option {
	return func(cfg *enginetask.Config) {
		cfg.ItemVar = itemVar
	}
}

// WithIndexVar sets the IndexVar field
//
// IndexVar is the variable name for the current index (default: "index")
// Available in task templates as {{ .index }} or custom name
// Zero-based index of the current item
func WithIndexVar(indexVar string) Option {
	return func(cfg *enginetask.Config) {
		cfg.IndexVar = indexVar
	}
}

// WithMode sets the Mode field
//
// Mode determines if items are processed in parallel or sequentially
// Defaults to "parallel"
// Options: parallel, sequential
func WithMode(mode enginetask.CollectionMode) Option {
	return func(cfg *enginetask.Config) {
		cfg.Mode = mode
	}
}

// WithBatch sets the Batch field
//
// Batch size for processing items in groups (0 = no batching)
// Useful for rate limiting or managing resource usage
// - **Example**: 10 means process 10 items at a time
func WithBatch(batch int) Option {
	return func(cfg *enginetask.Config) {
		cfg.Batch = batch
	}
}

// WithSignal sets the Signal field
//
// Signal configuration containing the signal ID and payload
func WithSignal(signal *enginetask.SignalConfig) Option {
	return func(cfg *enginetask.Config) {
		cfg.Signal = signal
	}
}

// WithWaitFor sets the WaitFor field
//
// WaitFor specifies the signal ID to wait for
// The task will pause until a signal with this ID is received
// Must match the ID used in a SignalTask
// - **Example**: "user-approved", "payment-completed"
func WithWaitFor(waitFor string) Option {
	return func(cfg *enginetask.Config) {
		cfg.WaitFor = waitFor
	}
}

// WithProcessor sets the Processor field
//
// Processor is an optional task configuration to process received signals
// Allows custom handling of signal data before continuing
// The processor receives the signal payload as input
// $ref: inline:#
func WithProcessor(processor *enginetask.Config) Option {
	return func(cfg *enginetask.Config) {
		cfg.Processor = processor
	}
}

// WithOnTimeout sets the OnTimeout field
//
// OnTimeout specifies the next task to execute if the wait times out
// Uses the timeout value from BaseConfig
// If not specified, the task fails on timeout
func WithOnTimeout(onTimeout string) Option {
	return func(cfg *enginetask.Config) {
		cfg.OnTimeout = onTimeout
	}
}

// WithOperation sets the Operation field
//
// Operation type to perform on memory
// Required field that determines the action to take
func WithOperation(operation enginetask.MemoryOpType) Option {
	return func(cfg *enginetask.Config) {
		cfg.Operation = operation
	}
}

// WithMemoryRef sets the MemoryRef field
//
// MemoryRef identifies which memory store to use
// References a memory configuration defined at the project level
// - **Example**: "user-sessions", "workflow-state", "cache"
func WithMemoryRef(memoryRef string) Option {
	return func(cfg *enginetask.Config) {
		cfg.MemoryRef = memoryRef
	}
}

// WithKeyTemplate sets the KeyTemplate field
//
// KeyTemplate is a template expression for the memory key
// Supports template variables for dynamic key generation
// - **Example**: "user:{{ .workflow.input.user_id }}:profile"
func WithKeyTemplate(keyTemplate string) Option {
	return func(cfg *enginetask.Config) {
		cfg.KeyTemplate = keyTemplate
	}
}

// WithPayload sets the Payload field
//
// Payload data for write/append operations
// Can be any JSON-serializable data structure
// Required for write and append operations
func WithPayload(payload any) Option {
	return func(cfg *enginetask.Config) {
		cfg.Payload = payload
	}
}

// WithBatchSize sets the BatchSize field
//
// BatchSize for operations that process multiple keys
// Controls how many keys are processed in each batch
// Default: 100, Maximum: 10,000
func WithBatchSize(batchSize int) Option {
	return func(cfg *enginetask.Config) {
		cfg.BatchSize = batchSize
	}
}

// WithMaxKeys sets the MaxKeys field
//
// MaxKeys limits the number of keys processed
// Safety limit to prevent runaway operations
// Default: 1,000, Maximum: 50,000
func WithMaxKeys(maxKeys int) Option {
	return func(cfg *enginetask.Config) {
		cfg.MaxKeys = maxKeys
	}
}

// WithFlushConfig sets the FlushConfig field
//
// Configuration for flush operations
// Only used when operation is "flush"
func WithFlushConfig(flushConfig *enginetask.FlushConfig) Option {
	return func(cfg *enginetask.Config) {
		cfg.FlushConfig = flushConfig
	}
}

// WithHealthConfig sets the HealthConfig field
//
// Configuration for health check operations
// Only used when operation is "health"
func WithHealthConfig(healthConfig *enginetask.HealthConfig) Option {
	return func(cfg *enginetask.Config) {
		cfg.HealthConfig = healthConfig
	}
}

// WithStatsConfig sets the StatsConfig field
//
// Configuration for statistics operations
// Only used when operation is "stats"
func WithStatsConfig(statsConfig *enginetask.StatsConfig) Option {
	return func(cfg *enginetask.Config) {
		cfg.StatsConfig = statsConfig
	}
}

// WithClearConfig sets the ClearConfig field
//
// Configuration for clear operations
// Only used when operation is "clear"
func WithClearConfig(clearConfig *enginetask.ClearConfig) Option {
	return func(cfg *enginetask.Config) {
		cfg.ClearConfig = clearConfig
	}
}

// WithResource sets the Resource field
//
// Resource reference for the task
// Format: "compozy:task:<name>" (e.g., "compozy:task:process-data")
func WithResource(resource string) Option {
	return func(cfg *enginetask.Config) {
		cfg.Resource = resource
	}
}

// WithID sets the ID field
//
// Unique identifier for the task instance within a workflow
// Must be unique within the workflow scope
func WithID(id string) Option {
	return func(cfg *enginetask.Config) {
		cfg.ID = id
	}
}

// WithType sets the Type field
//
// Type of task that determines execution behavior
// If not specified, defaults to "basic"
func WithType(typeValue enginetask.Type) Option {
	return func(cfg *enginetask.Config) {
		cfg.Type = typeValue
	}
}

// WithConfig sets the Config field
//
// Global configuration options inherited from parent contexts
// Includes provider settings, API keys, and other global parameters
func WithConfig(config core.GlobalOpts) Option {
	return func(cfg *enginetask.Config) {
		cfg.Config = config
	}
}

// WithAgent sets the Agent field
//
// Agent configuration for AI-powered task execution
// Only used when the task needs to interact with an LLM agent
// Mutually exclusive with Tool field
// $ref: schema://agents
func WithAgent(agent *agent.Config) Option {
	return func(cfg *enginetask.Config) {
		cfg.Agent = agent
	}
}

// WithTool sets the Tool field
//
// Tool configuration for executing specific tool operations
// Used when the task needs to execute a predefined tool
// Mutually exclusive with Agent field
// $ref: schema://tools
func WithTool(tool *tool.Config) Option {
	return func(cfg *enginetask.Config) {
		cfg.Tool = tool
	}
}

// WithInputSchema sets the InputSchema field
//
// Schema definition for validating task input parameters
// Follows JSON Schema specification for type validation
// Format:
// type: object
// properties:
// user_id: { type: string, description: "User identifier" }
// required: ["user_id"]
func WithInputSchema(inputSchema *schema.Schema) Option {
	return func(cfg *enginetask.Config) {
		cfg.InputSchema = inputSchema
	}
}

// WithOutputSchema sets the OutputSchema field
//
// Schema definition for validating task output data
// Ensures task results conform to expected structure
// Uses same format as InputSchema
func WithOutputSchema(outputSchema *schema.Schema) Option {
	return func(cfg *enginetask.Config) {
		cfg.OutputSchema = outputSchema
	}
}

// WithWith sets the With field
//
// Input parameters passed to the task at execution time
// Can include references to workflow inputs, previous task outputs, etc.
// - **Example**: { "user_id": "{{ .workflow.input.user_id }}" }
func WithWith(with *core.Input) Option {
	return func(cfg *enginetask.Config) {
		cfg.With = with
	}
}

// WithOutputs sets the Outputs field
//
// Output mappings that define what data this task exposes to subsequent tasks
// Uses template expressions to transform task results
// - **Example**: { "processed_data": "{{ .task.output.result }}" }
func WithOutputs(outputs *core.Input) Option {
	return func(cfg *enginetask.Config) {
		cfg.Outputs = outputs
	}
}

// WithEnv sets the Env field
//
// Environment variables available during task execution
// Can override or extend workflow-level environment variables
// - **Example**: { "API_KEY": "{{ .env.SECRET_KEY }}" }
func WithEnv(env *core.EnvMap) Option {
	return func(cfg *enginetask.Config) {
		cfg.Env = env
	}
}

// WithKnowledge sets the Knowledge field
//
// Knowledge declares task-scoped knowledge bindings (MVP single binding).
func WithKnowledge(knowledge []core.KnowledgeBinding) Option {
	return func(cfg *enginetask.Config) {
		cfg.Knowledge = knowledge
	}
}

// WithOnSuccess sets the OnSuccess field
//
// Task execution control
// Defines what happens after successful task completion
// Can specify next task ID or conditional routing
func WithOnSuccess(onSuccess *core.SuccessTransition) Option {
	return func(cfg *enginetask.Config) {
		cfg.OnSuccess = onSuccess
	}
}

// WithOnError sets the OnError field
//
// Error handling configuration
// Defines fallback behavior when task execution fails
// Can specify error task ID or retry configuration
func WithOnError(onError *core.ErrorTransition) Option {
	return func(cfg *enginetask.Config) {
		cfg.OnError = onError
	}
}

// WithSleep sets the Sleep field
//
// Sleep duration after task completion
// Format: "5s", "1m", "500ms", "1h30m"
// Useful for rate limiting or giving external systems time to process
func WithSleep(sleep string) Option {
	return func(cfg *enginetask.Config) {
		cfg.Sleep = sleep
	}
}

// WithFinal sets the Final field
//
// Marks this task as a terminal node in the workflow
// No subsequent tasks will execute after a final task
func WithFinal(final bool) Option {
	return func(cfg *enginetask.Config) {
		cfg.Final = final
	}
}

// WithFilePath sets the FilePath field
//
// Absolute file path where this task configuration was loaded from
// Set automatically during configuration loading
func WithFilePath(filePath string) Option {
	return func(cfg *enginetask.Config) {
		cfg.FilePath = filePath
	}
}

// WithTimeout sets the Timeout field
//
// Maximum execution time for parallel or composite tasks
// Format: "30s", "5m", "1h"
// Task will be canceled if it exceeds this duration
func WithTimeout(timeout string) Option {
	return func(cfg *enginetask.Config) {
		cfg.Timeout = timeout
	}
}

// WithRetries sets the Retries field
//
// Number of retry attempts for failed task executions
// Default: 0 (no retries)
func WithRetries(retries int) Option {
	return func(cfg *enginetask.Config) {
		cfg.Retries = retries
	}
}

// WithCondition sets the Condition field
//
// CEL expression for conditional task execution or routing decisions
// Task only executes if condition evaluates to true
// - **Example**: "input.status == 'approved' && input.amount > 1000"
func WithCondition(condition string) Option {
	return func(cfg *enginetask.Config) {
		cfg.Condition = condition
	}
}

// WithAttachments sets the Attachments field
//
// Attachments declared at the task scope are available to all nested agents/actions.
func WithAttachments(attachments attachment.Attachments) Option {
	return func(cfg *enginetask.Config) {
		cfg.Attachments = attachments
	}
}

// WithTasks sets the Tasks field
//
// Tasks array for parallel, composite, and collection tasks
// Contains the list of sub-tasks to execute
// For parallel: tasks run concurrently
// For composite: tasks run sequentially
// For collection: not used (use Task field instead)
// $ref: inline:#
func WithTasks(tasks []enginetask.Config) Option {
	return func(cfg *enginetask.Config) {
		cfg.Tasks = tasks
	}
}

// WithTask sets the Task field
//
// Task template for collection tasks
// This configuration is replicated for each item in the collection
// The item and index are available as template variables
// $ref: inline:#
func WithTask(task *enginetask.Config) Option {
	return func(cfg *enginetask.Config) {
		cfg.Task = task
	}
}
