/*
  run-codex-pr-issues.ts

  Iterates all issue files under `ai-docs/reviews-pr-<PR>/issues` and, for each,
  invokes the Codex CLI with a single-issue prompt modeled after
  `.cursor/commands/pr-fix.md`.

  Usage:
    bun script/solve-pr-issues.ts --pr 259 [--issues-dir ai-docs/reviews-pr-259/issues] [--dry-run]

  Requirements:
  - Codex CLI installed and on PATH (codex >= 0.35)
  - Bun runtime
*/

import { existsSync, mkdirSync, readdirSync, readFileSync, writeFileSync } from "fs";
import { join, resolve } from "path";

type CLIArgs = {
  pr: string | null;
  issuesDir: string | null;
  dryRun: boolean;
};

type IssueEntry = {
  name: string; // filename inside issuesDir
  absPath: string;
  content: string;
  codeFile: string | null; // extracted code filepath from issue header
};

type IssueGroup = {
  codeFile: string; // repository-relative code file
  issues: IssueEntry[];
};

function parseArgs(argv: string[]): CLIArgs {
  let pr: string | null = null;
  let issuesDir: string | null = null;
  let dryRun = false;

  for (let i = 0; i < argv.length; i++) {
    const a = argv[i];
    if (a === "--pr") {
      pr = argv[++i] ?? null;
    } else if (a === "--issues-dir") {
      issuesDir = argv[++i] ?? null;
    } else if (a === "--dry-run") {
      dryRun = true;
    } else if (a === "-h" || a === "--help") {
      printHelpAndExit();
    }
  }

  return { pr, issuesDir, dryRun };
}

function printHelpAndExit(): never {
  console.log(
    "Usage: bun script/run-codex-pr-issues.ts --pr <number> [--issues-dir <path>] [--dry-run]"
  );
  process.exit(0);
}

function assertCodexExists() {
  const { success } = Bun.spawnSync(["bash", "-lc", "command -v codex >/dev/null 2>&1"]);
  if (!success) {
    console.error(
      "codex CLI not found on PATH. Install it from the openai/codex repo and try again."
    );
    process.exit(1);
  }
}

function assertExecSupported() {
  // Verify non-interactive mode is available
  const result = Bun.spawnSync(["bash", "-lc", "codex exec -h >/dev/null 2>&1"]);
  if (result.exitCode !== 0) {
    console.error(
      "Your codex CLI does not support 'codex exec'. Please update codex to a version with the exec subcommand."
    );
    process.exit(1);
  }
}

async function streamToString(stream?: ReadableStream | null): Promise<string> {
  if (!stream) return "";
  // Bun's ReadableStream can be consumed via Web Streams API
  return await new Response(stream as any).text();
}

async function tee(
  stream?: ReadableStream<Uint8Array> | null,
  outPath?: string,
  target: NodeJS.WriteStream = process.stdout
) {
  if (!stream || !outPath) return;
  const writer = Bun.file(outPath).writer();
  const reader = (stream as ReadableStream<Uint8Array>).getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    if (value && value.length) {
      await writer.write(value);
      target.write(value as any);
    }
  }
  await writer.end();
}

function readTemplateSafely(): string | null {
  try {
    return readFileSync(".cursor/commands/pr-fix.md", "utf8");
  } catch {
    return null;
  }
}

function buildSingleIssuePrompt(params: {
  pr: string;
  issuePath: string;
  issueContent: string;
  baseTemplate?: string | null;
}): string {
  const { pr, issuePath, issueContent, baseTemplate } = params;
  // Try to derive grouped file path from the issue content's **File:** header
  const codeFileInIssue = extractCodeFileFromIssue(issueContent);
  const groupedPath = `ai-docs/reviews-pr-${pr}/issues/grouped/${sanitizePath(
    codeFileInIssue ?? "unknown"
  )}.md`;

  const header = `<arguments>\n  <type>issue</type>\n  <pr>${pr}</pr>\n  <from>${issuePath}</from>\n</arguments>`;

  const criticalBlock = `
<critical>
- YOU NEED to fix the single issue from ${issuePath} in ai-docs/reviews-pr-${pr} and only finish when THIS ISSUE is fully addressed.
- Implement the best proper solution; do not use workarounds.
- YOU MUST follow project standards and rules in .cursor/rules and ensure all items in <arguments> are addressed.
- After making changes, update ONLY the progress files generated by pr-review for this PR:
  - ai-docs/reviews-pr-${pr}/issues/_summary.md
  - The specific issue file: ${issuePath}
  - If present, the grouped file under ai-docs/reviews-pr-${pr}/issues/grouped/ matching this issue's code file
- MUST DO: If this is a GitHub review issue, after resolving it you need to call the gh command to resolve the thread as per the issue instructions.
</critical>`;

  const body = `
<issue>
  <path>${issuePath}</path>
  <content lang="markdown">
${issueContent}
  </content>
</issue>

<task>
- Resolve ONLY the issue above (no batching). Apply code changes as needed and follow project standards.
- Update these tracking files: ai-docs/reviews-pr-${pr}/issues/_summary.md and ${issuePath}; also update the corresponding grouped file in ai-docs/reviews-pr-${pr}/issues/grouped/ if one exists.
- If a GitHub review thread ID is present, resolve it using gh per instructions in the issue.
- Run make fmt && make lint && make test before concluding this issue.
- If documentation updates are required, include them.
- If the issue is already solved (no code change required), you MUST still: update ai-docs/reviews-pr-${pr}/issues/_summary.md, mark ${issuePath} as RESOLVED ✓, and resolve the GitHub review thread using gh if a Thread ID is present.
</task>

<checklist>
  <title>Progress Files to Update</title>
  <path>ai-docs/reviews-pr-${pr}/issues/_summary.md</path>
  <path>${issuePath}</path>
  <path>${groupedPath}</path>
</checklist>
`;

  // If a base template exists, prepend it for additional context; otherwise, use our minimal prompt
  if (baseTemplate && baseTemplate.trim().length > 0) {
    return `${header}\n\n${criticalBlock}\n\n${body}`;
  }
  return `${header}\n\n${criticalBlock}\n\n${body}`;
}

function buildGroupedIssuesPrompt(params: {
  pr: string;
  codeFile: string;
  issues: { issuePath: string; issueContent: string }[];
  baseTemplate?: string | null;
}): string {
  const { pr, codeFile, issues, baseTemplate } = params;

  const header = `<arguments>\n  <type>issue-group</type>\n  <pr>${pr}</pr>\n  <file>${codeFile}</file>\n  <count>${issues.length}</count>\n</arguments>`;

  const criticalBlock = `
<critical>
- You MUST fix all issues listed below that refer to the same file: ${codeFile}.
- Implement proper solutions; do not use workarounds.
- Follow project standards in .cursor/rules and ensure changes are limited to addressing these issues in ${codeFile} (and strictly necessary dependencies like tests/types).
- After making changes, update ONLY the progress files generated by pr-review for this PR:
  - ai-docs/reviews-pr-${pr}/issues/_summary.md
  - Each included issue file under ai-docs/reviews-pr-${pr}/issues/
  - The grouped file for this set: ai-docs/reviews-pr-${pr}/issues/grouped/${sanitizePath(codeFile === "__unknown__" ? "unknown" : codeFile)}.md
- MUST DO: If these are GitHub review issues, after resolving them you need to call the gh command to resolve each thread as per the instructions in the issue files (look for a "Thread ID:" line and use the provided gh command).
</critical>`;

  const items = issues
    .map(
      (it, idx) => `
<issue index="${idx + 1}">
  <from>${it.issuePath}</from>
  <content lang="markdown">
${it.issueContent}
  </content>
</issue>`
    )
    .join("\n\n");

  const checklistPaths = [
    `ai-docs/reviews-pr-${pr}/issues/_summary.md`,
    `ai-docs/reviews-pr-${pr}/issues/grouped/${sanitizePath(codeFile === "__unknown__" ? "unknown" : codeFile)}.md`,
    ...issues.map(i => i.issuePath),
  ];

  const checklistBlock = `\n<checklist>\n  <title>Progress Files to Update</title>\n${checklistPaths
    .map(p => `  <path>${p}</path>`)
    .join("\n")}\n</checklist>\n`;

  const body = `
<issues-group file="${codeFile}">
${items}
</issues-group>

<task>
- Resolve ALL issues above for ${codeFile} in a cohesive set of changes.
- Update ai-docs/reviews-pr-${pr}/issues/_summary.md to reflect resolution status for each included issue.
- In each included issue file under ai-docs/reviews-pr-${pr}/issues, update the status section/checkbox to RESOLVED ✓ when addressed.
- Update the grouped tracking file at ai-docs/reviews-pr-${pr}/issues/grouped/${sanitizePath(codeFile === "__unknown__" ? "unknown" : codeFile)}.md to reflect the outcomes for the issues in this group.
- If a GitHub review thread ID is present in any issue, resolve it using gh as per the command snippet included in that issue.
- Run make fmt && make lint && make test before concluding this grouped task.
- If documentation updates are required, include them.
- For any included issue that is already solved (no code change required), you MUST still apply the progress updates above: update _summary.md, mark the specific issue file as RESOLVED ✓, and resolve its GitHub review thread via gh if a Thread ID is present.
</task>
${checklistBlock}`;

  if (baseTemplate && baseTemplate.trim().length > 0) {
    return `${header}\n\n${criticalBlock}\n\n${body}`;
  }
  return `${header}\n\n${criticalBlock}\n\n${body}`;
}

async function run() {
  const args = parseArgs(process.argv.slice(2));
  if (!args.pr && !args.issuesDir) printHelpAndExit();
  const pr = args.pr ?? inferPrFromIssuesDir(args.issuesDir!);
  const issuesDir = args.issuesDir ?? `ai-docs/reviews-pr-${pr}/issues`;

  const resolvedIssuesDir = resolve(issuesDir);
  if (!existsSync(resolvedIssuesDir)) {
    console.error(`Issues directory not found: ${resolvedIssuesDir}`);
    process.exit(1);
  }

  assertCodexExists();
  assertExecSupported();

  const template = readTemplateSafely();
  const issueFiles = readdirSync(resolvedIssuesDir, { withFileTypes: true })
    .filter(d => d.isFile() && d.name.endsWith(".md"))
    .map(d => d.name)
    .sort();

  if (issueFiles.length === 0) {
    console.log("No issue files found.");
    return;
  }

  // 1) Parse issues and group by code file
  const parsed: IssueEntry[] = issueFiles.map(name => {
    const absPath = join(resolvedIssuesDir, name);
    const content = readFileSync(absPath, "utf8");
    const codeFile = extractCodeFileFromIssue(content);
    return { name, absPath, content, codeFile } as IssueEntry;
  });

  const groupsMap = new Map<string, IssueEntry[]>();
  for (const it of parsed) {
    const key = it.codeFile ?? "__unknown__";
    if (!groupsMap.has(key)) groupsMap.set(key, []);
    groupsMap.get(key)!.push(it);
  }

  // 2) Create grouped/ folder with a summary file per code file
  const groupedDir = join(resolvedIssuesDir, "grouped");
  mkdirp(groupedDir);
  for (const [codeFile, items] of groupsMap.entries()) {
    const safeName = codeFile === "__unknown__" ? "unknown" : sanitizePath(codeFile);
    const groupFile = join(groupedDir, `${safeName}.md`);
    const header = `# Issue Group for ${codeFile === "__unknown__" ? "(unknown file)" : codeFile}\n\n`;
    const list = items.map(it => `- ${it.name}`).join("\n");
    const concat = items.map(it => `\n---\n\n## ${it.name}\n\n${it.content}`).join("");
    writeFileSync(groupFile, `${header}## Included Issues\n\n${list}\n${concat}\n`, "utf8");
  }

  // 3) Build prompts and execute Codex once per group
  const promptRoot = resolve(`.tmp/codex-prompts/pr-${pr}`);
  mkdirp(promptRoot);

  for (const [codeFile, items] of groupsMap.entries()) {
    const safeName = codeFile === "__unknown__" ? "unknown" : sanitizePath(codeFile);
    const relIssuePaths = items.map(it => normalizeForPrompt(it.absPath));
    const prompt = buildGroupedIssuesPrompt({
      pr,
      codeFile,
      issues: items.map((it, i) => ({ issuePath: relIssuePaths[i], issueContent: it.content })),
      baseTemplate: template,
    });

    const outPromptPath = join(promptRoot, `${safeName}.prompt.md`);
    writeFileSync(outPromptPath, prompt, "utf8");

    const shellCmd = `codex --full-auto -m gpt-5 -c model_reasoning_effort=medium exec - < ${JSON.stringify(
      outPromptPath
    ).slice(1, -1)}`;
    const outLog = join(promptRoot, `${safeName}.out.log`);
    const errLog = join(promptRoot, `${safeName}.err.log`);

    console.log("\n=== Running Codex (headless) for group:", codeFile, `(${items.length} issues)`);
    console.log("$", shellCmd);
    if (args.dryRun) continue;

    const child = Bun.spawn(["bash", "-lc", shellCmd], { stdio: ["ignore", "pipe", "pipe"] });
    await Promise.all([
      tee(child.stdout as any, outLog, process.stdout),
      tee(child.stderr as any, errLog, process.stderr),
    ]);
    const exit = await child.exited;
    if (exit !== 0) {
      console.error(
        `Codex exited with code ${exit} for group ${codeFile}. See logs: ${outLog}, ${errLog}`
      );
    }
  }
}

function normalizeForPrompt(absPath: string): string {
  // Prefer workspace-relative path from CWD
  const cwd = process.cwd();
  return absPath.startsWith(cwd) ? absPath.slice(cwd.length + 1) : absPath;
}

function mkdirp(pathname: string) {
  if (existsSync(pathname)) return;
  mkdirSync(pathname, { recursive: true });
}

function inferPrFromIssuesDir(dir: string): string {
  const m = dir.match(/reviews-pr-(\d+)/);
  if (!m) {
    console.error("Unable to infer PR number from issues dir. Use --pr <number>.");
    process.exit(1);
  }
  return m[1];
}

function extractCodeFileFromIssue(content: string): string | null {
  // Expected pattern: **File:** `path/to/file.tsx:123`
  const m = content.match(/\*\*File:\*\*\s*`([^`]+)`/);
  if (!m) return null;
  const raw = m[1].trim();
  // Strip trailing :line if present
  const m2 = raw.match(/^(.*?):\d+\s*$/);
  return (m2 ? m2[1] : raw).trim();
}

function sanitizePath(p: string): string {
  return p.replace(/[^a-zA-Z0-9._-]+/g, "_");
}

run().catch(err => {
  console.error(err);
  process.exit(1);
});
