package test

import (
	"testing"

	"github.com/compozy/compozy/engine/common"
	"github.com/compozy/compozy/engine/domain/agent"
	"github.com/compozy/compozy/engine/state"
	"github.com/compozy/compozy/pkg/nats"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestAgentStateInitialization(t *testing.T) {
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentAgent})
	defer tb.Cleanup()

	corrID := common.NewCorrID()
	workflowExecID := common.NewExecID()
	taskExecID := common.NewExecID()

	taskEnv := common.EnvMap{
		"TASK_KEY":     "task_val",
		"OVERRIDE_KEY": "task_override",
		"SHARED_ENV":   "from_task_env",
	}
	agentEnv := common.EnvMap{
		"AGENT_KEY":    "agent_val",
		"OVERRIDE_KEY": "agent_override",
		"FROM_TRIGGER": "{{ .trigger.input.data.value }}",
		"FROM_INPUT":   "{{ .input.agent_param }}",
		"FROM_ENV":     "{{ .env.SHARED_ENV }}",
	}
	triggerData := common.Input{
		"data": map[string]any{
			"value": "trigger_data_value",
		},
	}
	taskData := common.Input{
		"task_param":   "task_input_value",
		"COMMON_PARAM": "task_common_val",
	}
	agentData := common.Input{
		"agent_param":          "agent_input_value",
		"COMMON_PARAM":         "agent_common_val",
		"AGENT_TEMPLATE_PARAM": "{{ .trigger.input.data.value }}",
	}

	exec := agent.NewExecution(
		corrID,
		taskExecID,
		workflowExecID,
		taskEnv,
		agentEnv,
		&triggerData,
		&taskData,
		&agentData,
	)
	require.NotNil(t, exec, "Agent execution should not be nil")
	agentExecID := exec.AgentExecID
	require.NotEmpty(t, agentExecID, "AgentExecID should be generated by NewExecution")

	agentState, err := agent.NewAgentState(exec)
	require.NoError(t, err)
	require.NotNil(t, agentState)

	t.Run("Should correctly initialize IDs and default status", func(t *testing.T) {
		assert.Equal(t, corrID, agentState.GetID().CorrID)
		assert.Equal(t, workflowExecID, agentState.WorkflowExecID)
		assert.Equal(t, taskExecID, agentState.TaskExecID)
		assert.Equal(t, agentExecID, agentState.AgentExecID)
		assert.Equal(t, agentExecID, agentState.GetID().ExecID)
		assert.Equal(t, nats.StatusPending, agentState.GetStatus())
	})

	t.Run("Should merge environments with agent env taking precedence and resolve templates", func(t *testing.T) {
		expectedEnv := common.EnvMap{
			"TASK_KEY":     "task_val",
			"AGENT_KEY":    "agent_val",
			"OVERRIDE_KEY": "agent_override",
			"SHARED_ENV":   "from_task_env",
			"FROM_TRIGGER": "trigger_data_value",
			"FROM_INPUT":   "agent_input_value",
			"FROM_ENV":     "from_task_env",
		}
		require.NotNil(t, agentState.GetEnv(), "Env should not be nil")
		assert.Equal(t, expectedEnv, *agentState.GetEnv())
	})

	t.Run("Should merge inputs with task input taking precedence and resolve templates", func(t *testing.T) {
		expectedInput := common.Input{
			"task_param":           "task_input_value",
			"agent_param":          "agent_input_value",
			"COMMON_PARAM":         "task_common_val",
			"AGENT_TEMPLATE_PARAM": "trigger_data_value",
		}
		require.NotNil(t, agentState.GetInput(), "Input should not be nil")
		assert.Equal(t, expectedInput, *agentState.GetInput())
	})

	t.Run("Should correctly initialize Trigger and Output", func(t *testing.T) {
		require.NotNil(t, agentState.GetTrigger(), "Trigger should not be nil")
		assert.Equal(t, triggerData, *agentState.GetTrigger())

		require.NotNil(t, agentState.GetOutput(), "Output should be initialized")
		assert.Empty(t, *agentState.GetOutput(), "Output should be empty initially")
	})
}

func TestAgentStatePersistence(t *testing.T) {
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentAgent})
	defer tb.Cleanup()
	stateManager := tb.StateManager

	t.Run("Should persist state and allow accurate retrieval", func(t *testing.T) {
		corrID := common.NewCorrID()
		workflowExecID := common.NewExecID()
		taskExecID := common.NewExecID()

		taskEnv := common.EnvMap{
			"k1": "v1_task",
		}
		agentEnv := common.EnvMap{
			"k2": "v2_agent",
		}
		triggerData := common.Input{
			"trigger": "data",
		}
		taskData := common.Input{
			"task": "data",
		}
		agentData := common.Input{
			"agent": "data",
		}

		exec := agent.NewExecution(
			corrID, taskExecID, workflowExecID, taskEnv, agentEnv,
			&triggerData, &taskData, &agentData,
		)
		require.NotNil(t, exec)
		agentExecID := exec.AgentExecID

		originalAgentState, err := agent.NewAgentState(exec)
		require.NoError(t, err)
		require.NotNil(t, originalAgentState)

		err = stateManager.SaveState(originalAgentState)
		require.NoError(t, err)

		retrievedStateInterface, err := stateManager.GetAgentState(corrID, agentExecID)
		require.NoError(t, err)
		require.NotNil(t, retrievedStateInterface)

		retrievedBaseState, ok := retrievedStateInterface.(*state.BaseState)
		require.True(t, ok, "Retrieved state should be of type *state.BaseState")

		assert.Equal(t, originalAgentState.GetID(), retrievedBaseState.GetID())
		assert.Equal(t, nats.ComponentAgent, retrievedBaseState.GetID().Component)
		assert.Equal(t, originalAgentState.GetStatus(), retrievedBaseState.GetStatus())
		assert.Equal(t, *originalAgentState.GetEnv(), *retrievedBaseState.GetEnv())
		assert.Equal(t, *originalAgentState.GetTrigger(), *retrievedBaseState.GetTrigger())
		assert.Equal(t, *originalAgentState.GetInput(), *retrievedBaseState.GetInput())
		assert.Equal(t, *originalAgentState.GetOutput(), *retrievedBaseState.GetOutput())
	})
}

func TestAgentStateUpdates(t *testing.T) {
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentAgent})
	defer tb.Cleanup()
	stateManager := tb.StateManager

	t.Run("Should reflect updates to status and output after saving", func(t *testing.T) {
		corrID := common.NewCorrID()
		workflowExecID := common.NewExecID()
		taskExecID := common.NewExecID()

		taskEnv := common.EnvMap{
			"k1": "v1_task_update",
		}
		agentEnv := common.EnvMap{
			"k2": "v2_agent_update",
		}
		triggerData := common.Input{
			"trigger_update": "data",
		}
		taskData := common.Input{
			"task_update": "data",
		}
		agentData := common.Input{
			"agent_update": "data",
		}

		exec := agent.NewExecution(
			corrID, taskExecID, workflowExecID, taskEnv, agentEnv,
			&triggerData, &taskData, &agentData,
		)
		require.NotNil(t, exec)
		agentExecID := exec.AgentExecID

		agentStateInstance, err := agent.NewAgentState(exec)
		require.NoError(t, err)
		require.NotNil(t, agentStateInstance)

		err = stateManager.SaveState(agentStateInstance)
		require.NoError(t, err)

		agentStateInstance.SetStatus(nats.StatusSuccess)
		newOutputData := common.Output{
			"result": "agent_done",
			"detail": "all good",
		}
		agentStateInstance.BaseState.Output = &newOutputData

		err = stateManager.SaveState(agentStateInstance)
		require.NoError(t, err)

		retrievedStateInterface, err := stateManager.GetAgentState(corrID, agentExecID)
		require.NoError(t, err)
		require.NotNil(t, retrievedStateInterface)

		retrievedBaseState, ok := retrievedStateInterface.(*state.BaseState)
		require.True(t, ok, "Retrieved state should be of type *state.BaseState")

		assert.Equal(t, nats.StatusSuccess, retrievedBaseState.GetStatus())
		require.NotNil(t, retrievedBaseState.GetOutput())
		assert.Equal(t, newOutputData, *retrievedBaseState.GetOutput())
		assert.Equal(t, *agentStateInstance.GetEnv(), *retrievedBaseState.GetEnv())
	})
}
