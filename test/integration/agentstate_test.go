package test

import (
	"testing"

	"github.com/compozy/compozy/engine/common"
	"github.com/compozy/compozy/engine/domain/agent"
	"github.com/compozy/compozy/engine/state"
	"github.com/compozy/compozy/pkg/nats"
	pbagent "github.com/compozy/compozy/pkg/pb/agent"
	pbcommon "github.com/compozy/compozy/pkg/pb/common"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	structpb "google.golang.org/protobuf/types/known/structpb"
)

func createIDs() (*common.ID, *common.ID, *common.ID, error) {
	corrID, err := common.NewID()
	if err != nil {
		return nil, nil, nil, err
	}
	workflowExecID, err := common.NewID()
	if err != nil {
		return nil, nil, nil, err
	}
	taskExecID, err := common.NewID()
	if err != nil {
		return nil, nil, nil, err
	}
	return &corrID, &workflowExecID, &taskExecID, nil
}

func TestAgentStateInitialization(t *testing.T) {
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentAgent})
	defer tb.Cleanup()

	corrID, workflowExecID, taskExecID, err := createIDs()
	require.NoError(t, err)

	taskEnv := common.EnvMap{
		"TASK_KEY":     "task_val",
		"OVERRIDE_KEY": "task_override",
		"SHARED_ENV":   "from_task_env",
	}
	agentEnv := common.EnvMap{
		"AGENT_KEY":    "agent_val",
		"OVERRIDE_KEY": "agent_override",
		"FROM_TRIGGER": "{{ .trigger.input.data.value }}",
		"FROM_INPUT":   "{{ .input.agent_param }}",
		"FROM_ENV":     "{{ .env.SHARED_ENV }}",
	}
	triggerData := common.Input{
		"data": map[string]any{
			"value": "trigger_data_value",
		},
	}
	taskData := common.Input{
		"task_param":   "task_input_value",
		"COMMON_PARAM": "task_common_val",
	}
	agentData := common.Input{
		"agent_param":          "agent_input_value",
		"COMMON_PARAM":         "agent_common_val",
		"AGENT_TEMPLATE_PARAM": "{{ .trigger.input.data.value }}",
	}

	exec, err := agent.NewExecution(
		*corrID,
		*taskExecID,
		*workflowExecID,
		taskEnv,
		agentEnv,
		&triggerData,
		&taskData,
		&agentData,
	)
	require.NoError(t, err)
	require.NotNil(t, exec, "Agent execution should not be nil")
	agentExecID := exec.AgentExecID
	require.NotEmpty(t, agentExecID, "AgentExecID should be generated by NewExecution")

	agentState, err := agent.NewAgentState(exec)
	require.NoError(t, err)
	require.NotNil(t, agentState)

	t.Run("Should correctly initialize IDs and default status", func(t *testing.T) {
		assert.Equal(t, *corrID, agentState.GetID().CorrID)
		assert.Equal(t, *workflowExecID, agentState.WorkflowExecID)
		assert.Equal(t, *taskExecID, agentState.TaskExecID)
		assert.Equal(t, agentExecID, agentState.AgentExecID)
		assert.Equal(t, agentExecID, agentState.GetID().ExecID)
		assert.Equal(t, nats.StatusPending, agentState.GetStatus())
	})

	t.Run("Should merge environments with agent env taking precedence and resolve templates", func(t *testing.T) {
		expectedEnv := common.EnvMap{
			"TASK_KEY":     "task_val",
			"AGENT_KEY":    "agent_val",
			"OVERRIDE_KEY": "agent_override",
			"SHARED_ENV":   "from_task_env",
			"FROM_TRIGGER": "trigger_data_value",
			"FROM_INPUT":   "agent_input_value",
			"FROM_ENV":     "from_task_env",
		}
		require.NotNil(t, agentState.GetEnv(), "Env should not be nil")
		assert.Equal(t, expectedEnv, *agentState.GetEnv())
	})

	t.Run("Should merge inputs with task input taking precedence and resolve templates", func(t *testing.T) {
		expectedInput := common.Input{
			"task_param":           "task_input_value",
			"agent_param":          "agent_input_value",
			"COMMON_PARAM":         "task_common_val",
			"AGENT_TEMPLATE_PARAM": "trigger_data_value",
		}
		require.NotNil(t, agentState.GetInput(), "Input should not be nil")
		assert.Equal(t, expectedInput, *agentState.GetInput())
	})

	t.Run("Should correctly initialize Trigger and Output", func(t *testing.T) {
		require.NotNil(t, agentState.GetTrigger(), "Trigger should not be nil")
		assert.Equal(t, triggerData, *agentState.GetTrigger())

		require.NotNil(t, agentState.GetOutput(), "Output should be initialized")
		assert.Empty(t, *agentState.GetOutput(), "Output should be empty initially")
	})
}

func TestAgentStatePersistence(t *testing.T) {
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentAgent})
	defer tb.Cleanup()
	stateManager := tb.StateManager

	corrID, workflowExecID, taskExecID, err := createIDs()
	require.NoError(t, err)

	t.Run("Should persist state and allow accurate retrieval", func(t *testing.T) {
		taskEnv := common.EnvMap{
			"k1": "v1_task",
		}
		agentEnv := common.EnvMap{
			"k2": "v2_agent",
		}
		triggerData := common.Input{
			"trigger": "data",
		}
		taskData := common.Input{
			"task": "data",
		}
		agentData := common.Input{
			"agent": "data",
		}

		exec, err := agent.NewExecution(
			*corrID, *taskExecID, *workflowExecID, taskEnv, agentEnv,
			&triggerData, &taskData, &agentData,
		)
		require.NoError(t, err)
		require.NotNil(t, exec)
		agentExecID := exec.AgentExecID

		originalAgentState, err := agent.NewAgentState(exec)
		require.NoError(t, err)
		require.NotNil(t, originalAgentState)

		err = stateManager.SaveState(originalAgentState)
		require.NoError(t, err)

		retrievedStateInterface, err := stateManager.GetAgentState(*corrID, agentExecID)
		require.NoError(t, err)
		require.NotNil(t, retrievedStateInterface)

		retrievedBaseState, ok := retrievedStateInterface.(*state.BaseState)
		require.True(t, ok, "Retrieved state should be of type *state.BaseState")

		assert.Equal(t, originalAgentState.GetID(), retrievedBaseState.GetID())
		assert.Equal(t, nats.ComponentAgent, retrievedBaseState.GetID().Component)
		assert.Equal(t, originalAgentState.GetStatus(), retrievedBaseState.GetStatus())
		assert.Equal(t, *originalAgentState.GetEnv(), *retrievedBaseState.GetEnv())
		assert.Equal(t, *originalAgentState.GetTrigger(), *retrievedBaseState.GetTrigger())
		assert.Equal(t, *originalAgentState.GetInput(), *retrievedBaseState.GetInput())
		assert.Equal(t, *originalAgentState.GetOutput(), *retrievedBaseState.GetOutput())
	})
}

func TestAgentStateUpdates(t *testing.T) {
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentAgent})
	defer tb.Cleanup()
	stateManager := tb.StateManager

	corrID, workflowExecID, taskExecID, err := createIDs()
	require.NoError(t, err)

	t.Run("Should reflect updates to status and output after saving", func(t *testing.T) {
		taskEnv := common.EnvMap{
			"k1": "v1_task_update",
		}
		agentEnv := common.EnvMap{
			"k2": "v2_agent_update",
		}
		triggerData := common.Input{
			"trigger_update": "data",
		}
		taskData := common.Input{
			"task_update": "data",
		}
		agentData := common.Input{
			"agent_update": "data",
		}

		exec, err := agent.NewExecution(
			*corrID, *taskExecID, *workflowExecID, taskEnv, agentEnv,
			&triggerData, &taskData, &agentData,
		)
		require.NoError(t, err)
		require.NotNil(t, exec)
		agentExecID := exec.AgentExecID

		agentStateInstance, err := agent.NewAgentState(exec)
		require.NoError(t, err)
		require.NotNil(t, agentStateInstance)

		err = stateManager.SaveState(agentStateInstance)
		require.NoError(t, err)

		agentStateInstance.SetStatus(nats.StatusSuccess)
		newOutputData := common.Output{
			"result": "agent_done",
			"detail": "all good",
		}
		agentStateInstance.Output = &newOutputData

		err = stateManager.SaveState(agentStateInstance)
		require.NoError(t, err)

		retrievedStateInterface, err := stateManager.GetAgentState(*corrID, agentExecID)
		require.NoError(t, err)
		require.NotNil(t, retrievedStateInterface)

		retrievedBaseState, ok := retrievedStateInterface.(*state.BaseState)
		require.True(t, ok, "Retrieved state should be of type *state.BaseState")

		assert.Equal(t, nats.StatusSuccess, retrievedBaseState.GetStatus())
		require.NotNil(t, retrievedBaseState.GetOutput())
		assert.Equal(t, newOutputData, *retrievedBaseState.GetOutput())
		assert.Equal(t, *agentStateInstance.GetEnv(), *retrievedBaseState.GetEnv())
	})
}

func TestAgentStateUpdateFromEvent(t *testing.T) {
	// Setup
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentAgent})
	defer tb.Cleanup()
	stateManager := tb.StateManager

	// Create an agent execution for testing
	corrID, workflowExecID, taskExecID, err := createIDs()
	require.NoError(t, err)

	taskEnv := common.EnvMap{"TASK_ENV": "task_value"}
	agentEnv := common.EnvMap{"AGENT_ENV": "agent_value"}

	triggerInput := &common.Input{"trigger_key": "trigger_value"}
	taskInput := &common.Input{"task_key": "task_value"}
	agentInput := &common.Input{"agent_key": "agent_value"}

	exec, err := agent.NewExecution(
		*corrID,
		*taskExecID,
		*workflowExecID,
		taskEnv,
		agentEnv,
		triggerInput,
		taskInput,
		agentInput,
	)
	require.NoError(t, err)
	require.NotNil(t, exec)

	agentState, err := agent.NewAgentState(exec)
	require.NoError(t, err)
	require.NotNil(t, agentState)

	// Save initial state
	err = stateManager.SaveState(agentState)
	require.NoError(t, err)
	assert.Equal(t, nats.StatusPending, agentState.Status)

	// Test cases for each event type
	t.Run("Should update status to Running when receiving AgentExecutionStartedEvent", func(t *testing.T) {
		event := &pbagent.AgentExecutionStartedEvent{
			Metadata: &pbcommon.Metadata{
				CorrelationId: corrID.String(),
			},
			Agent: &pbcommon.AgentInfo{
				Id:     "agent-id",
				ExecId: exec.AgentExecID.String(),
			},
			Task: &pbcommon.TaskInfo{
				Id:     "task-id",
				ExecId: taskExecID.String(),
			},
			Workflow: &pbcommon.WorkflowInfo{
				Id:     "workflow-id",
				ExecId: workflowExecID.String(),
			},
		}

		err := agentState.UpdateFromEvent(event)
		require.NoError(t, err)
		assert.Equal(t, nats.StatusRunning, agentState.Status)

		// Save and verify
		err = stateManager.SaveState(agentState)
		require.NoError(t, err)

		retrievedState, err := stateManager.GetAgentState(*corrID, exec.AgentExecID)
		require.NoError(t, err)
		assert.Equal(t, nats.StatusRunning, retrievedState.GetStatus())
	})

	t.Run("Should update both status and output when receiving AgentExecutionSuccessEvent with Result", func(t *testing.T) {
		// Create a structpb.Struct with test data
		resultData, err := structpb.NewStruct(map[string]interface{}{
			"message": "Agent completed successfully",
			"count":   42,
			"tokens":  2500,
			"details": map[string]any{
				"model":   "gpt-4",
				"latency": 1200,
			},
		})
		require.NoError(t, err)

		// Create success event with result
		event := &pbagent.AgentExecutionSuccessEvent{
			Metadata: &pbcommon.Metadata{
				CorrelationId: corrID.String(),
			},
			Agent: &pbcommon.AgentInfo{
				Id:     "agent-id",
				ExecId: exec.AgentExecID.String(),
			},
			Task: &pbcommon.TaskInfo{
				Id:     "task-id",
				ExecId: taskExecID.String(),
			},
			Workflow: &pbcommon.WorkflowInfo{
				Id:     "workflow-id",
				ExecId: workflowExecID.String(),
			},
			Payload: &pbagent.AgentExecutionSuccessEvent_Payload{
				Result: &pbcommon.Result{
					Output: resultData,
				},
			},
		}

		// Apply the event
		err = agentState.UpdateFromEvent(event)
		require.NoError(t, err)

		// Verify status update
		assert.Equal(t, nats.StatusSuccess, agentState.Status)

		// Verify output update
		require.NotNil(t, agentState.Output)
		assert.Equal(t, "Agent completed successfully", (*agentState.Output)["message"])
		assert.Equal(t, float64(42), (*agentState.Output)["count"])
		assert.Equal(t, float64(2500), (*agentState.Output)["tokens"])

		// Verify nested map is correctly converted
		details, ok := (*agentState.Output)["details"].(map[string]interface{})
		require.True(t, ok, "details should be a map")
		assert.Equal(t, "gpt-4", details["model"])
		assert.Equal(t, float64(1200), details["latency"])

		// Save and verify
		err = stateManager.SaveState(agentState)
		require.NoError(t, err)

		retrievedState, err := stateManager.GetAgentState(*corrID, exec.AgentExecID)
		require.NoError(t, err)
		assert.Equal(t, nats.StatusSuccess, retrievedState.GetStatus())

		// Verify output was saved correctly
		output := retrievedState.GetOutput()
		require.NotNil(t, output)
		assert.Equal(t, "Agent completed successfully", (*output)["message"])
	})

	t.Run("Should update both status and error output when receiving AgentExecutionFailedEvent with Error", func(t *testing.T) {
		// Create a new agent state for this test
		newExec, err := agent.NewExecution(
			*corrID,
			*taskExecID,
			*workflowExecID,
			taskEnv,
			agentEnv,
			triggerInput,
			taskInput,
			agentInput,
		)
		require.NoError(t, err)
		require.NotNil(t, newExec)
		newAgentState, err := agent.NewAgentState(newExec)
		require.NoError(t, err)
		require.NotNil(t, newAgentState)
		err = stateManager.SaveState(newAgentState)
		require.NoError(t, err)

		// Create error details struct
		errorDetails, err := structpb.NewStruct(map[string]interface{}{
			"model":   "gpt-4",
			"context": "LLM API call failed",
			"retry":   2,
		})
		require.NoError(t, err)

		// Create error code value
		errorCode := "ERR_AGENT_FAILED"

		// Create failed event with error result
		event := &pbagent.AgentExecutionFailedEvent{
			Metadata: &pbcommon.Metadata{
				CorrelationId: corrID.String(),
			},
			Agent: &pbcommon.AgentInfo{
				Id:     "agent-id",
				ExecId: newExec.AgentExecID.String(),
			},
			Task: &pbcommon.TaskInfo{
				Id:     "task-id",
				ExecId: taskExecID.String(),
			},
			Workflow: &pbcommon.WorkflowInfo{
				Id:     "workflow-id",
				ExecId: workflowExecID.String(),
			},
			Payload: &pbagent.AgentExecutionFailedEvent_Payload{
				Result: &pbcommon.Result{
					Error: &pbcommon.ErrorResult{
						Message: "Agent execution failed",
						Code:    &errorCode,
						Details: errorDetails,
					},
				},
			},
		}

		// Apply the event
		err = newAgentState.UpdateFromEvent(event)
		require.NoError(t, err)

		// Verify status update
		assert.Equal(t, nats.StatusFailed, newAgentState.Status)

		// Verify error details
		require.NotNil(t, newAgentState.Error)
		assert.Equal(t, "Agent execution failed", newAgentState.Error.Message)
		assert.Equal(t, errorCode, newAgentState.Error.Code)

		// Verify error details are correctly stored
		require.NotNil(t, newAgentState.Error.Details)
		assert.Equal(t, "gpt-4", newAgentState.Error.Details["model"])
		assert.Equal(t, "LLM API call failed", newAgentState.Error.Details["context"])
		assert.Equal(t, float64(2), newAgentState.Error.Details["retry"])

		// Verify output is nil when there's an error
		assert.Nil(t, newAgentState.Output)

		// Save and verify
		err = stateManager.SaveState(newAgentState)
		require.NoError(t, err)

		retrievedState, err := stateManager.GetAgentState(*corrID, newExec.AgentExecID)
		require.NoError(t, err)
		assert.Equal(t, nats.StatusFailed, retrievedState.GetStatus())

		// Verify error was saved correctly
		errRes := retrievedState.GetError()
		require.NotNil(t, errRes)
		assert.Equal(t, "Agent execution failed", errRes.Message)
		assert.Equal(t, errorCode, errRes.Code)
	})

	t.Run("Should return error when receiving unsupported event type", func(t *testing.T) {
		unsupportedEvent := struct{}{}
		err := agentState.UpdateFromEvent(unsupportedEvent)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "unsupported event type")
	})
}
