package test

import (
	"testing"

	"github.com/compozy/compozy/engine/common"
	"github.com/compozy/compozy/engine/domain/tool"
	"github.com/compozy/compozy/engine/state"
	"github.com/compozy/compozy/pkg/nats"
	pbcommon "github.com/compozy/compozy/pkg/pb/common"
	pbtool "github.com/compozy/compozy/pkg/pb/tool"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	structpb "google.golang.org/protobuf/types/known/structpb"
)

func TestToolStateInitialization(t *testing.T) {
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentTool})
	defer tb.Cleanup()

	corrID := common.NewCorrID()
	workflowExecID := common.NewExecID()
	taskExecID := common.NewExecID()

	taskEnv := common.EnvMap{
		"TASK_KEY":     "task_val",
		"OVERRIDE_KEY": "task_override",
		"SHARED_ENV":   "from_task_env",
	}
	toolEnv := common.EnvMap{
		"TOOL_KEY":     "tool_val",
		"OVERRIDE_KEY": "tool_override",
		"FROM_TRIGGER": "{{ .trigger.input.data.value }}",
		"FROM_INPUT":   "{{ .input.tool_param }}",
		"FROM_ENV":     "{{ .env.SHARED_ENV }}",
	}
	triggerData := common.Input{
		"data": map[string]any{
			"value": "trigger_data_value",
		},
	}
	taskData := common.Input{
		"task_param":   "task_input_value",
		"COMMON_PARAM": "task_common_val",
	}
	toolData := common.Input{
		"tool_param":          "tool_input_value",
		"COMMON_PARAM":        "tool_common_val",
		"TOOL_TEMPLATE_PARAM": "{{ .trigger.input.data.value }}",
	}

	exec := tool.NewStateParams(
		corrID,
		taskExecID,
		workflowExecID,
		taskEnv,
		toolEnv,
		&triggerData,
		&taskData,
		&toolData,
	)
	require.NotNil(t, exec, "Tool execution should not be nil")
	toolExecID := exec.ExecID
	require.NotEmpty(t, toolExecID, "ToolExecID should be generated by NewExecution")

	toolState, err := tool.NewToolState(exec)
	require.NoError(t, err)
	require.NotNil(t, toolState)

	t.Run("Should correctly initialize IDs and default status", func(t *testing.T) {
		assert.Equal(t, corrID, toolState.GetID().CorrID)
		assert.Equal(t, workflowExecID, toolState.WorkflowExecID)
		assert.Equal(t, taskExecID, toolState.TaskExecID)
		assert.Equal(t, toolExecID, toolState.ToolExecID)
		assert.Equal(t, toolExecID, toolState.GetID().ExecID)
		assert.Equal(t, nats.StatusPending, toolState.GetStatus())
	})

	t.Run("Should merge environments with tool env taking precedence and resolve templates", func(t *testing.T) {
		expectedEnv := common.EnvMap{
			"TASK_KEY":     "task_val",
			"TOOL_KEY":     "tool_val",
			"OVERRIDE_KEY": "tool_override",
			"SHARED_ENV":   "from_task_env",
			"FROM_TRIGGER": "trigger_data_value",
			"FROM_INPUT":   "tool_input_value",
			"FROM_ENV":     "from_task_env",
		}
		require.NotNil(t, toolState.GetEnv(), "Env should not be nil")
		assert.Equal(t, expectedEnv, *toolState.GetEnv())
	})

	t.Run("Should merge inputs with task input taking precedence and resolve templates", func(t *testing.T) {
		expectedInput := common.Input{
			"task_param":          "task_input_value",
			"tool_param":          "tool_input_value",
			"COMMON_PARAM":        "task_common_val",
			"TOOL_TEMPLATE_PARAM": "trigger_data_value",
		}
		require.NotNil(t, toolState.GetInput(), "Input should not be nil")
		assert.Equal(t, expectedInput, *toolState.GetInput())
	})

	t.Run("Should correctly initialize Trigger and Output", func(t *testing.T) {
		require.NotNil(t, toolState.GetTrigger(), "Trigger should not be nil")
		assert.Equal(t, triggerData, *toolState.GetTrigger())

		require.NotNil(t, toolState.GetOutput(), "Output should be initialized")
		assert.Empty(t, *toolState.GetOutput(), "Output should be empty initially")
	})
}

func TestToolStatePersistence(t *testing.T) {
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentTool})
	defer tb.Cleanup()
	stateManager := tb.StateManager

	t.Run("Should persist state and allow accurate retrieval", func(t *testing.T) {
		corrID := common.NewCorrID()
		workflowExecID := common.NewExecID()
		taskExecID := common.NewExecID()

		taskEnv := common.EnvMap{
			"k1_task": "v1",
		}
		toolEnv := common.EnvMap{
			"k1_tool": "v2",
		}
		triggerData := common.Input{
			"trigger_persist": "data",
		}
		taskData := common.Input{
			"task_persist": "data",
		}
		toolData := common.Input{
			"tool_persist": "data",
		}

		exec := tool.NewStateParams(
			corrID, taskExecID, workflowExecID, taskEnv, toolEnv,
			&triggerData, &taskData, &toolData,
		)
		require.NotNil(t, exec)
		toolExecID := exec.ExecID

		originalToolState, err := tool.NewToolState(exec)
		require.NoError(t, err)
		require.NotNil(t, originalToolState)

		err = stateManager.SaveState(originalToolState)
		require.NoError(t, err)

		retrievedStateInterface, err := stateManager.GetToolState(corrID, toolExecID)
		require.NoError(t, err)
		require.NotNil(t, retrievedStateInterface)

		retrievedBaseState, ok := retrievedStateInterface.(*state.BaseState)
		require.True(t, ok, "Retrieved state should be of type *state.BaseState")

		assert.Equal(t, originalToolState.GetID(), retrievedBaseState.GetID())
		assert.Equal(t, nats.ComponentTool, retrievedBaseState.GetID().Component)
		assert.Equal(t, originalToolState.GetStatus(), retrievedBaseState.GetStatus())
		assert.Equal(t, *originalToolState.GetEnv(), *retrievedBaseState.GetEnv())
		assert.Equal(t, *originalToolState.GetTrigger(), *retrievedBaseState.GetTrigger())
		assert.Equal(t, *originalToolState.GetInput(), *retrievedBaseState.GetInput())
		assert.Equal(t, *originalToolState.GetOutput(), *retrievedBaseState.GetOutput())
	})
}

func TestToolStateUpdates(t *testing.T) {
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentTool})
	defer tb.Cleanup()
	stateManager := tb.StateManager

	t.Run("Should reflect updates to status and output after saving", func(t *testing.T) {
		corrID := common.NewCorrID()
		workflowExecID := common.NewExecID()
		taskExecID := common.NewExecID()

		taskEnv := common.EnvMap{
			"k1_task_upd": "v1",
		}
		toolEnv := common.EnvMap{
			"k1_tool_upd": "v2",
		}
		triggerData := common.Input{
			"trigger_update": "data",
		}
		taskData := common.Input{
			"task_update": "data",
		}
		toolData := common.Input{
			"tool_update": "data",
		}

		exec := tool.NewStateParams(
			corrID, taskExecID, workflowExecID, taskEnv, toolEnv,
			&triggerData, &taskData, &toolData,
		)
		require.NotNil(t, exec)
		toolExecID := exec.ExecID

		toolStateInstance, err := tool.NewToolState(exec)
		require.NoError(t, err)
		require.NotNil(t, toolStateInstance)

		err = stateManager.SaveState(toolStateInstance)
		require.NoError(t, err)

		toolStateInstance.SetStatus(nats.StatusSuccess)
		newOutputData := common.Output{"result": "tool_finished", "value": 99.9}
		toolStateInstance.Output = &newOutputData

		err = stateManager.SaveState(toolStateInstance)
		require.NoError(t, err)

		retrievedStateInterface, err := stateManager.GetToolState(corrID, toolExecID)
		require.NoError(t, err)
		require.NotNil(t, retrievedStateInterface)

		retrievedBaseState, ok := retrievedStateInterface.(*state.BaseState)
		require.True(t, ok, "Retrieved state should be of type *state.BaseState")

		assert.Equal(t, nats.StatusSuccess, retrievedBaseState.GetStatus())
		require.NotNil(t, retrievedBaseState.GetOutput())
		assert.Equal(t, newOutputData, *retrievedBaseState.GetOutput())
		assert.Equal(t, *toolStateInstance.GetEnv(), *retrievedBaseState.GetEnv())
	})
}

func TestToolStateUpdateFromEvent(t *testing.T) {
	// Setup
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentTool})
	defer tb.Cleanup()
	stateManager := tb.StateManager

	// Create a tool execution for testing
	corrID := common.NewCorrID()
	workflowExecID := common.NewExecID()
	taskExecID := common.NewExecID()

	taskEnv := common.EnvMap{"TASK_ENV": "task_value"}
	toolEnv := common.EnvMap{"TOOL_ENV": "tool_value"}

	triggerInput := &common.Input{"trigger_key": "trigger_value"}
	taskInput := &common.Input{"task_key": "task_value"}
	toolInput := &common.Input{"tool_key": "tool_value"}

	exec := tool.NewStateParams(
		corrID,
		taskExecID,
		workflowExecID,
		taskEnv,
		toolEnv,
		triggerInput,
		taskInput,
		toolInput,
	)

	toolState, err := tool.NewToolState(exec)
	require.NoError(t, err)
	require.NotNil(t, toolState)

	// Save initial state
	err = stateManager.SaveState(toolState)
	require.NoError(t, err)
	assert.Equal(t, nats.StatusPending, toolState.Status)

	// Test cases for each event type
	t.Run("Should update status to Running when receiving ToolExecutionStartedEvent", func(t *testing.T) {
		event := &pbtool.ToolExecutionStartedEvent{
			Metadata: &pbcommon.Metadata{
				CorrelationId: string(corrID),
			},
			Tool: &pbcommon.ToolInfo{
				Id:     "tool-id",
				ExecId: string(exec.ExecID),
			},
			Task: &pbcommon.TaskInfo{
				Id:     "task-id",
				ExecId: string(taskExecID),
			},
			Workflow: &pbcommon.WorkflowInfo{
				Id:     "workflow-id",
				ExecId: string(workflowExecID),
			},
		}

		err := toolState.UpdateFromEvent(event)
		require.NoError(t, err)
		assert.Equal(t, nats.StatusRunning, toolState.Status)

		// Save and verify
		err = stateManager.SaveState(toolState)
		require.NoError(t, err)

		retrievedState, err := stateManager.GetToolState(corrID, exec.ExecID)
		require.NoError(t, err)
		assert.Equal(t, nats.StatusRunning, retrievedState.GetStatus())
	})

	t.Run("Should update both status and output when receiving ToolExecutionSuccessEvent with Result", func(t *testing.T) {
		// Create a structpb.Struct with test data
		resultData, err := structpb.NewStruct(map[string]interface{}{
			"message": "Tool executed successfully",
			"count":   42,
			"files":   []interface{}{"file1.txt", "file2.txt"},
			"details": map[string]interface{}{
				"duration": 1200,
				"command":  "ls -la",
			},
		})
		require.NoError(t, err)

		// Create success event with result
		event := &pbtool.ToolExecutionSuccessEvent{
			Metadata: &pbcommon.Metadata{
				CorrelationId: string(corrID),
			},
			Tool: &pbcommon.ToolInfo{
				Id:     "tool-id",
				ExecId: string(exec.ExecID),
			},
			Task: &pbcommon.TaskInfo{
				Id:     "task-id",
				ExecId: string(taskExecID),
			},
			Workflow: &pbcommon.WorkflowInfo{
				Id:     "workflow-id",
				ExecId: string(workflowExecID),
			},
			Payload: &pbtool.ToolExecutionSuccessEvent_Payload{
				Result: &pbcommon.Result{
					Output: resultData,
				},
			},
		}

		// Apply the event
		err = toolState.UpdateFromEvent(event)
		require.NoError(t, err)

		// Verify status update
		assert.Equal(t, nats.StatusSuccess, toolState.Status)

		// Verify output update
		require.NotNil(t, toolState.Output)
		assert.Equal(t, "Tool executed successfully", (*toolState.Output)["message"])
		assert.Equal(t, float64(42), (*toolState.Output)["count"])

		// Verify array is correctly converted
		files, ok := (*toolState.Output)["files"].([]interface{})
		require.True(t, ok, "files should be an array")
		require.Len(t, files, 2)
		assert.Equal(t, "file1.txt", files[0])
		assert.Equal(t, "file2.txt", files[1])

		// Verify nested map is correctly converted
		details, ok := (*toolState.Output)["details"].(map[string]interface{})
		require.True(t, ok, "details should be a map")
		assert.Equal(t, float64(1200), details["duration"])
		assert.Equal(t, "ls -la", details["command"])

		// Save and verify
		err = stateManager.SaveState(toolState)
		require.NoError(t, err)

		retrievedState, err := stateManager.GetToolState(corrID, exec.ExecID)
		require.NoError(t, err)
		assert.Equal(t, nats.StatusSuccess, retrievedState.GetStatus())

		// Verify output was saved correctly
		output := retrievedState.GetOutput()
		require.NotNil(t, output)
		assert.Equal(t, "Tool executed successfully", (*output)["message"])
	})

	t.Run("Should update both status and error output when receiving ToolExecutionFailedEvent with Error", func(t *testing.T) {
		// Create a new tool state for this test
		newCorrID := common.NewCorrID()
		newExec := tool.NewStateParams(
			newCorrID,
			taskExecID,
			workflowExecID,
			taskEnv,
			toolEnv,
			triggerInput,
			taskInput,
			toolInput,
		)
		newToolState, err := tool.NewToolState(newExec)
		require.NoError(t, err)
		err = stateManager.SaveState(newToolState)
		require.NoError(t, err)

		// Create error details struct
		errorDetails, err := structpb.NewStruct(map[string]interface{}{
			"command":   "git clone",
			"exit_code": 128,
			"stderr":    "fatal: repository not found",
		})
		require.NoError(t, err)

		// Create error code value
		errorCode := "ERR_TOOL_FAILED"

		// Create failed event with error result
		event := &pbtool.ToolExecutionFailedEvent{
			Metadata: &pbcommon.Metadata{
				CorrelationId: string(newCorrID),
			},
			Tool: &pbcommon.ToolInfo{
				Id:     "tool-id",
				ExecId: string(newExec.ExecID),
			},
			Task: &pbcommon.TaskInfo{
				Id:     "task-id",
				ExecId: string(taskExecID),
			},
			Workflow: &pbcommon.WorkflowInfo{
				Id:     "workflow-id",
				ExecId: string(workflowExecID),
			},
			Payload: &pbtool.ToolExecutionFailedEvent_Payload{
				Result: &pbcommon.Result{
					Error: &pbcommon.ErrorResult{
						Message: "Tool execution failed",
						Code:    &errorCode,
						Details: errorDetails,
					},
				},
			},
		}

		// Apply the event
		err = newToolState.UpdateFromEvent(event)
		require.NoError(t, err)

		// Verify status update
		assert.Equal(t, nats.StatusFailed, newToolState.Status)

		// Verify error details
		require.NotNil(t, newToolState.Error)
		assert.Equal(t, "Tool execution failed", newToolState.Error.Message)
		assert.Equal(t, errorCode, newToolState.Error.Code)

		// Verify error details are correctly stored
		require.NotNil(t, newToolState.Error.Details)
		assert.Equal(t, "git clone", newToolState.Error.Details["command"])
		assert.Equal(t, float64(128), newToolState.Error.Details["exit_code"])
		assert.Equal(t, "fatal: repository not found", newToolState.Error.Details["stderr"])

		// Verify output is nil when there's an error
		assert.Nil(t, newToolState.Output)

		// Save and verify
		err = stateManager.SaveState(newToolState)
		require.NoError(t, err)

		retrievedState, err := stateManager.GetToolState(newCorrID, newExec.ExecID)
		require.NoError(t, err)
		assert.Equal(t, nats.StatusFailed, retrievedState.GetStatus())

		// Verify error was saved correctly
		errRes := retrievedState.GetError()
		require.NotNil(t, errRes)
		assert.Equal(t, "Tool execution failed", errRes.Message)
		assert.Equal(t, errorCode, errRes.Code)
	})

	t.Run("Should return error when receiving unsupported event type", func(t *testing.T) {
		unsupportedEvent := struct{}{}
		err := toolState.UpdateFromEvent(unsupportedEvent)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "unsupported event type")
	})
}
