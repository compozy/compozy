package test

import (
	"testing"

	"github.com/compozy/compozy/engine/common"
	"github.com/compozy/compozy/engine/domain/tool"
	"github.com/compozy/compozy/engine/state"
	"github.com/compozy/compozy/pkg/nats"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestToolStateInitialization(t *testing.T) {
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentTool})
	defer tb.Cleanup()

	corrID := common.NewCorrID()
	workflowExecID := common.NewExecID()
	taskExecID := common.NewExecID()

	taskEnv := common.EnvMap{
		"TASK_KEY":     "task_val",
		"OVERRIDE_KEY": "task_override",
		"SHARED_ENV":   "from_task_env",
	}
	toolEnv := common.EnvMap{
		"TOOL_KEY":     "tool_val",
		"OVERRIDE_KEY": "tool_override",
		"FROM_TRIGGER": "{{ .trigger.input.data.value }}",
		"FROM_INPUT":   "{{ .input.tool_param }}",
		"FROM_ENV":     "{{ .env.SHARED_ENV }}",
	}
	triggerData := common.Input{
		"data": map[string]any{
			"value": "trigger_data_value",
		},
	}
	taskData := common.Input{
		"task_param":   "task_input_value",
		"COMMON_PARAM": "task_common_val",
	}
	toolData := common.Input{
		"tool_param":          "tool_input_value",
		"COMMON_PARAM":        "tool_common_val",
		"TOOL_TEMPLATE_PARAM": "{{ .trigger.input.data.value }}",
	}

	exec := tool.NewExecution(
		corrID,
		taskExecID,
		workflowExecID,
		taskEnv,
		toolEnv,
		&triggerData,
		&taskData,
		&toolData,
	)
	require.NotNil(t, exec, "Tool execution should not be nil")
	toolExecID := exec.ExecID
	require.NotEmpty(t, toolExecID, "ToolExecID (exec.ExecID) should be generated by NewExecution")

	toolState, err := tool.NewToolState(exec)
	require.NoError(t, err)
	require.NotNil(t, toolState)

	t.Run("Should correctly initialize IDs and default status", func(t *testing.T) {
		assert.Equal(t, corrID, toolState.GetID().CorrID)
		assert.Equal(t, workflowExecID, toolState.WorkflowExecID)
		assert.Equal(t, taskExecID, toolState.TaskExecID)
		assert.Equal(t, toolExecID, toolState.ToolExecID)
		assert.Equal(t, toolExecID, toolState.GetID().ExecID)
		assert.Equal(t, nats.StatusPending, toolState.GetStatus())
	})

	t.Run("Should merge environments with tool env taking precedence and resolve templates", func(t *testing.T) {
		expectedEnv := common.EnvMap{
			"TASK_KEY":     "task_val",
			"TOOL_KEY":     "tool_val",
			"OVERRIDE_KEY": "tool_override",
			"SHARED_ENV":   "from_task_env",
			"FROM_TRIGGER": "trigger_data_value",
			"FROM_INPUT":   "tool_input_value",
			"FROM_ENV":     "from_task_env",
		}
		require.NotNil(t, toolState.GetEnv(), "Env should not be nil")
		assert.Equal(t, expectedEnv, *toolState.GetEnv())
	})

	t.Run("Should merge inputs with task input taking precedence and resolve templates", func(t *testing.T) {
		expectedInput := common.Input{
			"task_param":          "task_input_value",
			"tool_param":          "tool_input_value",
			"COMMON_PARAM":        "task_common_val",
			"TOOL_TEMPLATE_PARAM": "trigger_data_value",
		}
		require.NotNil(t, toolState.GetInput(), "Input should not be nil")
		assert.Equal(t, expectedInput, *toolState.GetInput())
	})

	t.Run("Should correctly initialize Trigger and Output", func(t *testing.T) {
		require.NotNil(t, toolState.GetTrigger(), "Trigger should not be nil")
		assert.Equal(t, triggerData, *toolState.GetTrigger())

		require.NotNil(t, toolState.GetOutput(), "Output should be initialized")
		assert.Empty(t, *toolState.GetOutput(), "Output should be empty initially")
	})
}

func TestToolStatePersistence(t *testing.T) {
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentTool})
	defer tb.Cleanup()
	stateManager := tb.StateManager

	t.Run("Should persist state and allow accurate retrieval", func(t *testing.T) {
		corrID := common.NewCorrID()
		workflowExecID := common.NewExecID()
		taskExecID := common.NewExecID()

		taskEnv := common.EnvMap{
			"k1_task": "v1",
		}
		toolEnv := common.EnvMap{
			"k1_tool": "v2",
		}
		triggerData := common.Input{
			"trigger_persist": "data",
		}
		taskData := common.Input{
			"task_persist": "data",
		}
		toolData := common.Input{
			"tool_persist": "data",
		}

		exec := tool.NewExecution(
			corrID, taskExecID, workflowExecID, taskEnv, toolEnv,
			&triggerData, &taskData, &toolData,
		)
		require.NotNil(t, exec)
		toolExecID := exec.ExecID

		originalToolState, err := tool.NewToolState(exec)
		require.NoError(t, err)
		require.NotNil(t, originalToolState)

		err = stateManager.SaveState(originalToolState)
		require.NoError(t, err)

		retrievedStateInterface, err := stateManager.GetToolState(corrID, toolExecID)
		require.NoError(t, err)
		require.NotNil(t, retrievedStateInterface)

		retrievedBaseState, ok := retrievedStateInterface.(*state.BaseState)
		require.True(t, ok, "Retrieved state should be of type *state.BaseState")

		assert.Equal(t, originalToolState.GetID(), retrievedBaseState.GetID())
		assert.Equal(t, nats.ComponentTool, retrievedBaseState.GetID().Component)
		assert.Equal(t, originalToolState.GetStatus(), retrievedBaseState.GetStatus())
		assert.Equal(t, *originalToolState.GetEnv(), *retrievedBaseState.GetEnv())
		assert.Equal(t, *originalToolState.GetTrigger(), *retrievedBaseState.GetTrigger())
		assert.Equal(t, *originalToolState.GetInput(), *retrievedBaseState.GetInput())
		assert.Equal(t, *originalToolState.GetOutput(), *retrievedBaseState.GetOutput())
	})
}

func TestToolStateUpdates(t *testing.T) {
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentTool})
	defer tb.Cleanup()
	stateManager := tb.StateManager

	t.Run("Should reflect updates to status and output after saving", func(t *testing.T) {
		corrID := common.NewCorrID()
		workflowExecID := common.NewExecID()
		taskExecID := common.NewExecID()

		taskEnv := common.EnvMap{
			"k1_task_upd": "v1",
		}
		toolEnv := common.EnvMap{
			"k1_tool_upd": "v2",
		}
		triggerData := common.Input{
			"trigger_update": "data",
		}
		taskData := common.Input{
			"task_update": "data",
		}
		toolData := common.Input{
			"tool_update": "data",
		}

		exec := tool.NewExecution(
			corrID, taskExecID, workflowExecID, taskEnv, toolEnv,
			&triggerData, &taskData, &toolData,
		)
		require.NotNil(t, exec)
		toolExecID := exec.ExecID

		toolStateInstance, err := tool.NewToolState(exec)
		require.NoError(t, err)
		require.NotNil(t, toolStateInstance)

		err = stateManager.SaveState(toolStateInstance)
		require.NoError(t, err)

		toolStateInstance.SetStatus(nats.StatusSuccess)
		newOutputData := common.Output{"result": "tool_finished", "value": 99.9}
		toolStateInstance.BaseState.Output = &newOutputData

		err = stateManager.SaveState(toolStateInstance)
		require.NoError(t, err)

		retrievedStateInterface, err := stateManager.GetToolState(corrID, toolExecID)
		require.NoError(t, err)
		require.NotNil(t, retrievedStateInterface)

		retrievedBaseState, ok := retrievedStateInterface.(*state.BaseState)
		require.True(t, ok, "Retrieved state should be of type *state.BaseState")

		assert.Equal(t, nats.StatusSuccess, retrievedBaseState.GetStatus())
		require.NotNil(t, retrievedBaseState.GetOutput())
		assert.Equal(t, newOutputData, *retrievedBaseState.GetOutput())
		assert.Equal(t, *toolStateInstance.GetEnv(), *retrievedBaseState.GetEnv())
	})
}
