package test

import (
	"testing"

	"github.com/compozy/compozy/engine/common"
	"github.com/compozy/compozy/engine/domain/task"
	"github.com/compozy/compozy/engine/state"
	"github.com/compozy/compozy/pkg/nats"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestTaskStateInitialization(t *testing.T) {
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentTask})
	defer tb.Cleanup()

	corrID := common.NewCorrID()
	workflowExecID := common.NewExecID()

	workflowEnv := common.EnvMap{
		"WORKFLOW_KEY": "workflow_value",
		"OVERRIDE_KEY": "workflow_override",
	}
	taskEnv := common.EnvMap{
		"TASK_SPECIFIC_KEY": "task_value",
		"OVERRIDE_KEY":      "task_override",
		"FROM_TRIGGER":      "{{ .trigger.input.data.value }}",
		"FROM_INPUT":        "{{ .input.task_param }}",
	}
	triggerData := common.Input{
		"data": map[string]any{
			"value": "trigger_data_value",
		},
	}
	taskData := common.Input{
		"task_param": "task_input_value",
	}

	exec := task.NewExecution(
		corrID,
		workflowExecID,
		workflowEnv,
		taskEnv,
		&triggerData,
		&taskData,
	)
	require.NotNil(t, exec, "Task execution should not be nil")
	taskExecID := exec.TaskExecID
	require.NotEmpty(t, taskExecID, "TaskExecID should be generated by NewExecution")

	taskState, err := task.NewTaskState(exec)
	require.NoError(t, err)
	require.NotNil(t, taskState)

	t.Run("Should correctly initialize IDs and default status", func(t *testing.T) {
		assert.Equal(t, corrID, taskState.GetID().CorrID)
		assert.Equal(t, workflowExecID, taskState.WorkflowExecID)
		assert.Equal(t, taskExecID, taskState.TaskExecID)
		assert.Equal(t, taskExecID, taskState.GetID().ExecID)
		assert.Equal(t, nats.StatusPending, taskState.GetStatus())
	})

	t.Run("Should merge environments and resolve templates", func(t *testing.T) {
		expectedEnv := common.EnvMap{
			"WORKFLOW_KEY":      "workflow_value",
			"OVERRIDE_KEY":      "task_override",
			"TASK_SPECIFIC_KEY": "task_value",
			"FROM_TRIGGER":      "trigger_data_value",
			"FROM_INPUT":        "task_input_value",
		}
		require.NotNil(t, taskState.GetEnv(), "Env should not be nil")
		assert.Equal(t, expectedEnv, *taskState.GetEnv())
	})

	t.Run("Should correctly initialize Trigger, Input, and Output", func(t *testing.T) {
		require.NotNil(t, taskState.GetTrigger(), "Trigger should not be nil")
		assert.Equal(t, triggerData, *taskState.GetTrigger())

		require.NotNil(t, taskState.GetInput(), "Input should not be nil")
		assert.Equal(t, taskData, *taskState.GetInput())

		require.NotNil(t, taskState.GetOutput(), "Output should be initialized")
		assert.Empty(t, *taskState.GetOutput(), "Output should be empty initially")
	})
}

func TestTaskStatePersistence(t *testing.T) {
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentTask})
	defer tb.Cleanup()
	stateManager := tb.StateManager

	t.Run("Should persist state and allow accurate retrieval", func(t *testing.T) {
		corrID := common.NewCorrID()
		workflowExecID := common.NewExecID()

		workflowEnv := common.EnvMap{"key1": "val1"}
		taskEnv := common.EnvMap{"key2": "val2"}
		triggerData := common.Input{"trigger_key": "trigger_val"}
		taskData := common.Input{"input_key": "input_val"}

		exec := task.NewExecution(
			corrID, workflowExecID, workflowEnv, taskEnv, &triggerData, &taskData,
		)
		require.NotNil(t, exec)
		taskExecID := exec.TaskExecID

		originalTaskState, err := task.NewTaskState(exec)
		require.NoError(t, err)
		require.NotNil(t, originalTaskState)

		err = stateManager.SaveState(originalTaskState)
		require.NoError(t, err)

		retrievedStateInterface, err := stateManager.GetTaskState(corrID, taskExecID)
		require.NoError(t, err)
		require.NotNil(t, retrievedStateInterface)

		retrievedBaseState, ok := retrievedStateInterface.(*state.BaseState)
		require.True(t, ok, "Retrieved state should be of type *state.BaseState")

		assert.Equal(t, originalTaskState.GetID(), retrievedBaseState.GetID())
		assert.Equal(t, nats.ComponentTask, retrievedBaseState.GetID().Component)
		assert.Equal(t, originalTaskState.GetStatus(), retrievedBaseState.GetStatus())
		assert.Equal(t, *originalTaskState.GetEnv(), *retrievedBaseState.GetEnv())
		assert.Equal(t, *originalTaskState.GetTrigger(), *retrievedBaseState.GetTrigger())
		assert.Equal(t, *originalTaskState.GetInput(), *retrievedBaseState.GetInput())
		assert.Equal(t, *originalTaskState.GetOutput(), *retrievedBaseState.GetOutput())
	})
}

func TestTaskStateUpdates(t *testing.T) {
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentTask})
	defer tb.Cleanup()
	stateManager := tb.StateManager

	t.Run("Should reflect updates to status and output after saving", func(t *testing.T) {
		corrID := common.NewCorrID()
		workflowExecID := common.NewExecID()

		workflowEnv := common.EnvMap{"key1": "val1"}
		taskEnv := common.EnvMap{"key2": "val2"}
		triggerData := common.Input{"trigger_key": "trigger_val"}
		taskData := common.Input{"input_key": "input_val"}

		exec := task.NewExecution(
			corrID, workflowExecID, workflowEnv, taskEnv, &triggerData, &taskData,
		)
		require.NotNil(t, exec)
		taskExecID := exec.TaskExecID

		taskStateInstance, err := task.NewTaskState(exec)
		require.NoError(t, err)
		require.NotNil(t, taskStateInstance)

		err = stateManager.SaveState(taskStateInstance)
		require.NoError(t, err)

		taskStateInstance.SetStatus(nats.StatusSuccess)
		newOutputData := common.Output{
			"result": "task_done",
			"value":  123.45,
		}
		taskStateInstance.Output = &newOutputData

		err = stateManager.SaveState(taskStateInstance)
		require.NoError(t, err)

		retrievedStateInterface, err := stateManager.GetTaskState(corrID, taskExecID)
		require.NoError(t, err)
		require.NotNil(t, retrievedStateInterface)

		retrievedBaseState, ok := retrievedStateInterface.(*state.BaseState)
		require.True(t, ok, "Retrieved state should be of type *state.BaseState")

		assert.Equal(t, nats.StatusSuccess, retrievedBaseState.GetStatus())
		require.NotNil(t, retrievedBaseState.GetOutput())
		assert.Equal(t, newOutputData, *retrievedBaseState.GetOutput())
		assert.Equal(t, *taskStateInstance.GetEnv(), *retrievedBaseState.GetEnv())
	})
}
