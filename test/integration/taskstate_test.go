package test

import (
	"testing"

	"github.com/compozy/compozy/engine/common"
	"github.com/compozy/compozy/engine/domain/task"
	"github.com/compozy/compozy/pkg/nats"
	pbcommon "github.com/compozy/compozy/pkg/pb/common"
	pbtask "github.com/compozy/compozy/pkg/pb/task"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	structpb "google.golang.org/protobuf/types/known/structpb"
)

func TestTaskStateInitialization(t *testing.T) {
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentTask})
	defer tb.Cleanup()

	corrID := common.NewCorrID()
	workflowExecID := common.NewExecID()

	workflowEnv := common.EnvMap{
		"WORKFLOW_KEY": "workflow_val",
		"OVERRIDE_KEY": "workflow_override",
		"SHARED_ENV":   "from_workflow_env",
	}
	taskEnv := common.EnvMap{
		"TASK_KEY":     "task_val",
		"OVERRIDE_KEY": "task_override",
		"FROM_TRIGGER": "{{ .trigger.input.data.value }}",
		"FROM_INPUT":   "{{ .input.task_param }}",
		"FROM_ENV":     "{{ .env.SHARED_ENV }}",
	}
	triggerData := common.Input{
		"data": map[string]any{
			"value": "trigger_data_value",
		},
	}
	taskData := common.Input{
		"task_param":     "task_input_value",
		"TEMPLATE_PARAM": "{{ .trigger.input.data.value }}",
	}

	exec := task.NewExecution(
		corrID,
		workflowExecID,
		workflowEnv,
		taskEnv,
		&triggerData,
		&taskData,
	)
	require.NotNil(t, exec, "Task execution should not be nil")
	taskExecID := exec.TaskExecID
	require.NotEmpty(t, taskExecID, "TaskExecID should be generated by NewExecution")

	taskState, err := task.NewTaskState(exec)
	require.NoError(t, err)
	require.NotNil(t, taskState)

	t.Run("Should correctly initialize IDs and default status", func(t *testing.T) {
		assert.Equal(t, corrID, taskState.GetID().CorrID)
		assert.Equal(t, workflowExecID, taskState.WorkflowExecID)
		assert.Equal(t, taskExecID, taskState.TaskExecID)
		assert.Equal(t, taskExecID, taskState.GetID().ExecID)
		assert.Equal(t, nats.StatusPending, taskState.GetStatus())
	})

	t.Run("Should merge environments with task env taking precedence and resolve templates", func(t *testing.T) {
		expectedEnv := common.EnvMap{
			"WORKFLOW_KEY": "workflow_val",
			"TASK_KEY":     "task_val",
			"OVERRIDE_KEY": "task_override",
			"SHARED_ENV":   "from_workflow_env",
			"FROM_TRIGGER": "trigger_data_value",
			"FROM_INPUT":   "task_input_value",
			"FROM_ENV":     "from_workflow_env",
		}
		require.NotNil(t, taskState.GetEnv(), "Env should not be nil")
		assert.Equal(t, expectedEnv, *taskState.GetEnv())
	})

	t.Run("Should correctly initialize Input with templates resolved", func(t *testing.T) {
		expectedInput := common.Input{
			"task_param":     "task_input_value",
			"TEMPLATE_PARAM": "trigger_data_value",
		}
		require.NotNil(t, taskState.GetInput(), "Input should not be nil")
		assert.Equal(t, expectedInput, *taskState.GetInput())
	})

	t.Run("Should correctly initialize Trigger and Output", func(t *testing.T) {
		require.NotNil(t, taskState.GetTrigger(), "Trigger should not be nil")
		assert.Equal(t, triggerData, *taskState.GetTrigger())

		require.NotNil(t, taskState.GetOutput(), "Output should be initialized")
		assert.Empty(t, *taskState.GetOutput(), "Output should be empty initially")
	})
}

func TestTaskStateUpdateFromEvent(t *testing.T) {
	// Setup
	tb := SetupIntegrationTestBed(t, DefaultTestTimeout, []nats.ComponentType{nats.ComponentTask})
	defer tb.Cleanup()
	stateManager := tb.StateManager

	// Create a task execution for testing
	corrID := common.NewCorrID()
	workflowExecID := common.NewExecID()

	workflowEnv := common.EnvMap{"WORKFLOW_ENV": "workflow_value"}
	taskEnv := common.EnvMap{"TASK_ENV": "task_value"}

	triggerInput := &common.Input{"trigger_key": "trigger_value"}
	taskInput := &common.Input{"task_key": "task_value"}

	exec := task.NewExecution(
		corrID,
		workflowExecID,
		workflowEnv,
		taskEnv,
		triggerInput,
		taskInput,
	)

	taskState, err := task.NewTaskState(exec)
	require.NoError(t, err)
	require.NotNil(t, taskState)

	// Save initial state
	err = stateManager.SaveState(taskState)
	require.NoError(t, err)
	assert.Equal(t, nats.StatusPending, taskState.Status)

	// Test cases for different event types
	t.Run("Should update status to Pending when receiving TaskDispatchedEvent", func(t *testing.T) {
		event := &pbtask.TaskDispatchedEvent{
			Metadata: &pbcommon.Metadata{
				CorrelationId: string(corrID),
			},
			Task: &pbcommon.TaskInfo{
				Id:     "task-id",
				ExecId: string(exec.TaskExecID),
			},
			Workflow: &pbcommon.WorkflowInfo{
				Id:     "workflow-id",
				ExecId: string(workflowExecID),
			},
		}

		err := taskState.UpdateFromEvent(event)
		require.NoError(t, err)
		assert.Equal(t, nats.StatusPending, taskState.Status)
	})

	t.Run("Should update status to Running when receiving TaskExecutionStartedEvent", func(t *testing.T) {
		event := &pbtask.TaskExecutionStartedEvent{
			Metadata: &pbcommon.Metadata{
				CorrelationId: string(corrID),
			},
			Task: &pbcommon.TaskInfo{
				Id:     "task-id",
				ExecId: string(exec.TaskExecID),
			},
			Workflow: &pbcommon.WorkflowInfo{
				Id:     "workflow-id",
				ExecId: string(workflowExecID),
			},
		}

		err := taskState.UpdateFromEvent(event)
		require.NoError(t, err)
		assert.Equal(t, nats.StatusRunning, taskState.Status)

		// Save and verify
		err = stateManager.SaveState(taskState)
		require.NoError(t, err)

		retrievedState, err := stateManager.GetTaskState(corrID, exec.TaskExecID)
		require.NoError(t, err)
		assert.Equal(t, nats.StatusRunning, retrievedState.GetStatus())
	})

	t.Run("Should update status to Waiting when receiving TaskExecutionWaitingStartedEvent", func(t *testing.T) {
		event := &pbtask.TaskExecutionWaitingStartedEvent{
			Metadata: &pbcommon.Metadata{
				CorrelationId: string(corrID),
			},
			Task: &pbcommon.TaskInfo{
				Id:     "task-id",
				ExecId: string(exec.TaskExecID),
			},
			Workflow: &pbcommon.WorkflowInfo{
				Id:     "workflow-id",
				ExecId: string(workflowExecID),
			},
		}

		err := taskState.UpdateFromEvent(event)
		require.NoError(t, err)
		assert.Equal(t, nats.StatusWaiting, taskState.Status)
	})

	t.Run("Should update status to Running when receiving TaskExecutionWaitingEndedEvent", func(t *testing.T) {
		event := &pbtask.TaskExecutionWaitingEndedEvent{
			Metadata: &pbcommon.Metadata{
				CorrelationId: string(corrID),
			},
			Task: &pbcommon.TaskInfo{
				Id:     "task-id",
				ExecId: string(exec.TaskExecID),
			},
			Workflow: &pbcommon.WorkflowInfo{
				Id:     "workflow-id",
				ExecId: string(workflowExecID),
			},
		}

		err := taskState.UpdateFromEvent(event)
		require.NoError(t, err)
		assert.Equal(t, nats.StatusRunning, taskState.Status)
	})

	t.Run("Should update both status and output when receiving TaskExecutionSuccessEvent with Result", func(t *testing.T) {
		// Create a structpb.Struct with test data
		resultData, err := structpb.NewStruct(map[string]interface{}{
			"message": "Task completed successfully",
			"count":   42,
			"tokens":  2500,
			"details": map[string]interface{}{
				"type":    "completion",
				"latency": 500,
			},
		})
		require.NoError(t, err)

		// Create success event with result
		event := &pbtask.TaskExecutionSuccessEvent{
			Metadata: &pbcommon.Metadata{
				CorrelationId: string(corrID),
			},
			Task: &pbcommon.TaskInfo{
				Id:     "task-id",
				ExecId: string(exec.TaskExecID),
			},
			Workflow: &pbcommon.WorkflowInfo{
				Id:     "workflow-id",
				ExecId: string(workflowExecID),
			},
			Payload: &pbtask.TaskExecutionSuccessEvent_Payload{
				Result: &pbcommon.Result{
					Output: resultData,
				},
			},
		}

		// Apply the event
		err = taskState.UpdateFromEvent(event)
		require.NoError(t, err)

		// Verify status update
		assert.Equal(t, nats.StatusSuccess, taskState.Status)

		// Verify output update
		require.NotNil(t, taskState.Output)
		assert.Equal(t, "Task completed successfully", (*taskState.Output)["message"])
		assert.Equal(t, float64(42), (*taskState.Output)["count"])
		assert.Equal(t, float64(2500), (*taskState.Output)["tokens"])

		// Verify nested map is correctly converted
		details, ok := (*taskState.Output)["details"].(map[string]interface{})
		require.True(t, ok, "details should be a map")
		assert.Equal(t, "completion", details["type"])
		assert.Equal(t, float64(500), details["latency"])

		// Save and verify
		err = stateManager.SaveState(taskState)
		require.NoError(t, err)

		retrievedState, err := stateManager.GetTaskState(corrID, exec.TaskExecID)
		require.NoError(t, err)
		assert.Equal(t, nats.StatusSuccess, retrievedState.GetStatus())

		// Verify output was saved correctly
		output := retrievedState.GetOutput()
		require.NotNil(t, output)
		assert.Equal(t, "Task completed successfully", (*output)["message"])
	})

	t.Run("Should update both status and error output when receiving TaskExecutionFailedEvent with Error", func(t *testing.T) {
		// Create a new task state for this test
		newCorrID := common.NewCorrID()
		newExec := task.NewExecution(
			newCorrID,
			workflowExecID,
			workflowEnv,
			taskEnv,
			triggerInput,
			taskInput,
		)
		newTaskState, err := task.NewTaskState(newExec)
		require.NoError(t, err)
		err = stateManager.SaveState(newTaskState)
		require.NoError(t, err)

		// Create error details struct
		errorDetails, err := structpb.NewStruct(map[string]interface{}{
			"operation": "database_query",
			"context":   "connection failed",
			"retry":     false,
		})
		require.NoError(t, err)

		// Create error code value
		errorCode := "ERR_TASK_FAILED"

		// Create failed event with error result
		event := &pbtask.TaskExecutionFailedEvent{
			Metadata: &pbcommon.Metadata{
				CorrelationId: string(newCorrID),
			},
			Task: &pbcommon.TaskInfo{
				Id:     "task-id",
				ExecId: string(newExec.TaskExecID),
			},
			Workflow: &pbcommon.WorkflowInfo{
				Id:     "workflow-id",
				ExecId: string(workflowExecID),
			},
			Payload: &pbtask.TaskExecutionFailedEvent_Payload{
				Result: &pbcommon.Result{
					Error: &pbcommon.ErrorResult{
						Message: "Task execution failed",
						Code:    &errorCode,
						Details: errorDetails,
					},
				},
			},
		}

		// Apply the event
		err = newTaskState.UpdateFromEvent(event)
		require.NoError(t, err)

		// Verify status update
		assert.Equal(t, nats.StatusFailed, newTaskState.Status)

		// Verify error details
		require.NotNil(t, newTaskState.Error)
		assert.Equal(t, "Task execution failed", newTaskState.Error.Message)
		assert.Equal(t, errorCode, newTaskState.Error.Code)

		// Verify error details are correctly stored
		require.NotNil(t, newTaskState.Error.Details)
		assert.Equal(t, "database_query", newTaskState.Error.Details["operation"])
		assert.Equal(t, "connection failed", newTaskState.Error.Details["context"])
		assert.Equal(t, false, newTaskState.Error.Details["retry"])

		// Verify output is nil when there's an error
		assert.Nil(t, newTaskState.Output)

		// Save and verify
		err = stateManager.SaveState(newTaskState)
		require.NoError(t, err)

		retrievedState, err := stateManager.GetTaskState(newCorrID, newExec.TaskExecID)
		require.NoError(t, err)
		assert.Equal(t, nats.StatusFailed, retrievedState.GetStatus())

		// Verify error was saved correctly
		errRes := retrievedState.GetError()
		require.NotNil(t, errRes)
		assert.Equal(t, "Task execution failed", errRes.Message)
		assert.Equal(t, errorCode, errRes.Code)
	})

	t.Run("Should update both status and output when receiving TaskExecutionWaitingTimedOutEvent with Result", func(t *testing.T) {
		// Create a new task state for this test
		newCorrID := common.NewCorrID()
		newExec := task.NewExecution(
			newCorrID,
			workflowExecID,
			workflowEnv,
			taskEnv,
			triggerInput,
			taskInput,
		)
		newTaskState, err := task.NewTaskState(newExec)
		require.NoError(t, err)
		err = stateManager.SaveState(newTaskState)
		require.NoError(t, err)

		// Create a structpb.Struct with timeout details
		resultData, err := structpb.NewStruct(map[string]interface{}{
			"reason":     "waiting condition not satisfied",
			"timeout_ms": 30000,
			"details":    "max retry attempts exceeded",
		})
		require.NoError(t, err)

		// Create timeout event with result
		event := &pbtask.TaskExecutionWaitingTimedOutEvent{
			Metadata: &pbcommon.Metadata{
				CorrelationId: string(newCorrID),
			},
			Task: &pbcommon.TaskInfo{
				Id:     "task-id",
				ExecId: string(newExec.TaskExecID),
			},
			Workflow: &pbcommon.WorkflowInfo{
				Id:     "workflow-id",
				ExecId: string(workflowExecID),
			},
			Payload: &pbtask.TaskExecutionWaitingTimedOutEvent_Payload{
				Result: &pbcommon.Result{
					Output: resultData,
				},
			},
		}

		// Apply the event
		err = newTaskState.UpdateFromEvent(event)
		require.NoError(t, err)

		// Verify status update
		assert.Equal(t, nats.StatusTimedOut, newTaskState.Status)

		// Verify output update
		require.NotNil(t, newTaskState.Output)
		assert.Equal(t, "waiting condition not satisfied", (*newTaskState.Output)["reason"])
		assert.Equal(t, float64(30000), (*newTaskState.Output)["timeout_ms"])
		assert.Equal(t, "max retry attempts exceeded", (*newTaskState.Output)["details"])

		// Save and verify
		err = stateManager.SaveState(newTaskState)
		require.NoError(t, err)

		retrievedState, err := stateManager.GetTaskState(newCorrID, newExec.TaskExecID)
		require.NoError(t, err)
		assert.Equal(t, nats.StatusTimedOut, retrievedState.GetStatus())
	})

	t.Run("Should return error when receiving unsupported event type", func(t *testing.T) {
		unsupportedEvent := struct{}{}
		err := taskState.UpdateFromEvent(unsupportedEvent)
		require.Error(t, err)
		assert.Contains(t, err.Error(), "unsupported event type")
	})
}
