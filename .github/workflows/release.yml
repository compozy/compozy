name: Release

# Research Summary (Latest Best Practices - 2024/2025):
# - git-cliff: Use --unreleased flag for pending changes, --bump for version calculation
# - git-cliff: Support conventional commits with automatic semver bumping
# - GoReleaser: Use --snapshot --skip=publish for dry runs, --clean for production
# - GoReleaser: Native changelog field accepts file path (--release-notes=CHANGELOG.md)
# - Idempotency: Check for existing tags before operations
# - Concurrency: Use groups to prevent race conditions

on:
  # Trigger on push to main for Release PR creation/update
  push:
    branches:
      - main
    paths-ignore:
      - "**.md"
      - ".github/ISSUE_TEMPLATE/**"
      - ".github/PULL_REQUEST_TEMPLATE/**"

  # Trigger on PR events for dry-run checks
  pull_request:
    types:
      - opened
      - synchronize
      - labeled
    branches:
      - main

  # Manual trigger for emergency releases
  workflow_dispatch:
    inputs:
      force_release:
        description: "Force a release even if no changes"
        required: false
        type: boolean
        default: false

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

env:
  GO_VERSION: "1.24.x"
  NODE_VERSION: "22"
  RELEASE_BRANCH_PREFIX: "release/"
  RELEASE_PR_LABEL: "release-pending"
  INITIAL_VERSION: "v0.0.4"

permissions:
  contents: write
  packages: write
  pull-requests: write
  id-token: write
  attestations: write

jobs:
  # Job 1: Create or update Release PR on push to main or manual trigger
  release-pr:
    name: Create/Update Release PR
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    outputs:
      pr_created: ${{ steps.create-pr.outputs.pr_created }}
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          registry-url: "https://registry.npmjs.org"

      - name: Setup git-cliff
        uses: ./.github/actions/setup-git-cliff
        with:
          version: latest

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Run Compozy Release to check changes
        id: check-changes
        run: go run ./pkg/release check-changes --ci-output >> $GITHUB_OUTPUT

      - name: Calculate next version
        id: version
        if: steps.check-changes.outputs.has_changes == 'true' || github.event.inputs.force_release == 'true'
        run: go run ./pkg/release calculate-version --ci-output >> $GITHUB_OUTPUT

      - name: Generate changelog
        if: steps.check-changes.outputs.has_changes == 'true' || github.event.inputs.force_release == 'true'
        run: |
          # Generate release notes for this specific version (for PR body)
          go run ./pkg/release generate-changelog --version "${{ steps.version.outputs.version }}" --mode "unreleased" > RELEASE_NOTES.md

      - name: Create Release Branch
        if: steps.check-changes.outputs.has_changes == 'true' || github.event.inputs.force_release == 'true'
        id: create-branch
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN }}
        run: |
          BRANCH_NAME="${{ env.RELEASE_BRANCH_PREFIX }}${{ steps.version.outputs.version }}"
          go run ./pkg/release create-release-branch --branch-name "$BRANCH_NAME"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Update package versions
        if: steps.check-changes.outputs.has_changes == 'true' || github.event.inputs.force_release == 'true'
        run: go run ./pkg/release update-package-versions --version "${{ steps.version.outputs.version }}"

      - name: Commit version updates
        if: steps.check-changes.outputs.has_changes == 'true' || github.event.inputs.force_release == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN }}
        run: |
          set -e
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Switch to the release branch
          git checkout "${{ steps.create-branch.outputs.branch_name }}"

          # Add only package.json files (version updates)
          git add package.json 2>/dev/null || true
          git add tools/*/package.json 2>/dev/null || true

          # Only commit if there are changes
          if ! git diff --cached --quiet; then
            git commit -m "ci(release): prepare release ${{ steps.version.outputs.version }}"
            git push origin "${{ steps.create-branch.outputs.branch_name }}" --force-with-lease || {
              echo "ERROR: Failed to push branch" >&2
              exit 1
            }
          else
            echo "No changes to commit"
          fi

      - name: Prepare PR body
        if: steps.check-changes.outputs.has_changes == 'true' || github.event.inputs.force_release == 'true'
        id: pr-body
        run: |
          go run ./pkg/release prepare-pr-body \
            --version "${{ steps.version.outputs.version }}" \
            --changelog "$(cat RELEASE_NOTES.md)" > PR_BODY.md

      - name: Create or Update Pull Request
        if: steps.check-changes.outputs.has_changes == 'true' || github.event.inputs.force_release == 'true'
        id: create-pr
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.RELEASE_TOKEN }}
          branch: ${{ steps.create-branch.outputs.branch_name }}
          base: main
          title: "ci(release): Release ${{ steps.version.outputs.version }}"
          body-path: PR_BODY.md
          labels: |
            ${{ env.RELEASE_PR_LABEL }}
            automated
          assignees: ${{ github.actor }}

  # Job 2: Dry-run checks on Release PR
  dry-run:
    name: Dry-Run Release Check
    if: |
      github.event_name == 'pull_request' &&
      contains(github.event.pull_request.labels.*.name, 'release-pending')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          registry-url: "https://registry.npmjs.org"

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Setup git-cliff
        uses: ./.github/actions/setup-git-cliff
        with:
          version: latest

      - name: Run git-cliff validation
        run: |
          set -e
          echo "### 📝 Validating Changelog Generation"
          git-cliff --unreleased --verbose

      - name: Install GoReleaser
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser-pro
          version: latest
          install-only: true

      - name: Run GoReleaser dry-run
        run: |
          set -e
          echo "### 🏗️ Running GoReleaser Dry-Run"
          goreleaser release --snapshot --skip=publish --clean
        env:
          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}

      - name: Upload dry-run artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dry-run-artifacts
          path: |
            dist/*.tar.gz
            dist/*.zip
            dist/checksums.txt
            dist/metadata.json
          retention-days: 7

      - name: Validate NPM packages
        env:
          HEAD_REF: ${{ github.head_ref }}
        run: |
          set -e
          echo "### 📦 Validating NPM packages"
          # Extract version from PR title or branch name
          VERSION=$(echo "$HEAD_REF" | sed -n 's/.*\/\(v\?[0-9]\+\.[0-9]\+\.[0-9]\+\).*/\1/p')
          if [[ -z "$VERSION" ]]; then
            echo "ERROR: Could not extract version from branch name: $HEAD_REF" >&2
            exit 1
          fi
          # Remove 'v' prefix if present
          VERSION="${VERSION#v}"
          # Update versions for validation
          go run ./pkg/release update-package-versions --version "$VERSION"

      - name: Comment on PR with dry-run results
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            let metadata = {};
            let artifactsList = 'Not available.';
            try {
              metadata = JSON.parse(fs.readFileSync('dist/metadata.json', 'utf8'));
              if (metadata.artifacts) {
                const uniqueBuilds = new Set(metadata.artifacts.filter(a => a.type === 'Archive').map(a => `${a.goos}/${a.goarch}`));
                artifactsList = Array.from(uniqueBuilds).map(b => `- ${b}`).join('\n');
              }
            } catch (e) {
              console.log('Could not read or parse metadata.json:', e);
            }

            const body = `## ✅ Dry-Run Completed Successfully

            ### 📊 Build Summary
            - **Version**: ${metadata.version || 'unknown'}
            - **Commit**: ${context.sha.substring(0, 7)}

            ### 📦 Built Artifacts
             ${artifactsList}

            ### 🔗 Download
            Dry-run artifacts are available as workflow artifacts for 7 days.

            ---
            *This is an automated comment from the release dry-run check.*
            `;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });

  # Job 3: Production release on merge
  release:
    name: Production Release
    if: |
      github.event_name == 'push' &&
      github.ref == 'refs/heads/main' &&
      contains(github.event.head_commit.message, 'release:')
    runs-on: ubuntu-latest
    timeout-minutes: 120
    env:
      DOCKER_CLI_EXPERIMENTAL: enabled

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_TOKEN }}

      - name: Extract version from commit
        id: extract-version
        env:
          COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
        run: |
          VERSION=$(echo "$COMMIT_MESSAGE" | grep -o 'v\?[0-9]\+\.[0-9]\+\.[0-9]\+' | head -n1)
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Check if tag already exists (idempotency)
        id: check-tag
        run: |
          if git rev-parse "${{ steps.extract-version.outputs.version }}" >/dev/null 2>&1; then
            echo "tag_exists=true" >> $GITHUB_OUTPUT
          else
            echo "tag_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup Node.js
        if: steps.check-tag.outputs.tag_exists == 'false'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          registry-url: "https://registry.npmjs.org"

      - name: Set up Go
        if: steps.check-tag.outputs.tag_exists == 'false'
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Set up Docker Buildx
        if: steps.check-tag.outputs.tag_exists == 'false'
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        if: steps.check-tag.outputs.tag_exists == 'false'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.RELEASE_TOKEN }}

      - name: Install cosign
        if: steps.check-tag.outputs.tag_exists == 'false'
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: "v2.2.4"

      - name: Install syft
        if: steps.check-tag.outputs.tag_exists == 'false'
        uses: anchore/sbom-action/download-syft@v0
        with:
          syft-version: latest

      - name: Create Git tag
        if: steps.check-tag.outputs.tag_exists == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN }}
        run: go run ./pkg/release create-git-tag --tag-name "${{ steps.extract-version.outputs.version }}" --message "Release ${{ steps.extract-version.outputs.version }}"

      - name: Setup git-cliff
        if: steps.check-tag.outputs.tag_exists == 'false'
        uses: ./.github/actions/setup-git-cliff
        with:
          version: latest

      - name: Generate final changelog
        if: steps.check-tag.outputs.tag_exists == 'false'
        run: go run ./pkg/release generate-changelog --version "${{ steps.extract-version.outputs.version }}" --mode "release" > RELEASE_NOTES.md

      - name: Run GoReleaser
        if: steps.check-tag.outputs.tag_exists == 'false'
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser-pro
          version: latest
          args: release --clean --release-notes=RELEASE_NOTES.md
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN }}
          RELEASE_TOKEN: ${{ secrets.RELEASE_TOKEN }}
          AUR_KEY: ${{ secrets.AUR_KEY }}
          COSIGN_EXPERIMENTAL: 1
          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          GORELEASER_CURRENT_TAG: ${{ steps.extract-version.outputs.version }}

      - name: Publish NPM packages
        if: steps.check-tag.outputs.tag_exists == 'false'
        run: |
          echo "### 📦 Publishing NPM packages"
          go run ./pkg/release publish-npm-packages
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Update CHANGELOG in main branch
        if: steps.check-tag.outputs.tag_exists == 'false'
        run: go run ./pkg/release update-main-changelog --changelog "$(cat RELEASE_NOTES.md)"
