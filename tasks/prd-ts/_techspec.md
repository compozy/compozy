# Compozy TypeScript SDK — Technical Spec and Delivery Plan

Status: Draft (Proposed)

Owner: Compozy Core

Last Updated: 2025-09-24

---

## 1. Objectives

- Deliver a modern, code-first TypeScript SDK to author and orchestrate Compozy workflows without YAML.
- Preserve existing configuration shapes and naming (1:1 parity with `schemas/compozy.json`).
- Avoid duplicating server compile/link logic; the SDK remains thin, ergonomic, and strongly typed.
- Provide great DX: class-based builders, optional validation, small transport client, YAML interop, and clear examples.

### Non‑Goals

- Reimplementing compile/link/defaulting/selector resolution (these remain server‑side responsibilities).
- Introducing new runtime semantics not present in the Go engine.

### Constraints and Standards

- Single source of truth: `schemas/compozy.json` (generated by `pkg/schemagen`).
- Emitted JSON fields are identical to the schema (snake_case); methods may be camelCase but output shape never changes.
- No server logic duplication: builders assemble JSON only; server validates/compiles.
- Ship optional runtime validation via precompiled AJV validators.

---

## 2. Architecture Overview

The SDK is split into small, tree‑shakeable modules:

- Core Types (generated): TS types from `schemas/compozy.json`.
- Builder Classes (zero‑overhead): Class-based builders that produce JSON matching the schema.
- Client (fetch-based): Minimal REST client to manage resources and executions.
- Validation (optional): Precompiled AJV validators per top‑level schema.
- YAML (optional): Utilities to read/write YAML using the same shapes.
- MCP (optional): Re‑export types from the MCP TypeScript SDK and small helpers for local dev.

Monorepo location: `tools/sdk` (fits current workspaces in `package.json`).

Exports map:

- `@compozy/sdk` → builders + client entry
- `@compozy/sdk/types` → generated types
- `@compozy/sdk/validation` → precompiled validators (optional)
- `@compozy/sdk/yaml` → YAML helpers (optional)
- `@compozy/sdk/mcp` → MCP extras (optional)

---

## 3. Source of Truth and Codegen

We will treat `schemas/compozy.json` as the canonical contract for all shapes. The SDK will:

1. Run `make schemagen` to regenerate `schemas/compozy.json` from Go structs.
2. Run `json-schema-to-typescript` to generate `tools/sdk/src/types/compozy.d.ts`.
3. Precompile AJV validators for `compozy.json` and the most used `$defs` into `tools/sdk/src/validation/`.
4. CI will fail on drift: regenerated types/validators must match committed artifacts.

Notes:

- Use AJV v8 in draft‑07 mode (matching current schemas).
- Keep validation optional and tree‑shakeable.

---

## 4. Builder Classes (Non‑Chaining API)

Builders return plain JSON objects conforming to the schema and never apply server logic. Public methods use camelCase, but the emitted JSON keys strictly follow snake_case per `compozy.json`.

### 4.1 Public API (MVP)

```ts
export class WorkflowBuilder {
  constructor(id: string, version?: string);
  setDescription(text: string): this;
  setAuthor(author: Author): this;
  setTags(tags: string[]): this;
  setConfig(opts: WorkflowOpts): this; // maps to workflow.config { input?, env?, ... }
  addTrigger(trigger: Trigger): this; // { type: 'signal'|'webhook', name, schema?, webhook? }
  addSchedule(schedule: {
    cron: string;
    timezone?: string;
    enabled?: boolean;
    jitter?: string;
    overlap?: OverlapPolicy; // alias → emits overlap_policy
    start_at?: string;
    end_at?: string;
    input?: Record<string, any>;
  }): this;
  addAgent(agent: AgentConfig): this;
  addTool(tool: ToolConfig): this;
  addMCP(mcp: MCPConfig): this;
  addTask(task: TaskConfig | TaskBuilder): this; // accepts built config or a TaskBuilder
  setOutputs(map: Record<string, any>): this;
  build(): WorkflowConfig;
}

export class TaskBuilder {
  constructor(type: TaskType, id: string);
  // Executors (exactly one must be set for basic tasks)
  setAgent(agentOrRef: AgentConfig | Ref): this;
  setTool(toolOrRef: ToolConfig | Ref): this;
  setPrompt(prompt: string): this; // direct LLM mode

  // Common task fields
  setWith(input: Record<string, any>): this;
  setOutputs(map: Record<string, any>): this;
  setOnSuccess(next: string | TaskBuilder | TaskConfig): this;
  setOnError(next: string | TaskBuilder | TaskConfig): this;
  setFinal(final: boolean): this;
  setSleep(duration: string): this;
  setTimeout(duration: string): this;
  setRetries(n: number): this;
  setCondition(cel: string): this;

  // Router
  addRoute(key: string, taskOrId: string | TaskBuilder | TaskConfig): this;

  // Parallel
  setStrategy(s: "wait_all" | "race" | "fail_fast" | "best_effort"): this;
  setMaxWorkers(n: number): this;
  addChildTask(task: TaskBuilder | TaskConfig): this;

  // Collection
  setItems(exprOrArray: any): this;
  setMode(mode: "parallel" | "sequential"): this;
  setBatch(n: number): this;
  setItemTask(task: TaskBuilder | TaskConfig): this;

  build(): TaskConfig;
}

export class Ref {
  static create(id: string): Ref; // serializes to a plain string on build
}
```

Validation rules enforced on `build()` (never at runtime execution):

- For `basic` tasks, exactly one of `setAgent`, `setTool`, or `setPrompt` must be used.
- Router routes must reference a valid ID or inline task.
- Parallel requires at least one child task; collection requires `items` and one `itemTask`.

### 4.2 Class‑Based Example (Requested Style)

```ts
import { WorkflowBuilder, TaskBuilder, Ref } from "@compozy/sdk";

const wfBuilder = new WorkflowBuilder("customer-support", "1.0.0");
wfBuilder.setDescription("Automated customer support with ticketing");
wfBuilder.setConfig({
  input: {
    type: "object",
    properties: {
      customer_email: { type: "string", format: "email" },
      issue_description: { type: "string", minLength: 10 },
    },
    required: ["customer_email", "issue_description"],
  },
  env: { SUPPORT_API_KEY: "{{ .secrets.SUPPORT_API_KEY }}" },
});
wfBuilder.addTrigger({
  type: "signal",
  name: "new-support-request",
  schema: { $ref: "local::config.input" },
});
wfBuilder.addSchedule({
  cron: "0 */4 * * *",
  overlap: "buffer_one",
  input: { source: "scheduled_check" },
});
wfBuilder.addAgent({
  id: "support-agent",
  instructions: "You are a helpful support agent.",
  model: "gpt-4",
});
wfBuilder.addTool({
  id: "ticket-creator",
  description: "Creates support tickets",
});

const analyzeTaskBuilder = new TaskBuilder("basic", "analyze-issue");
analyzeTaskBuilder.setAgent(Ref.create("support-agent"));
analyzeTaskBuilder.setWith({
  prompt: `Analyze:
Customer: {{ .workflow.input.customer_email }}
Issue: {{ .workflow.input.issue_description }}`,
});
analyzeTaskBuilder.setOnSuccess("create-ticket");
wfBuilder.addTask(analyzeTaskBuilder.build());

const createTicketTaskBuilder = new TaskBuilder("basic", "create-ticket");
createTicketTaskBuilder.setTool(Ref.create("ticket-creator"));
createTicketTaskBuilder.setWith({
  email: "{{ .workflow.input.customer_email }}",
  description: "{{ .workflow.input.issue_description }}",
  priority: "{{ .tasks.analyze-issue.output.priority }}",
});
createTicketTaskBuilder.setFinal(true);
wfBuilder.addTask(createTicketTaskBuilder.build());

wfBuilder.setOutputs({
  ticket_id: "{{ .tasks.create-ticket.output.ticket_id }}",
  status: "{{ .tasks.create-ticket.output.status }}",
});

const wf = wfBuilder.build();
```

### 4.3 Additional Patterns with Classes

Router with mixed refs and inline tasks:

```ts
const r = new TaskBuilder("router", "route");
r.setCondition(
  "input.amount > 10000 ? 'exec' : input.amount > 1000 ? 'mgr' : 'auto'"
);
r.addRoute("exec", "executive-approval");
r.addRoute("mgr", "manager-approval");
r.addRoute(
  "auto",
  new TaskBuilder("basic", "auto-approve")
    .setTool(Ref.create("approver"))
    .build()
);
wfBuilder.addTask(r.build());
```

Parallel fan‑out:

```ts
const p = new TaskBuilder("parallel", "fanout");
p.setStrategy("wait_all");
p.setMaxWorkers(4);
p.addChildTask(
  new TaskBuilder("basic", "extract").setAgent(Ref.create("ie")).build()
);
p.addChildTask(
  new TaskBuilder("basic", "sentiment").setAgent(Ref.create("sa")).build()
);
wfBuilder.addTask(p.build());
```

Collection map/reduce style:

```ts
const c = new TaskBuilder("collection", "users");
c.setItems("{{ .workflow.input.users }}");
c.setMode("parallel");
c.setBatch(10);
c.setItemTask(
  new TaskBuilder("basic", "process-user")
    .setAgent(Ref.create("processor"))
    .build()
);
wfBuilder.addTask(c.build());
```

---

## 5. Transport Client (REST)

Thin, fetch‑based, ETag‑aware client that maps to the versioned API (`/api/v0`).

```ts
import { createClient } from "@compozy/sdk";

const client = createClient({
  baseURL: "http://localhost:8080/api/v0",
  apiKey: process.env.COMPOZY_API_KEY!,
});

// Create/update (with ETag controls)
const { etag } = await client.workflows.upsert("customer-support", wf, {
  ifNoneMatch: "*",
});

// Execute workflow
const exec = await client.workflows.execute("customer-support", {
  input: {
    customer_email: "user@example.com",
    issue_description: "Cannot access billing portal",
  },
});

// Page through executions
let page = await client.workflows.executions.list({ limit: 20 });
while (page.nextCursor) {
  page = await client.workflows.executions.list({
    limit: 20,
    cursor: page.nextCursor,
  });
}
```

Key behaviors:

- Exposes `ifMatch`/`ifNoneMatch`, returns `ETag`, and parses `Link` headers.
- Surfaced endpoints mirror `engine/workflow/router/register.go` and other routers.
- No hidden retries; allow user‑provided fetch wrapper for backoff/observability.

---

## 6. YAML and Validation (Optional)

YAML I/O mirrors CLI/engine expectations; deterministic ordering for snapshot tests.

```ts
import { toYAML, fromYAML } from "@compozy/sdk/yaml";

const yaml = toYAML(wf);
const back = fromYAML(yaml); // round‑trips to the same JSON shape
```

Validation uses precompiled AJV:

```ts
import { validateWorkflow } from "@compozy/sdk/validation";

const ok = validateWorkflow(wf);
if (!ok) {
  console.error(validateWorkflow.errors);
}
```

---

## 7. Packaging and Runtime

- ESM‑first, Node >= 18. Fetch is required; polyfill is user‑provided when needed.
- `sideEffects: false` for tree‑shaking.
- Peer dependencies kept minimal; validation/zod/mcp are optional subpaths.

---

## 8. Testing Strategy

1. Unit tests: builder state machines (executor mutual exclusivity), router inline serialization.
2. Schema tests: AJV validation of all builder outputs.
3. Golden tests: deterministic JSON/YAML snapshots.
4. Integration tests: contract tests against a dev server for workflows, tasks, agents, tools, memory, executions.
5. Performance: ensure validators are precompiled; cold start measurements.

---

## 9. CI, Make Targets, and Drift Control

- `make schemagen` — refresh unified schema from Go.
- `make sdk-types` — generate TS types from `schemas/compozy.json`.
- `make sdk-validators` — precompile AJV validators.
- CI job “SDK drift check” runs the three commands, diffs outputs, and fails on changes.

Monorepo integration: add `tools/sdk` to workspaces and Turbo pipeline for `build`, `lint`, `type-check`, `test`.

---

## 10. Milestones & Deliverables

M0 — Foundations (1–2 weeks)

- Create `tools/sdk` workspace skeleton; set up build, lint, test.
- Codegen pipeline: types + validators, CI drift check.

M1 — MVP Builders + Read‑Only Client (2 weeks)

- Builders: `WorkflowBuilder`, `TaskBuilder` for `basic`, triggers, schedule, agent, tool.
- Client: `workflows.list/get`, `tasks/agents/tools` read‑only.
- Examples + golden tests.

M2 — Writes, ETag, Execute (2 weeks)

- Client writes: `upsert/delete` with `ifMatch/ifNoneMatch`.
- `workflows.execute`; executions `get/list` with pagination helpers.
- Unit + contract tests.

M3 — Advanced Tasks (2–3 weeks)

- `TaskBuilder`: router, parallel, collection, composite.
- YAML I/O helpers and `$ref` convenience utilities.

M4 — MCP Extras & Docs (1–2 weeks)

- `@compozy/sdk/mcp` subpath; re‑exports + helper.
- Full documentation site with end‑to‑end examples.

---

## 11. Risks & Mitigations

- Schema drift → codegen + CI drift check; no handwritten shapes.
- Logic duplication → builders stay shape‑only; server compiles/validates.
- ETag/concurrency pitfalls → first‑class API and examples; retries opt‑in.
- Pagination inconsistencies → Link‑header parser with tests.
- Bundle size → precompiled validators, optional subpaths, sideEffects:false.

---

## 12. High‑Level End‑to‑End Example

```ts
import { WorkflowBuilder, TaskBuilder, Ref } from "@compozy/sdk";
import { createClient } from "@compozy/sdk";

// 1) Define workflow in TS
function buildWf() {
  const wf = new WorkflowBuilder("etl-pipeline", "0.1.0");
  wf.setConfig({
    input: {
      type: "object",
      properties: { source: { type: "string" } },
      required: ["source"],
    },
  });

  const fanout = new TaskBuilder("parallel", "fanout");
  fanout.setStrategy("wait_all");
  fanout.addChildTask(
    new TaskBuilder("basic", "fetch")
      .setTool(Ref.create("http"))
      .setWith({ url: "{{ .workflow.input.source }}" })
      .build()
  );
  fanout.addChildTask(
    new TaskBuilder("basic", "extract")
      .setAgent(Ref.create("extractor"))
      .setWith({ prompt: "Extract fields" })
      .build()
  );
  wf.addTask(fanout.build());

  const load = new TaskBuilder("basic", "load")
    .setTool(Ref.create("db-writer"))
    .setWith({ table: "raw" })
    .setFinal(true)
    .build();
  wf.addTask(load);

  return wf.build();
}

// 2) Push to server
const client = createClient({
  baseURL: "http://localhost:8080/api/v0",
  apiKey: process.env.API_KEY!,
});
const wf = buildWf();
await client.workflows.upsert("etl-pipeline", wf, { ifNoneMatch: "*" });

// 3) Execute
const exec = await client.workflows.execute("etl-pipeline", {
  input: { source: "https://example.com/data.json" },
});
console.log(exec.id);
```

---

## 13. Alignment with Engine

- API versioning and base paths follow `engine/infra/server/routes/routes.go`.
- Workflow CRUD + executions map to `engine/workflow/router/register.go`.
- Builder mutual exclusivity mirrors `workflow.Config` compile checks.

---

## 14. Open Questions

- Execution streaming: expose streaming/logs if/when server supports it.
- Discovery: do we want a small `/api/version` endpoint for base path and version negotiation?
- Zod add‑on: offer optional Zod schemas for DX, behind a subpath?

---

## 15. Appendix — Minimal API Surface Map (MVP)

- Workflows
  - `GET /workflows`
  - `GET /workflows/:workflow_id`
  - `PUT /workflows/:workflow_id`
  - `DELETE /workflows/:workflow_id`
  - `POST /workflows/:workflow_id/executions`
  - `GET /workflows/:workflow_id/executions`

- Executions
  - `GET /executions/workflows`
  - `GET /executions/workflows/:exec_id`
  - `POST /executions/workflows/:exec_id/pause|resume|cancel|signals`

- Tasks/Agents/Tools/Memories
  - Top‑level list/get/put/delete
  - Import/Export where available

```
// Notes:
// - Builders output JSON matching snake_case keys.
// - All compile/default/link semantics remain server‑side.
// - Validation and YAML are optional modules for DX.
```
