---
description: Go coding standards covering project structure, code style, error handling, and dependency patterns for Compozy
globs:
  - "**/*.go"
alwaysApply: true
---

# Go Coding Standards

You are an expert in Go, microservices architecture, and clean backend development practices. Your role is to ensure code is idiomatic, modular, testable, and aligned with Compozy's established patterns and best practices.

## Project Structure and Organization

- Group code by feature/domain when appropriate (agent, task, tool, workflow)
- Keep package names simple and descriptive
- Follow the established pattern of separating interfaces from implementations

## Code Style and Standards

- Adhere to Go's official style guide and the project's `.golangci.yml` configuration
- Function length should not exceed 80 lines or 50 statements
- Line length should not exceed 120 characters
- Cyclomatic complexity should be kept below 15
- **DON'T ADD** comments to explain code changes - explanation belongs in text responses
- Only add code comments when user explicitly requests them or code is complex and requires context for future developers

## Error Handling

**MANDATORY PATTERNS:**
- Always check and handle errors explicitly
- **Use structured errors:** `core.NewError(err, "CODE", details)` for project errors
- **Use error wrapping:** `fmt.Errorf("context: %w", err)` for context
- **Transaction pattern:**
  ```go
  defer func() {
      if err != nil { tx.Rollback(ctx) } else { tx.Commit(ctx) }
  }()
  ```
- Avoid naked returns in longer functions (as enforced by nakedret linter)
- Return early on errors to avoid deep nesting

## Dependencies and Interfaces

- Prefer explicit dependency injection through constructor functions
- Use interfaces to define behavior and enable testing
- Follow the established pattern:
  ```go
  // Define interface
  type Service interface {
    DoSomething(ctx context.Context, param string) error
  }

  // Implement interface
  type ServiceImpl struct {
    dependency Dependency
  }

  // Constructor function
  func NewService(dependency Dependency) Service {
    return &serviceImpl{
      dependency: dependency,
    }
  }
  ```

## Context and Concurrency

- Use `context.Context` for request-scoped values, deadlines, and cancellations
- Pass context as the first parameter to functions that make external calls
- Use the noctx linter to enforce context propagation
- Ensure goroutines are properly managed and cleaned up
