---
alwaysApply: true
---

# Architecture & Design Principles

## Overview

Establish comprehensive architectural standards and design principles for building maintainable, scalable, and robust software following industry best practices adapted to the project's domain-driven structure.

## Core Architectural Principles

### SOLID Principles

#### Single Responsibility Principle (SRP)

- Each module, class, or function should have only one reason to change
- Separate business logic, data access, and presentation concerns
- Use domain-specific packages in `engine/` for business domains
- *Implementation patterns: see @.cursor/rules/go-coding-standards.mdc#constructors--responsibilities-srp*

#### Open/Closed Principle (OCP)

- Open for extension, closed for modification
- Use interfaces and composition over inheritance
- Leverage factory patterns for extensible behavior
- *Factory implementation: see @.cursor/rules/go-coding-standards.mdc#factories--defaults-ocp*

#### Liskov Substitution Principle (LSP)

- Subtypes must be substitutable for their base types
- Interface implementations must honor contracts
- Ensure interface methods behave consistently
- *See @.cursor/rules/go-coding-standards.mdc#dependencies-and-interfaces-isp*

#### Interface Segregation Principle (ISP)

- Clients should not depend on interfaces they don't use
- Create small, focused interfaces
- Use interface composition for complex behavior
- *Implementation: see @.cursor/rules/go-coding-standards.mdc#interface-segregation-principle*

#### Dependency Inversion Principle (DIP)

- Depend on abstractions, not concretions
- Use dependency injection through constructors
- High-level modules should not depend on low-level modules
- *Constructor patterns: see @.cursor/rules/go-coding-standards.mdc#dependency-injection-pattern*

### DRY Principle (Don't Repeat Yourself)

#### Code Reuse Strategies

- Extract common functionality into shared packages
- Use generic functions for similar operations
- Create utility packages for cross-cutting concerns
- Centralize configuration with defaults
- Use template engine for dynamic configurations
- Avoid duplicating configuration logic
- *See @.cursor/rules/go-coding-standards.mdc for implementation patterns*

### Clean Architecture

#### Project Structure

```
compozy/
├── engine/                 # Business Logic Layer
│   ├── Core Domains:
│   │   ├── agent/         # AI agent orchestration
│   │   ├── task/          # Task execution (legacy)
│   │   ├── task2/         # Task execution (current)
│   │   ├── tool/          # Tool management and execution
│   │   ├── workflow/      # Workflow orchestration
│   │   └── runtime/       # Runtime execution environment
│   │
│   ├── AI & Intelligence:
│   │   ├── llm/           # LLM provider orchestration
│   │   ├── memory/        # Memory management and persistence
│   │   ├── memorycfg/  # Memory configuration
│   │   ├── knowledge/     # Knowledge bases and RAG
│   │   └── model/         # AI model definitions
│   │
│   ├── Infrastructure:
│   │   ├── infra/         # Infrastructure adapters
│   │   │   ├── cache/     # Caching layer (Redis/Memory)
│   │   │   ├── postgres/  # PostgreSQL database
│   │   │   ├── redis/     # Redis client
│   │   │   ├── server/    # HTTP server and routing
│   │   │   ├── store/     # Storage abstractions
│   │   │   ├── repo/      # Repository implementations
│   │   │   └── monitoring/# Observability (metrics, traces)
│   │   └── core/          # Shared domain primitives
│   │
│   ├── Integration & Communication:
│   │   ├── mcp/           # Model Context Protocol
│   │   ├── webhook/       # Webhook handling
│   │   ├── attachment/    # File and media processing
│   │   └── resources/     # Resource management
│   │
│   ├── Cross-Cutting:
│   │   ├── auth/          # Authentication and authorization
│   │   ├── autoload/      # Auto-discovery and loading
│   │   ├── project/       # Project management
│   │   ├── schema/        # Schema definitions and validation
│   │   └── worker/        # Background worker processes
│   │
├── pkg/                    # Shared Packages Layer
│   ├── config/            # Configuration management
│   ├── logger/            # Structured logging
│   ├── mcp-proxy/         # MCP proxy server
│   ├── template/          # Template engine
│   ├── tplengine/         # Template processing
│   ├── schemagen/         # Schema generation
│   ├── swagger/           # API documentation generation
│   ├── release/           # Release management
│   └── version/           # Version information
│
├── cli/                    # CLI Layer
│   ├── cmd/               # Command implementations
│   ├── api/               # API client
│   ├── helpers/           # CLI utilities
│   └── tui/               # Terminal UI components
│
├── test/                   # Testing Infrastructure
│   ├── helpers/           # Test utilities
│   └── integration/       # Integration tests
│
├── docs/                   # Documentation Site (Next.js)
├── schemas/               # JSON Schema definitions
└── examples/              # Example projects and workflows
```

#### Layer Separation

**Domain Layer** (`engine/core/`):
- Shared business entities, value objects, and cross-domain primitives
- Core types used across multiple domains
- No external dependencies

**Application Layer** (Domain packages in `engine/`):
- Domain-specific business logic and use cases
- Port interfaces (repositories, external services)
- Organized by feature/domain (agent, task, tool, workflow, etc.)
- Each domain has:
  - `uc/` - Use cases (application logic)
  - `router/` - HTTP route handlers (when exposed via API)
  - Domain-specific types and validators

**Infrastructure Layer** (`engine/infra/`):
- Adapter implementations for external systems
- Database access (PostgreSQL, Redis)
- HTTP server and routing
- Caching implementations
- Monitoring and observability
- Storage abstractions

**Shared Packages** (`pkg/`):
- Framework-level utilities
- Configuration management
- Logging infrastructure
- Template processing
- Schema generation
- No business logic

**Presentation Layer** (`cli/`):
- Command-line interface
- User interaction and formatting
- API client for server communication

#### Interface Ownership

- **Port Interfaces** (e.g., Repository, ExternalService): Defined in Application Layer packages where they're used
- **Domain Entities**: Defined in Domain Layer (`engine/core/`) for cross-domain sharing
- **Adapter Implementations**: Defined in Infrastructure Layer, implementing Application Layer interfaces

#### Dependency Flow Pattern

Dependencies must always flow inward toward the domain layer:
- Infrastructure → Application → Domain
- CLI → Application → Domain
- Shared packages can be used by any layer (no business logic)

```go
// ✅ Good: Dependencies flow inward
package task

import (
    "context"
    "github.com/compozy/engine/core" // Domain entities
)

type Service struct {
    repo Repository // Interface defined in application layer
}

type Repository interface { // Application layer interface
    Save(ctx context.Context, task *core.Task) error
    Find(ctx context.Context, id core.ID) (*core.Task, error)
}

// Implementation in infrastructure layer
package infra

import (
    "github.com/compozy/engine/task" // Application layer
)

type PostgreSQLTaskRepository struct {
    db *sql.DB
}

func (r *PostgreSQLTaskRepository) Save(ctx context.Context, task *core.Task) error {
    // Implementation
}
```

### Clean Code Practices

#### Naming Conventions

- Use intention-revealing names
- Avoid mental mapping and abbreviations
- Use searchable names for important concepts
- Function/method names should clearly indicate their purpose
- Type names should be descriptive of what they represent

#### Function Design

- Follow function length limits defined in @.cursor/rules/go-coding-standards.mdc
- Single level of abstraction per function
- Minimize function parameters (max 3-4)
- Return early on errors to avoid deep nesting

#### Implementation Standards

- **Error Handling:** See @.cursor/rules/go-coding-standards.mdc#unified-error-handling-strategy
- **Context Propagation:** See @.cursor/rules/go-coding-standards.mdc#context--resource-lifecycle
- **Resource Management:** See @.cursor/rules/go-coding-standards.mdc#resource-cleanup-patterns
- **Concurrency:** See @.cursor/rules/go-coding-standards.mdc#concurrency--shutdown

## Project-Specific Patterns

### Domain Organization

Each domain in `engine/` follows a consistent structure:

```
domain/
├── config.go              # Domain configuration
├── service.go             # Domain service
├── types.go               # Domain-specific types
├── validators.go          # Input validation
├── uc/                    # Use cases (application logic)
│   ├── create.go
│   ├── update.go
│   ├── delete.go
│   └── query.go
└── router/                # HTTP handlers (if exposed)
    ├── handlers.go
    ├── dto.go
    └── router.go
```

**Key Principles:**
- Each domain has clear boundaries
- Shared types in `engine/core/`
- Infrastructure concerns in `engine/infra/`
- Use cases (`uc/`) contain business logic
- Routers contain HTTP handling only

### Service Construction Requirements (MANDATORY)

- Use dependency injection through constructors
- Always provide nil-safe configuration handling
- Follow factory patterns for complex service creation
- *See @.cursor/rules/go-coding-standards.mdc#factories--defaults-ocp*

### Context Propagation Requirements (MANDATORY)

- Context as first parameter in all functions that perform I/O or long-running operations
- Always handle context cancellation
- Propagate context through call chains
- *See @.cursor/rules/go-coding-standards.mdc#context--resource-lifecycle*

### Configuration Management

- Global configuration in `pkg/config/`
- Domain-specific configuration in each domain
- Use context to pass configuration: `config.FromContext(ctx)`
- Never use global configuration singletons
- Always provide defaults for optional configuration

### Use Case Pattern

Use cases (`uc/` directories) implement application logic:

```go
// Use case structure
type CreateTask struct {
    taskRepo task.Repository
    validator task.Validator
}

func NewCreateTask(taskRepo task.Repository, validator task.Validator) *CreateTask {
    return &CreateTask{
        taskRepo: taskRepo,
        validator: validator,
    }
}

func (uc *CreateTask) Execute(ctx context.Context, req CreateTaskRequest) (*core.Task, error) {
    // Validation
    // Business logic
    // Persistence
}
```

## Anti-Patterns to Avoid

### God Objects

```go
// ❌ Avoid: Too many responsibilities
type MegaService struct {
    // Too many dependencies and responsibilities
}
```

### Tight Coupling

```go
// ❌ Avoid: Direct dependency on concrete types
type Service struct {
    db *sql.DB // Should be an interface
}

// ✅ Good: Depend on abstractions
type Service struct {
    db Database // Interface
}
```

### Circular Dependencies

```go
// ❌ Avoid: Package A imports B, B imports A
// This indicates poor package organization
```

## Quality Metrics

### Code Quality Indicators

- **Function complexity and length:** Follow limits in @.cursor/rules/go-coding-standards.mdc
- **Package Coupling:** Minimize cross-package dependencies
- **Test Coverage:** Aim for 80%+ on business logic
- **Cyclomatic Complexity:** Keep below 10 per function

### Architecture Health

- **Dependency Direction:** Always inward toward domain
- **Interface Usage:** High ratio of interfaces to concrete types in domain boundaries
- **Package Cohesion:** Related functionality grouped together
- **Separation of Concerns:** Clear boundaries between layers
- **Domain Isolation:** Each domain in `engine/` is independently testable

## Guidelines

1. **Design for Change:** Assume requirements will evolve
2. **Favor Composition:** Over inheritance and complex hierarchies
3. **Explicit Dependencies:** Make all dependencies visible through constructors
4. **Fail Fast:** Validate inputs early and fail explicitly
5. **Document Decisions:** Capture architectural decisions and trade-offs
6. **Refactor Continuously:** Improve design as understanding grows
7. **Test Architecture:** Verify architectural constraints in tests
8. **Follow Standards:** All implementation patterns in @.cursor/rules/go-coding-standards.mdc
9. **Domain Boundaries:** Respect domain boundaries and avoid cross-domain dependencies
10. **Infrastructure Isolation:** Keep infrastructure concerns in `engine/infra/` only
