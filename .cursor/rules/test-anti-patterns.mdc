---
description: Critical test anti-patterns to prevent based on comprehensive codebase analysis - prevents test redundancy, low-value tests, and coverage inflation
globs:
alwaysApply: false
---

# Test Anti-Patterns - NEVER DO THESE

<critical>
**BASED ON COMPREHENSIVE CODEBASE ANALYSIS:**
This document captures critical test anti-patterns discovered through analysis of 4,000+ tests in the Compozy codebase. These patterns led to:
- 75-80% test redundancy
- Low coverage despite high test count
- Maintenance overhead
- False confidence in test quality

**ENFORCEMENT:** Violating these anti-patterns results in immediate code review rejection.
</critical>

## üö® CRITICAL: Redundancy Anti-Patterns

<redundancy_anti_patterns type="immediate_rejection">
**DISCOVERED PATTERNS - NEVER REPEAT:**

‚ùå **ANTI-PATTERN 1: Cross-Package Validation Duplication**
```go
// ‚ùå FOUND IN 9+ PACKAGES - DO NOT REPEAT
func TestConfig_Validation(t *testing.T) {
    t.Run("Should validate required fields", func(t *testing.T) {
        config := &Config{} // Only type differs between packages
        err := config.Validate()
        assert.Error(t, err)
        assert.Contains(t, err.Error(), "required field")
    })
}
```
**WHY PROHIBITED:** Found 70+ identical tests across packages testing same validation logic.

‚ùå **ANTI-PATTERN 2: Identical Mock Setup Patterns**
```go
// ‚ùå FOUND 259 TIMES - DO NOT REPEAT
mockRepo.On("GetState", mock.Anything, mock.Anything).Return((*task.State)(nil), nil)
mockRepo.On("GetStateForUpdate", ctx, mock.Anything, taskState.TaskExecID).Return(taskState, nil)
```
**WHY PROHIBITED:** Same mock setup repeated verbatim across 50+ test files.

‚ùå **ANTI-PATTERN 3: Response Handler Constructor Duplication**
```go
// ‚ùå FOUND IN 7+ HANDLER TYPES - DO NOT REPEAT
func TestNewResponseHandler(t *testing.T) {
    t.Run("Should create handler with dependencies", func(t *testing.T) {
        templateEngine := &tplengine.TemplateEngine{}
        contextBuilder := &shared.ContextBuilder{}
        baseHandler := &shared.BaseResponseHandler{}
        
        handler := NewResponseHandler(templateEngine, contextBuilder, baseHandler)
        
        assert.NotNil(t, handler)
        assert.Equal(t, templateEngine, handler.templateEngine) // Same assertions
    })
}
```
**WHY PROHIBITED:** Identical constructor tests across all response handler types.
</redundancy_anti_patterns>

## üö® CRITICAL: Low-Value Test Anti-Patterns

<low_value_anti_patterns type="immediate_rejection">
**DISCOVERED PATTERNS - PROVIDE ZERO VALUE:**

‚ùå **ANTI-PATTERN 4: Getter/Setter Tests**
```go
// ‚ùå FOUND 22+ TIMES - PROVIDES ZERO VALUE
func TestConfig_GetOutput(t *testing.T) {
    t.Run("Should return output", func(t *testing.T) {
        config := &Config{Output: "test"}
        assert.Equal(t, "test", config.GetOutput()) // Tests obvious field access
    })
}
```
**WHY PROHIBITED:** Tests obvious behavior that cannot fail.

‚ùå **ANTI-PATTERN 5: Constructor Non-Nil Tests**
```go
// ‚ùå FOUND 8+ TIMES - PROVIDES ZERO VALUE
func TestNewOverrideCache(t *testing.T) {
    t.Run("Should create cache", func(t *testing.T) {
        cache := NewOverrideCache()
        assert.NotNil(t, cache) // Only tests object creation
    })
}
```
**WHY PROHIBITED:** Tests that constructor returns non-nil provide no business value.

‚ùå **ANTI-PATTERN 6: Framework Functionality Tests**
```go
// ‚ùå FOUND 25+ TIMES - TESTS GO STANDARD LIBRARY
func TestOutputsValidator_CompatibilityWithGoTemplates(t *testing.T) {
    // Tests Go's template parser works correctly
    // This tests framework functionality, not business logic
}
```
**WHY PROHIBITED:** Tests Go standard library instead of application logic.

‚ùå **ANTI-PATTERN 7: Mock-Heavy Tests with No Logic**
```go
// ‚ùå FOUND 35+ TIMES - 90% MOCK SETUP, 10% ACTUAL TEST
func TestService_Method(t *testing.T) {
    t.Run("Should call dependencies", func(t *testing.T) {
        // 20 lines of mock setup
        mockRepo := &MockRepo{}
        mockService := &MockService{}
        mockValidator := &MockValidator{}
        mockRepo.On("Get", mock.Anything).Return(nil, nil)
        mockService.On("Process", mock.Anything).Return(nil)
        mockValidator.On("Validate", mock.Anything).Return(nil)
        
        // 1 line of actual test
        service := NewService(mockRepo, mockService, mockValidator)
        err := service.Method()
        
        // Only verifies mocks were called, not business logic
        assert.NoError(t, err)
        mockRepo.AssertExpectations(t)
    })
}
```
**WHY PROHIBITED:** Tests mock framework functionality instead of business logic.
</low_value_anti_patterns>

## üö® CRITICAL: Coverage Inflation Anti-Patterns

<coverage_inflation_anti_patterns type="immediate_rejection">
**DISCOVERED PATTERNS - FALSE COVERAGE:**

‚ùå **ANTI-PATTERN 8: Weak Error Assertions**
```go
// ‚ùå FOUND 100+ TIMES - WEAK VALIDATION
func TestValidation(t *testing.T) {
    t.Run("Should return error", func(t *testing.T) {
        err := validate(invalidInput)
        assert.Error(t, err) // ‚ùå Doesn't verify what error or why
    })
}
```
**WHY PROHIBITED:** Executes code without verifying meaningful behavior.

‚ùå **ANTI-PATTERN 9: Field Assignment Tests**
```go
// ‚ùå FOUND 12+ TIMES - TESTS OBVIOUS OPERATIONS
func TestConfig_ApplyDefaults(t *testing.T) {
    t.Run("Should set default values", func(t *testing.T) {
        config := &Config{}
        config.ApplyDefaults()
        assert.Equal(t, defaultValue, config.Field) // Tests field assignment
    })
}
```
**WHY PROHIBITED:** Tests obvious field operations without business logic.

‚ùå **ANTI-PATTERN 10: Interface Implementation Tests**
```go
// ‚ùå FOUND 10+ TIMES - TESTS COMPILE-TIME BEHAVIOR
func TestServiceImplementsInterface(t *testing.T) {
    t.Run("Should implement interface", func(t *testing.T) {
        var _ ServiceInterface = &Service{} // Compile-time check only
        assert.True(t, true) // Meaningless assertion
    })
}
```
**WHY PROHIBITED:** Tests compile-time behavior that Go compiler already verifies.
</coverage_inflation_anti_patterns>

## üö® CRITICAL: Test Overlap Anti-Patterns

<test_overlap_anti_patterns type="immediate_rejection">
**DISCOVERED PATTERNS - DUPLICATE COVERAGE:**

‚ùå **ANTI-PATTERN 11: Integration/Unit Test Overlap**
```go
// ‚ùå FOUND IN MEMORY, MCP-PROXY, TASK PACKAGES
// Integration test: test/integration/memory/config_test.go
func TestMemoryConfig_ValidationIntegration(t *testing.T) {
    // Tests config validation with real components
}

// Unit test: engine/memory/config_test.go  
func TestMemoryConfig_Validation(t *testing.T) {
    // Tests same validation logic with mocks
}
```
**WHY PROHIBITED:** Same functionality tested in both unit and integration suites.

‚ùå **ANTI-PATTERN 12: HTTP Handler Duplication**
```go
// ‚ùå FOUND IN MCP-PROXY PACKAGE
// Integration test: Full HTTP server testing
func TestMCPProxy_HTTPHandlers(t *testing.T) {
    // Tests actual HTTP endpoints
}

// Unit test: Mock HTTP testing  
func TestMCPProxy_Handlers(t *testing.T) {
    // Tests same handlers with httptest.NewRecorder
}
```
**WHY PROHIBITED:** HTTP handlers tested at both unit and integration levels.
</test_overlap_anti_patterns>

## ‚úÖ CORRECT PATTERNS TO FOLLOW

<correct_patterns type="implementation_guide">
**REPLACE ANTI-PATTERNS WITH THESE:**

‚úÖ **PATTERN 1: Shared Validation Framework**
```go
// test/helpers/validation_suite.go
type ValidationSuite struct {
    ValidatorType reflect.Type
    TestCases     []ValidationTest
}

func (s *ValidationSuite) RunTests(t *testing.T) {
    // Generic validation testing for all packages
}

// Usage across packages
func TestAgentConfig_Validation(t *testing.T) {
    suite := validation.NewConfigValidationSuite(reflect.TypeOf(&agent.Config{}))
    suite.RunTests(t)
}
```

‚úÖ **PATTERN 2: Shared Mock Factory**
```go
// test/mocks/factory.go
func CreateStandardMocks() *TestMocks {
    return &TestMocks{
        Repository: createMockRepository(),
        Service:    createMockService(),
    }
}

func (m *TestMocks) SetupStandardExpectations() {
    // Common mock expectations used across tests
}
```

‚úÖ **PATTERN 3: Business Logic Testing**
```go
func TestWorkflow_Execute(t *testing.T) {
    t.Run("Should transition state and maintain invariants", func(t *testing.T) {
        workflow := &Workflow{State: StateRunning}
        result, err := workflow.Execute(validInput)
        
        // Test business logic and side effects
        require.NoError(t, err)
        assert.Equal(t, StateCompleted, workflow.State)
        assert.True(t, result.CompletedAt.After(result.StartedAt))
        assert.Contains(t, result.Output, expectedData)
    })
}
```

‚úÖ **PATTERN 4: Specific Error Validation**
```go
func TestValidation_SecurityChecks(t *testing.T) {
    t.Run("Should reject malicious input with specific error", func(t *testing.T) {
        err := validator.Validate(maliciousInput)
        
        require.Error(t, err)
        assert.ErrorContains(t, err, "security violation")
        assert.ErrorContains(t, err, "script injection")
        
        var securityErr *SecurityError
        assert.ErrorAs(t, err, &securityErr)
        assert.Equal(t, SecurityViolationScript, securityErr.Type)
    })
}
```
</correct_patterns>

## üìã Test Review Checklist

<review_checklist type="mandatory">
**BEFORE WRITING ANY TEST, ASK:**

1. **Value Check:**
   - Does this test verify meaningful business logic?
   - Would this test fail if business requirements change?
   - Does this test verify behavior, not just code execution?

2. **Redundancy Check:**
   - Is this functionality already tested elsewhere?
   - Can this test be consolidated with existing patterns?
   - Am I duplicating validation/mock logic from other tests?

3. **Coverage Check:**
   - Does this test contribute to meaningful coverage?
   - Am I testing critical paths or trivial operations?
   - Will this test catch real bugs in production?

4. **Efficiency Check:**
   - Can this test be part of a shared test framework?
   - Am I creating more setup than actual testing?
   - Is this the right level (unit vs integration) for this test?

**IF ANY ANSWER IS NO: Reconsider or redesign the test.**
</review_checklist>

## üéØ Implementation Guidelines

<implementation_guidelines type="actionable">
**IMMEDIATE ACTIONS WHEN WRITING TESTS:**

1. **Search First:** Check if similar functionality is already tested
2. **Consolidate:** Use existing test helpers and frameworks when possible
3. **Focus:** Test business logic and critical paths, not trivial operations
4. **Validate:** Ensure tests verify meaningful behavior with specific assertions
5. **Review:** Apply the test review checklist before submitting

**WHEN REVIEWING TESTS:**
- Reject tests that match any anti-pattern in this document
- Require consolidation of duplicate test scenarios
- Demand specific error validation instead of weak assertions
- Enforce business logic testing over framework testing
</implementation_guidelines>

These anti-patterns are based on real analysis of test redundancy and inefficiency in the Compozy codebase. Following these guidelines will prevent the accumulation of low-value tests and maintain a lean, effective test suite.
