---
description: Comprehensive testing standards and patterns for Compozy Go development - enforces mandatory t.Run patterns, testify usage, and mock standards
globs:
alwaysApply: false
---

# Testing Standards for Compozy Go Development

<critical>
**MANDATORY REQUIREMENTS:**
- **ALWAYS** check dependent files APIs before write tests to avoid write wrong code
- **ALWAYS** verify against PRD and tech specs - NEVER make assumptions
- **NEVER** use workarounds, especially in tests - implement proper solutions
- **MUST** follow all established project standards:
    - Architecture patterns: `.cursor/rules/architecture.mdc`
    - Go coding standards: `.cursor/rules/go-coding-standards.mdc`
    - Testing requirements: `.cursor/rules/testing-standards.mdc`
    - API standards: `.cursor/rules/api-standards.mdc`
    - Security & quality: `.cursor/rules/quality-security.mdc`
- **MUST** run `make lint` and `make test` before completing ANY subtask
- **MUST** follow `.cursor/rules/task-review.mdc` workflow for parent tasks
**Enforcement:** Violating these standards results in immediate task rejection.
**CRITICAL:** Also review `.cursor/rules/test-anti-patterns.mdc` for comprehensive anti-patterns based on codebase analysis.
</critical>

## Core Testing Requirements

<requirements type="mandatory">
**MANDATORY testing patterns for all Go code:**
- Use `t.Run("Should describe expected behavior")` pattern for all tests
- Use `stretchr/testify` for assertions and mocks
- Follow table-driven test patterns when appropriate
- Achieve >85% coverage for business logic packages
</requirements>

## Testing Requirements

<requirements type="mandatory">
- **ALL tests MUST use `t.Run("Should...")` pattern** - no direct test implementation without t.Run wrapper
- Test function names: `func TestModuleName_MethodName(t *testing.T)`
- Each test case within t.Run with descriptive "Should..." names
- MUST use `stretchr/testify` for assertions and mocks
- **STANDARDIZE ON TESTIFY MOCK:** Replace existing custom mocks with `testify/mock` implementations
</requirements>

## Anti-Patterns to Avoid

<anti_patterns type="prohibited_patterns">
**NEVER USE TESTIFY SUITE PATTERNS:**

- ❌ **PROHIBITED:** `suite.Suite` embedding or any suite-based test structures
- ❌ **PROHIBITED:** Suite methods like `s.Equal()`, `s.NoError()`, `s.True()`, `s.False()`, `s.T()`
- ❌ **PROHIBITED:** `testsuite.WorkflowTestSuite` or similar suite embeddings
- ❌ **PROHIBITED:** Suite lifecycle methods like `SetupTest()`, `TearDownTest()`, `AfterTest()`

**USE DIRECT ASSERTIONS INSTEAD:**

- ✅ **REQUIRED:** `assert.Equal(t, expected, actual)`
- ✅ **REQUIRED:** `require.NoError(t, err)`
- ✅ **REQUIRED:** `assert.True(t, condition)`
- ✅ **REQUIRED:** Individual test functions with `*testing.T` parameter
</anti_patterns>

## CRITICAL: Redundancy Prevention

<critical_reference>
**COMPREHENSIVE ANTI-PATTERNS:** See `.cursor/rules/test-anti-patterns.mdc` for detailed analysis of 12 critical anti-patterns discovered in the codebase that led to 75-80% test redundancy.
</critical_reference>

<redundancy_prevention type="critical_anti_patterns">
**NEVER CREATE REDUNDANT TESTS:**

❌ **PROHIBITED: Cross-Package Validation Duplication**
- Do NOT create identical config validation tests in multiple packages
- Do NOT duplicate error handling patterns across packages
- Do NOT repeat the same validation logic in multiple test files

❌ **PROHIBITED: Meaningless Tests**
- Do NOT test trivial getter/setter methods without business logic
- Do NOT test basic constructor functionality that only assigns fields
- Do NOT test Go standard library functionality (JSON marshal/unmarshal, template parsing)
- Do NOT test interface implementations that have no custom logic

❌ **PROHIBITED: Mock-Heavy Tests**
- Do NOT create tests that are 90% mock setup with minimal business logic testing
- Do NOT test mock framework functionality instead of application logic
- Do NOT mock simple interfaces that don't require external dependencies

❌ **PROHIBITED: Duplicate Test Scenarios**
- Do NOT create identical test scenarios across different test files
- Do NOT repeat the same test patterns with only minor type variations
- Do NOT duplicate integration test logic in unit test files

❌ **PROHIBITED: Over-Testing Simple Functions**
- Do NOT create multiple tests for simple utility functions
- Do NOT test obvious behavior (field assignments, basic operations)
- Do NOT create excessive edge case tests for trivial operations
</redundancy_prevention>

<test_value_requirements type="mandatory">
**EVERY TEST MUST PROVIDE VALUE:**

✅ **REQUIRED: Meaningful Business Logic Testing**
- Test complex business rules and logic flows
- Test error handling that affects system behavior
- Test integration points between components
- Test state management and transitions

✅ **REQUIRED: Proper Assertions**
- Use specific error message validation: `assert.ErrorContains(t, err, "expected message")`
- Verify side effects and state changes, not just function completion
- Test actual behavior outcomes, not just that functions were called
- Validate business invariants and constraints

✅ **REQUIRED: Test Critical Paths**
- Focus on workflows, orchestration, and coordination logic
- Test failure scenarios and recovery mechanisms
- Test concurrent access and race condition prevention
- Test security boundaries and validation logic
</test_value_requirements>

<anti_patterns type="bad_examples">

```go
// ❌ NEVER DO THIS - Suite pattern is prohibited
type MyTestSuite struct {
    suite.Suite
    // other fields
}

func (s *MyTestSuite) TestSomething() {
    s.Equal("expected", "actual")  // ❌ WRONG
    s.NoError(err)                 // ❌ WRONG
    s.T().Run("test", func(t *testing.T) { ... }) // ❌ WRONG
}

// ❌ NEVER DO THIS - Redundant config validation across packages
func TestConfig_Validation(t *testing.T) {
    t.Run("Should validate required fields", func(t *testing.T) {
        config := &Config{} // ❌ REDUNDANT if same pattern exists in other packages
        err := config.Validate()
        assert.Error(t, err)
        assert.Contains(t, err.Error(), "required field") // ❌ WEAK ASSERTION
    })
}

// ❌ NEVER DO THIS - Meaningless getter/setter tests
func TestConfig_GetOutput(t *testing.T) {
    t.Run("Should return output", func(t *testing.T) {
        config := &Config{Output: "test"}
        assert.Equal(t, "test", config.GetOutput()) // ❌ TESTS OBVIOUS BEHAVIOR
    })
}

// ❌ NEVER DO THIS - Mock-heavy tests with no business logic
func TestService_Method(t *testing.T) {
    t.Run("Should call dependencies", func(t *testing.T) {
        // 20 lines of mock setup ❌
        mockRepo := &MockRepo{}
        mockService := &MockService{}
        mockValidator := &MockValidator{}
        mockRepo.On("Get", mock.Anything).Return(nil, nil)
        mockService.On("Process", mock.Anything).Return(nil)
        mockValidator.On("Validate", mock.Anything).Return(nil)
        
        // 1 line of actual test ❌
        service := NewService(mockRepo, mockService, mockValidator)
        err := service.Method()
        
        // Only tests mocks were called, not business logic ❌
        assert.NoError(t, err)
        mockRepo.AssertExpectations(t)
    })
}

// ✅ DO THIS INSTEAD - Direct test functions with meaningful logic
func TestWorkflow_ExecuteWithValidation(t *testing.T) {
    t.Run("Should execute workflow and transition state correctly", func(t *testing.T) {
        // Test actual business logic and state transitions
        workflow := &Workflow{State: StateRunning}
        result, err := workflow.Execute(validInput)
        
        // Test meaningful behavior and side effects
        require.NoError(t, err)
        assert.Equal(t, StateCompleted, workflow.State) // ✅ TESTS STATE CHANGE
        assert.Equal(t, expectedOutput, result.Output)  // ✅ TESTS BUSINESS LOGIC
        assert.True(t, workflow.CompletedAt.After(workflow.StartedAt)) // ✅ TESTS INVARIANTS
    })
    
    t.Run("Should handle validation errors and maintain state consistency", func(t *testing.T) {
        workflow := &Workflow{State: StateRunning}
        result, err := workflow.Execute(invalidInput)
        
        // Test error handling affects system behavior
        assert.Error(t, err)
        assert.ErrorContains(t, err, "validation failed") // ✅ SPECIFIC ERROR VALIDATION
        assert.Equal(t, StateRunning, workflow.State)      // ✅ TESTS STATE PRESERVATION
        assert.Nil(t, result)                              // ✅ TESTS ERROR BEHAVIOR
    })
}
```

</anti_patterns>

## Table-Driven Tests

<guidelines type="table_tests">
- AVOID table-driven tests for 2-3 cases
- ONLY use when 5+ similar variations exist
- Each table test case must still use "Should..." naming
</guidelines>

## Test Organization

<organization_rules>
- **Unit Tests**: Place `*_test.go` files alongside implementation files
- **Integration Tests**: **MUST** live under `test/integration/` directory - NO EXCEPTIONS
- Each test MUST be independent and repeatable
- Mock external dependencies **only when necessary** using `testify/mock`
- Use project test helpers: `utils.SetupTest()`, `utils.SetupFixture()`
- Test both success and error paths
- Ensure test coverage for all exported functions
</organization_rules>

<test_consolidation type="mandatory">
**PREVENT TEST DUPLICATION:**

✅ **REQUIRED: Shared Test Utilities**
- Create `test/helpers/` directory for shared test utilities
- Use generic validation test frameworks instead of duplicating validation logic
- Create shared mock factories instead of duplicating mock setup patterns
- Extract common test patterns into reusable helpers

✅ **REQUIRED: Test Consolidation Patterns**
- Use table-driven tests for similar scenarios with different parameters
- Create parametrized test frameworks for common patterns (config validation, error handling)
- Consolidate identical test scenarios across packages into shared test suites

❌ **PROHIBITED: Test Pattern Duplication**
- Do NOT create identical mock setup patterns across multiple test files
- Do NOT duplicate the same test scenario in multiple packages
- Do NOT repeat validation test logic when it can be shared
</test_consolidation>

<integration_test_location type="mandatory">
**INTEGRATION TEST LOCATION REQUIREMENT:**

- **ALL integration tests MUST be placed in `test/integration/` directory**
- **NEVER place integration tests alongside unit tests in package directories**
- Integration tests include: database tests, HTTP API tests, external service tests, end-to-end workflow tests
- Use subdirectories under `test/integration/` to organize by domain: `test/integration/memory/`, `test/integration/workflow/`, etc.
- Integration test files follow same naming: `*_test.go`
  </integration_test_location>

## Mock Standards

<when_to_mock>
**WHEN TO USE MOCKS:**

- External services (HTTP clients, databases, file systems)
- Dependencies that are slow, unreliable, or have side effects
- Complex interfaces that would make tests brittle or slow
- **NOT REQUIRED** for simple functions, pure logic, or internal utilities
  </when_to_mock>

<pattern type="mock_implementation">
```go
// Define mock interface
type MockService struct {
    mock.Mock
}

func (m \*MockService) DoSomething(ctx context.Context, param string) error {
args := m.Called(ctx, param)
return args.Error(0)
}

// Usage in tests
func TestComponent_Method(t *testing.T) {
t.Run("Should use mocked service", func(t *testing.T) {
mockService := new(MockService)
mockService.On("DoSomething", mock.Anything, "test").Return(nil)

        component := NewComponent(mockService)
        err := component.Method("test")

        assert.NoError(t, err)
        mockService.AssertExpectations(t)
    })

}

````
</pattern>

<refactoring_priorities>
- Replace custom mocks with testify/mock implementations
- Migrate interface-based mocks to use `mock.Mock` embedding
- Standardize mock setup and assertion patterns across the codebase
</refactoring_priorities>

<example type="test_structure">
```go
func TestService_Method(t *testing.T) {
    t.Run("Should succeed with valid input", func(t *testing.T) {
        // arrange, act, assert
    })

    t.Run("Should handle error cases", func(t *testing.T) {
        // test implementation
    })
}
````

</example>

## Test Patterns

<patterns type="testing_best_practices">
- **Arrange-Act-Assert:** Structure all tests with clear setup, execution, and verification phases
- **Independent Tests:** Each test should be able to run in isolation
- **Descriptive Names:** Use "Should..." pattern to describe expected behavior
- **Mock When Necessary:** Use testify/mock only for external dependencies or complex interfaces
- **Context Propagation:** Pass context to functions that require it, even in tests
- **Mock Assertions:** When using mocks, always call `mockService.AssertExpectations(t)` to verify all expected calls were made
- **Mock Cleanup:** Use `mock.AnythingOfType()` and `mock.Anything` for flexible parameter matching
</patterns>

## Test Coverage Requirements

<coverage_requirements type="unified">
**Unified Coverage Standard:**

- **Business Logic Packages**: All code in `engine/{agent,task,tool,workflow}/` must achieve ≥80% test coverage
- **Exported Functions**: All exported functions across the codebase must have meaningful tests (not just presence tests)
- **Coverage Focus**: Prioritize testing business logic paths over trivial getters/setters
- **Quality Gate**: Use coverage reports to identify gaps in business logic, not just check for test existence
</coverage_requirements>

<coverage_quality type="critical">
**COVERAGE QUALITY REQUIREMENTS:**

✅ **REQUIRED: Meaningful Coverage**
- Coverage MUST come from testing actual business logic, not trivial operations
- Focus on critical paths: workflow orchestration, state management, error handling
- Test integration points between components and modules
- Verify security boundaries and validation logic

❌ **PROHIBITED: Coverage Inflation**
- Do NOT count trivial getter/setter tests toward coverage goals
- Do NOT create tests that execute code without verifying behavior
- Do NOT test framework functionality to inflate coverage percentages
- Do NOT mock everything just to achieve high coverage numbers

✅ **REQUIRED: Critical Component Coverage**
- **Workflow Activities**: ALL workflow activities MUST have comprehensive tests
- **State Management**: ALL state transitions and consistency rules MUST be tested
- **API Endpoints**: ALL HTTP endpoints MUST have integration tests
- **Use Cases**: ALL business use cases MUST have complete test coverage
- **Error Handling**: ALL error scenarios MUST be tested with proper recovery verification
</coverage_quality>

## Test Efficiency and Quality

<test_efficiency type="critical_guidelines">
**CRITICAL: Test Efficiency Requirements**

❌ **NEVER CREATE LOW-VALUE TESTS:**
- Tests that only verify constructor creates non-nil objects
- Tests that only verify getter methods return assigned values
- Tests that only verify interface implementations exist without custom logic
- Tests that only check default configuration values are set
- Tests that duplicate Go standard library functionality testing

❌ **NEVER CREATE REDUNDANT VALIDATION:**
- Multiple tests for the same validation logic across packages
- Identical error handling test patterns repeated in multiple files
- Same mock setup patterns copied across test files
- Duplicate test scenarios with only type/name variations

✅ **REQUIRED: Test Efficiency Patterns:**
- Before creating a test, verify similar functionality isn't already tested elsewhere
- Use shared test helpers for common validation patterns
- Create generic test frameworks for repeated scenarios
- Focus tests on business logic and critical paths only

✅ **REQUIRED: Test Quality Gates:**
- Every test MUST verify meaningful behavior, not just code execution
- Every test MUST have specific assertions about expected outcomes
- Every test MUST test business logic, not framework functionality
- Every test MUST be able to fail when business logic is broken
</test_efficiency>

<shared_test_patterns type="implementation_guide">
**SHARED TEST PATTERN IMPLEMENTATION:**

```go
// ✅ CORRECT: Generic validation test framework
// test/helpers/validation_suite.go
type ValidationTest struct {
    Name           string
    Input          interface{}
    ExpectedError  string
    ShouldPass     bool
}

func RunValidationTests(t *testing.T, validator interface{}, tests []ValidationTest) {
    for _, test := range tests {
        t.Run(test.Name, func(t *testing.T) {
            // Generic validation testing logic
        })
    }
}

// ✅ CORRECT: Shared mock factory
// test/mocks/factory.go
func CreateStandardMocks() *TestMocks {
    return &TestMocks{
        Repository: createMockRepository(),
        Service:    createMockService(),
        Validator:  createMockValidator(),
    }
}

// ✅ CORRECT: Usage in test files
func TestWorkflow_Execute(t *testing.T) {
    mocks := mocks.CreateStandardMocks()
    workflow := NewWorkflow(mocks.Repository, mocks.Service)
    
    t.Run("Should execute workflow successfully", func(t *testing.T) {
        result, err := workflow.Execute(validInput)
        // Test actual business logic and outcomes
        require.NoError(t, err)
        assert.Equal(t, expectedState, workflow.State)
    })
}
```
</shared_test_patterns>

## Architectural Testing

<architectural_testing type="mandatory">
**MANDATORY: Architecture Constraint Validation**

- **Dependency Direction**: Test that dependencies flow inward toward domain
- **Layer Violations**: Prevent direct dependencies between Infrastructure and Domain layers
- **Circular Dependencies**: Automated detection of package cycles
- **Interface Compliance**: Verify adapters properly implement port interfaces

**Implementation Pattern:**

```go
func TestArchitecturalConstraints(t *testing.T) {
    t.Run("Should enforce dependency direction", func(t *testing.T) {
        // Test that engine/infra doesn't import engine/core directly
        // Test that engine/core doesn't import any other engine packages
    })

    t.Run("Should prevent circular dependencies", func(t *testing.T) {
        // Use go list or similar to detect cycles
    })
}
```

</architectural_testing>
