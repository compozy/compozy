#!/usr/bin/env bun
// .compozy/bun_worker.ts
// Generated by Compozy - DO NOT EDIT

// Import all tools from entrypoint
import * as allExports from "{{.EntrypointPath}}";

interface Request {
    tool_id: string;
    tool_exec_id: string;
    input: any;
    env: Record<string, string>;
    timeout_ms?: number;
}

interface Response {
    result: any;
    error: ErrorInfo | null;
    metadata?: {
        tool_id: string;
        tool_exec_id: string;
        execution_time?: number;
    };
}

interface ErrorInfo {
    message: string;
    stack?: string;
    name: string;
    tool_id: string;
    tool_exec_id: string;
    timestamp: string;
}

// Redirect all console output methods to stderr to prevent stdout pollution
// This ensures that tool console calls don't interfere with JSON response parsing

// Store the original console.error to use for redirecting other methods
const originalError = console.error;

console.log = (...args: unknown[]): void => {
    originalError("[LOG]", ...args);
};
console.debug = (...args: unknown[]): void => {
    originalError("[DEBUG]", ...args);
};
console.info = (...args: unknown[]): void => {
    originalError("[INFO]", ...args);
};
console.warn = (...args: unknown[]): void => {
    originalError("[WARN]", ...args);
};
console.error = (...args: unknown[]): void => {
    originalError("[ERROR]", ...args);
};

// Utility function to validate tool IDs
function isValidToolId(toolId: string): boolean {
    const validPattern = /^[a-zA-Z0-9_\/.-]+$/;
    if (!validPattern.test(toolId)) return false;
    if (toolId.includes("..") || toolId.startsWith("/")) return false;
    return true;
}

// Utility function to execute tool with timeout
async function executeWithTimeout(
    fn: (input: any) => Promise<any>,
    input: any,
    timeoutMs: number,
): Promise<any> {
    return new Promise((resolve, reject) => {
        const timeoutId = setTimeout(
            () => reject(new Error(`Tool execution timed out after ${timeoutMs}ms`)),
            timeoutMs,
        );
        
        Promise.resolve(fn(input))
            .then((result) => {
                clearTimeout(timeoutId);
                resolve(result);
            })
            .catch((err) => {
                clearTimeout(timeoutId);
                reject(err);
            });
    });
}

// Main execution logic
async function main() {
    let inputText = "";
    
    try {
        // Read input from stdin using Bun's text() method
        inputText = await Bun.stdin.text();
    } catch (err) {
        originalError("Failed to read from stdin:", err);
        process.exit(1);
    }

    let req: Request;
    try {
        req = JSON.parse(inputText.trim());
    } catch (err) {
        originalError("Failed to parse JSON input:", err);
        const errorResponse: Response = {
            result: null,
            error: {
                message: "Invalid JSON input",
                name: "ParseError",
                tool_id: "",
                tool_exec_id: "",
                timestamp: new Date().toISOString(),
            },
        };
        process.stdout.write(JSON.stringify(errorResponse));
        process.exit(1);
    }

    const { tool_id, tool_exec_id, input, env, timeout_ms } = req;

    // Validate tool_id
    if (!tool_id || typeof tool_id !== "string" || !isValidToolId(tool_id)) {
        const errorResponse: Response = {
            result: null,
            error: {
                message: "Invalid tool_id: must be a non-empty string without directory traversal",
                name: "ValidationError",
                tool_id: tool_id || "",
                tool_exec_id: tool_exec_id || "",
                timestamp: new Date().toISOString(),
            },
        };
        process.stdout.write(JSON.stringify(errorResponse));
        process.exit(1);
    }

    // Store and set environment variables with validation
    const originalEnv = { ...process.env };
    const addedEnvKeys = new Set<string>();
    if (env && typeof env === "object") {
        for (const [key, value] of Object.entries(env)) {
            if (typeof key === "string" && typeof value === "string") {
                // Validate environment variable name (uppercase alphanumeric and underscore only)
                if (!/^[A-Z0-9_]+$/.test(key)) {
                    throw new Error(`Invalid environment variable name: ${key}`);
                }
                
                // Validate value - prevent newlines and null bytes
                if (value.includes('\n') || value.includes('\r') || value.includes('\0')) {
                    throw new Error(`Environment variable ${key} contains invalid characters`);
                }
                
                // Check for dangerous environment variables
                const dangerousVars = ['LD_PRELOAD', 'LD_LIBRARY_PATH', 'DYLD_INSERT_LIBRARIES', 
                                     'DYLD_LIBRARY_PATH', 'NODE_OPTIONS', 'BUN_CONFIG_PROFILE'];
                if (dangerousVars.includes(key)) {
                    throw new Error(`Environment variable ${key} is not allowed for security reasons`);
                }
                
                if (!(key in originalEnv)) addedEnvKeys.add(key);
                process.env[key] = value;
            }
        }
    }

    const startTime = Date.now();

    try {
        // Support both export patterns:
        // 1. Default export: export default { "tool_name": toolFunction }
        // 2. Named exports: export const tool_name = toolFunction
        let tools: Record<string, any> = {};
        
        // Check if there's a default export (new standard)
        if (allExports.default && typeof allExports.default === 'object') {
            tools = allExports.default;
        } else {
            // Use named exports (legacy pattern) - exclude 'default' key
            const { default: _, ...namedExports } = allExports;
            tools = namedExports;
        }
        
        const toolFn = tools[tool_id];
        if (typeof toolFn !== "function") {
            const availableTools = Object.keys(tools).filter(key => 
                typeof tools[key] === "function"
            );
            throw new Error(
                `Tool ${tool_id} not found in entrypoint exports. ` +
                `Available tools: ${availableTools.join(", ") || "none"}`
            );
        }

        // Execute tool with configurable timeout (default to 60 seconds if not provided)
        const timeoutMs = timeout_ms || 60000;
        const result = await executeWithTimeout(toolFn, input, timeoutMs);

        // Send success response
        const response: Response = {
            result,
            error: null,
            metadata: { 
                tool_id, 
                tool_exec_id, 
                execution_time: Date.now() - startTime 
            },
        };
        process.stdout.write(JSON.stringify(response));
        
    } catch (err) {
        // Send error response
        const errorInfo: ErrorInfo = {
            message: err instanceof Error ? err.message : String(err),
            stack: err instanceof Error ? err.stack : undefined,
            name: err instanceof Error ? err.name : "UnknownError",
            tool_id,
            tool_exec_id,
            timestamp: new Date().toISOString(),
        };
        
        const response: Response = {
            result: null,
            error: errorInfo,
        };
        process.stdout.write(JSON.stringify(response));
        
    } finally {
        // Clean up environment variables
        try {
            for (const key of addedEnvKeys) {
                delete process.env[key];
            }
            for (const [key, value] of Object.entries(originalEnv)) {
                if (!addedEnvKeys.has(key) && process.env[key] !== value) {
                    process.env[key] = value;
                }
            }
        } catch (cleanupErr) {
            originalError("Error during environment cleanup:", cleanupErr);
        }
    }
}

// Run main
main().catch((err) => {
    originalError("Fatal error:", err);
    process.exit(1);
});
