#!/usr/bin/env deno run --allow-read --allow-net --allow-env
// .compozy/compozy_worker.ts
// Generated by Compozy - DO NOT EDIT

const encoder = new TextEncoder();

// Redirect all console output methods to stderr to prevent stdout pollution
// This ensures that tool console calls don't interfere with JSON response parsing

// Store the original console.error to use for redirecting other methods
const originalError = console.error;

console.log = (...args: unknown[]): void => {
    originalError("[LOG]", ...args);
};
console.debug = (...args: unknown[]): void => {
    originalError("[DEBUG]", ...args);
};
console.info = (...args: unknown[]): void => {
    originalError("[INFO]", ...args);
};
console.warn = (...args: unknown[]): void => {
    originalError("[WARN]", ...args);
};
console.error = (...args: unknown[]): void => {
    originalError("[ERROR]", ...args);
};

// Utility function to validate tool IDs
function isValidToolId(toolId: string): boolean {
    const validPattern = /^[a-zA-Z0-9_\/.-]+$/;
    if (!validPattern.test(toolId)) return false;
    if (toolId.includes("..") || toolId.startsWith("/")) return false;
    return true;
}

// Utility function to execute tool with timeout
// deno-lint-ignore require-await
async function executeWithTimeout(
    fn: (input: any) => Promise<any>,
    input: any,
    timeoutMs: number,
): Promise<any> {
    return new Promise((resolve, reject) => {
        const timeoutId = setTimeout(
            () => reject(new Error(`Tool execution timed out after ${timeoutMs}ms`)),
            timeoutMs,
        );
        Promise.resolve(fn(input))
            .then((result) => {
                clearTimeout(timeoutId);
                resolve(result);
            })
            .catch((err) => {
                clearTimeout(timeoutId);
                reject(err);
            });
    });
}

// Main execution logic
async function main() {
    const decoder = new TextDecoder("utf-8", { stream: true });
    let inputText = "";

    // Read input from stdin
    for await (const chunk of Deno.stdin.readable) {
        inputText += decoder.decode(chunk, { stream: true });
    }
    // Decode any remaining bytes
    inputText += decoder.decode();

    let req;
    try {
        req = JSON.parse(inputText.trim());
    } catch (err) {
        originalError("Failed to parse JSON input:", err);
        Deno.stdout.write(encoder.encode(JSON.stringify({
            error: {
                message: "Invalid JSON input",
                name: "ParseError",
                timestamp: new Date().toISOString(),
            },
        })));
        Deno.exit(1);
    }

    const { tool_id, tool_exec_id, input, env, timeout_ms } = req;

    // Validate tool_id
    if (!tool_id || typeof tool_id !== "string" || !isValidToolId(tool_id)) {
        const errorResponse = {
            error: {
                message: "Invalid tool_id: must be a non-empty string without directory traversal",
                name: "ValidationError",
                tool_id,
                tool_exec_id,
                timestamp: new Date().toISOString(),
            },
        };
        Deno.stdout.write(encoder.encode(JSON.stringify(errorResponse)));
        Deno.exit(1);
    }

    // Store and set environment variables
    const originalEnv = { ...Deno.env.toObject() };
    const addedEnvKeys = new Set<string>();
    if (env && typeof env === "object") {
        for (const [key, value] of Object.entries(env)) {
            if (typeof key === "string" && typeof value === "string") {
                if (!(key in originalEnv)) addedEnvKeys.add(key);
                Deno.env.set(key, value);
            }
        }
    }

    try {
        // Import tool module
        let toolModule;
        try {
            toolModule = await import(tool_id);
        } catch (err) {
            throw new Error(
                `Failed to import tool ${tool_id}: ${
                    err instanceof Error ? err.message : String(err)
                }`,
            );
        }

        // Get tool function
        const toolFn = toolModule.default || toolModule.run;
        if (typeof toolFn !== "function") {
            throw new Error(
                `Tool ${tool_id} does not export a default or run function. Available exports: ${
                    Object.keys(toolModule).join(", ")
                }`,
            );
        }

        // Execute tool with configurable timeout (default to 60 seconds if not provided)
        const timeoutMs = timeout_ms || 60000;
        const result = await executeWithTimeout(toolFn, input, timeoutMs);

        // Write output
        Deno.stdout.write(encoder.encode(JSON.stringify({
            result,
            error: null,
            metadata: { tool_id, tool_exec_id, execution_time: Date.now() },
        })));
    } catch (err) {
        const errorInfo = {
            message: err instanceof Error ? err.message : String(err),
            stack: err instanceof Error ? err.stack : undefined,
            name: err instanceof Error ? err.name : "UnknownError",
            tool_id,
            tool_exec_id,
            timestamp: new Date().toISOString(),
        };
        Deno.stdout.write(encoder.encode(JSON.stringify({ result: null, error: errorInfo })));
    } finally {
        // Clean up environment variables
        try {
            for (const key of addedEnvKeys) Deno.env.delete(key);
            for (const [key, value] of Object.entries(originalEnv)) {
                if (!addedEnvKeys.has(key) && Deno.env.get(key) !== value) {
                    Deno.env.set(key, value);
                }
            }
        } catch (cleanupErr) {
            originalError("Error during environment cleanup:", cleanupErr);
        }
    }
}

// Run main
main().catch((err) => {
    originalError("Fatal error:", err);
    Deno.exit(1);
});
