package server

import (
	"encoding/json"
	"net/http"
	"os"

	"github.com/compozy/compozy/docs"
	"github.com/compozy/compozy/pkg/logger"
	"github.com/getkin/kin-openapi/openapi2"
	"github.com/getkin/kin-openapi/openapi2conv"
	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

const swaggerModelsExpandDepthCollapsed = -1

// setupSwaggerAndDocs wires up both Swagger 2.0 docs (generated by swag)
// and an OpenAPI 3.0 view converted on-the-fly from the Swagger spec.
// Docs are served under /docs; /swagger redirects to maintain backward compatibility.
func setupSwaggerAndDocs(router *gin.Engine, prefixURL string) {
	// Keep Swagger (v2) base settings in sync with runtime prefix
	docs.SwaggerInfo.BasePath = prefixURL
	docs.SwaggerInfo.Host = ""
	docs.SwaggerInfo.Schemes = []string{"http", "https"}

	// Default Docs UI points to OpenAPI v3 JSON
	router.GET("/docs/*any", ginSwagger.WrapHandler(
		swaggerFiles.Handler,
		ginSwagger.URL("/openapi.json"),
		ginSwagger.InstanceName(docs.SwaggerInfo.InstanceName()),
		ginSwagger.DefaultModelsExpandDepth(swaggerModelsExpandDepthCollapsed),
	))

	// Maintain backward compatibility with the legacy Swagger URL.
	router.GET("/swagger/index.html", func(c *gin.Context) {
		c.Redirect(http.StatusMovedPermanently, "/docs/index.html")
	})

	// OpenAPI 3.0: expose converted spec at /openapi.json (top-level to avoid wildcard conflicts)
	router.GET("/openapi.json", func(c *gin.Context) {
		ctx := c.Request.Context()
		log := logger.FromContext(ctx)
		raw := docs.SwaggerInfo.ReadDoc() // rendered swagger v2 JSON string
		if raw == "" || !json.Valid([]byte(raw)) {
			// Fallback to generated file if template rendering returned invalid JSON (rare)
			if b, err := os.ReadFile("docs/swagger.json"); err == nil {
				raw = string(b)
			}
		}
		if raw == "" || !json.Valid([]byte(raw)) {
			log.Error("swagger v2 JSON not available or invalid")
			c.JSON(http.StatusInternalServerError, gin.H{"error": "swagger spec not available"})
			return
		}
		var v2 openapi2.T
		if err := json.Unmarshal([]byte(raw), &v2); err != nil {
			log.Error("failed to unmarshal swagger v2 JSON", "error", err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to unmarshal swagger v2"})
			return
		}
		// Best-effort dynamic host propagation so OpenAPI shows Servers
		if v2.Host == "" {
			v2.Host = c.Request.Host
		}
		v3, err := openapi2conv.ToV3(&v2)
		if err != nil {
			log.Error("failed to convert swagger v2 to openapi v3", "error", err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to convert to openapi v3"})
			return
		}
		// Marshal as JSON
		b, err := json.MarshalIndent(v3, "", "  ")
		if err != nil {
			log.Error("failed to marshal openapi v3", "error", err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to marshal openapi v3"})
			return
		}
		c.Data(http.StatusOK, "application/json; charset=utf-8", b)
	})

	// Note: no separate /openapi UI; /docs is canonical and uses /openapi.json
}
